"""
Test suite for crisis events with mechanical consequences.

This test verifies that crisis events generate `updates` blocks that are
validated and applied to the game state, causing direct mechanical consequences.
"""

import json
import sys
import os

# Import game systems
from game_state import GameState
from engines.crisis_engine import generate_crisis_event, detect_crisis
from engines.state_validator import validate_updates


def test_crisis_event_has_updates():
    """Test that crisis events contain an 'updates' block."""
    print("\n" + "=" * 60)
    print("TEST: Crisis Events Contain Updates Block")
    print("=" * 60)

    # Create a game state with crisis conditions (low food)
    game_state = GameState()
    game_state.civilization['resources']['food'] = 50
    game_state.civilization['population'] = 1000

    # Detect crisis type
    crisis_type = detect_crisis(game_state)
    if not crisis_type:
        print("‚ùå FAIL: No crisis detected with low food")
        return False

    print(f"‚úì Crisis detected: {crisis_type}")

    # Generate crisis event
    try:
        event_data = generate_crisis_event(game_state, crisis_type)
    except Exception as e:
        print(f"‚ùå FAIL: Error generating crisis event: {e}")
        return False

    # Check if updates block exists
    if 'updates' not in event_data:
        print(f"‚ùå FAIL: Crisis event does not contain 'updates' block")
        print(f"Event data keys: {list(event_data.keys())}")
        return False

    print(f"‚úì Crisis event contains 'updates' block")

    # Check if updates block is non-empty
    updates = event_data.get('updates', {})
    if not updates:
        print(f"‚ùå FAIL: Updates block is empty")
        return False

    print(f"‚úì Updates block contains {len(updates)} entries:")
    for key, value in updates.items():
        print(f"  - {key}: {value}")

    return True


def test_crisis_updates_validation():
    """Test that crisis updates pass validation."""
    print("\n" + "=" * 60)
    print("TEST: Crisis Updates Pass Validation")
    print("=" * 60)

    # Create a game state with crisis conditions (low wealth)
    game_state = GameState()
    game_state.civilization['resources']['wealth'] = 50
    game_state.civilization['population'] = 1000

    # Detect crisis type
    crisis_type = detect_crisis(game_state)
    if not crisis_type:
        print("‚ùå FAIL: No crisis detected with low wealth")
        return False

    print(f"‚úì Crisis detected: {crisis_type}")

    # Generate crisis event
    try:
        event_data = generate_crisis_event(game_state, crisis_type)
    except Exception as e:
        print(f"‚ùå FAIL: Error generating crisis event: {e}")
        return False

    updates = event_data.get('updates', {})
    if not updates:
        print(f"‚ö†Ô∏è  SKIP: Updates block is empty (AI may not have generated updates)")
        return True  # Not a failure - AI might need more context

    # Validate updates
    is_valid, cleaned_updates, errors = validate_updates(updates, game_state)

    if errors:
        print(f"‚ö†Ô∏è  Validation warnings found ({len(errors)}):")
        for error in errors:
            print(f"  - {error}")

    if not cleaned_updates:
        print(f"‚ùå FAIL: No valid updates after validation")
        return False

    print(f"‚úì Validation passed with {len(cleaned_updates)} valid updates")
    for key, value in cleaned_updates.items():
        print(f"  - {key}: {value}")

    return True


def test_crisis_updates_application():
    """Test that crisis updates are correctly applied to game state."""
    print("\n" + "=" * 60)
    print("TEST: Crisis Updates Are Applied to Game State")
    print("=" * 60)

    # Create a game state with crisis conditions (famine)
    game_state = GameState()
    initial_population = 1000
    initial_food = 100
    game_state.civilization['population'] = initial_population
    game_state.civilization['resources']['food'] = initial_food

    # Force famine crisis by setting very low food per capita
    game_state.civilization['resources']['food'] = 10  # Very low food

    # Detect and generate crisis
    crisis_type = detect_crisis(game_state)
    if crisis_type != 'famine':
        print(f"‚ö†Ô∏è  SKIP: Expected famine crisis, got {crisis_type}")
        return True

    print(f"‚úì Famine crisis detected")

    # Store initial values
    initial_population = game_state.civilization['population']
    initial_food = game_state.civilization['resources']['food']

    # Generate and apply crisis event
    try:
        from engines.state_updater import apply_updates
        event_data = generate_crisis_event(game_state, crisis_type)
        updates = event_data.get('updates', {})

        if not updates:
            print(f"‚ö†Ô∏è  SKIP: No updates generated by AI")
            return True

        # Validate and apply
        is_valid, cleaned_updates, errors = validate_updates(updates, game_state)
        if cleaned_updates:
            apply_updates(game_state, cleaned_updates)
            print(f"‚úì Updates applied")
        else:
            print(f"‚ö†Ô∏è  SKIP: No valid updates to apply")
            return True

    except Exception as e:
        print(f"‚ùå FAIL: Error applying updates: {e}")
        return False

    # Verify changes
    final_population = game_state.civilization['population']
    final_food = game_state.civilization['resources']['food']

    population_change = final_population - initial_population
    food_change = final_food - initial_food

    print(f"‚úì Population: {initial_population} ‚Üí {final_population} ({population_change:+d})")
    print(f"‚úì Food: {initial_food} ‚Üí {final_food} ({food_change:+d})")

    # Expect negative changes for famine
    if population_change >= 0 and food_change >= 0:
        print(f"‚ö†Ô∏è  WARNING: Expected negative changes for famine, but no losses occurred")

    return True


def test_multiple_crisis_types():
    """Test that different crisis types generate appropriate updates."""
    print("\n" + "=" * 60)
    print("TEST: Different Crisis Types Generate Appropriate Updates")
    print("=" * 60)

    crisis_scenarios = [
        ('famine', {'food': 0, 'population': 1000}),
        ('economic_collapse', {'wealth': 0, 'population': 1000, 'food': 500}),
        ('food_shortage', {'food': 200, 'population': 1000}),
        ('economic_crisis', {'wealth': 50, 'population': 1000, 'food': 500}),
    ]

    results = []

    for crisis_type, conditions in crisis_scenarios:
        game_state = GameState()

        # Set conditions
        for key, value in conditions.items():
            if key == 'food':
                game_state.civilization['resources']['food'] = value
            elif key == 'wealth':
                game_state.civilization['resources']['wealth'] = value
            elif key == 'population':
                game_state.civilization['population'] = value

        # Generate crisis event
        try:
            event_data = generate_crisis_event(game_state, crisis_type)
            updates = event_data.get('updates', {})

            if updates:
                print(f"‚úì {crisis_type}: Generated {len(updates)} updates")
                results.append(True)
            else:
                print(f"‚ö†Ô∏è  {crisis_type}: No updates generated")
                results.append(False)

        except Exception as e:
            print(f"‚ùå {crisis_type}: Error - {e}")
            results.append(False)

    success_rate = sum(results) / len(results) * 100
    print(f"\n‚úì Success rate: {success_rate:.0f}% ({sum(results)}/{len(results)})")

    return success_rate >= 50  # At least 50% should succeed


def run_all_tests():
    """Run all crisis mechanical consequences tests."""
    print("\n" + "=" * 70)
    print("CRISIS MECHANICAL CONSEQUENCES TEST SUITE")
    print("=" * 70)
    print("\nThese tests verify that crisis events include mechanical consequences")
    print("via 'updates' blocks that are validated and applied to the game state.")
    print("=" * 70)

    tests = [
        ("Crisis Events Contain Updates Block", test_crisis_event_has_updates),
        ("Crisis Updates Pass Validation", test_crisis_updates_validation),
        ("Crisis Updates Are Applied to Game State", test_crisis_updates_application),
        ("Different Crisis Types Generate Updates", test_multiple_crisis_types),
    ]

    results = []
    for test_name, test_func in tests:
        try:
            result = test_func()
            results.append((test_name, result))
        except Exception as e:
            print(f"\n‚ùå EXCEPTION in {test_name}: {e}")
            import traceback
            traceback.print_exc()
            results.append((test_name, False))

    # Summary
    print("\n" + "=" * 70)
    print("TEST SUMMARY")
    print("=" * 70)

    passed = sum(1 for _, result in results if result)
    total = len(results)

    for test_name, result in results:
        status = "‚úì PASS" if result else "‚ùå FAIL"
        print(f"{status}: {test_name}")

    print("=" * 70)
    print(f"Total: {passed}/{total} tests passed ({passed/total*100:.0f}%)")
    print("=" * 70)

    if passed == total:
        print("\nüéâ All tests passed!")
    elif passed > 0:
        print(f"\n‚ö†Ô∏è  Some tests failed. {total - passed} test(s) need attention.")
    else:
        print("\n‚ùå All tests failed. Please review the implementation.")

    return passed == total


if __name__ == "__main__":
    success = run_all_tests()
    sys.exit(0 if success else 1)
