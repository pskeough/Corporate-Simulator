================================================================================
GEMINI CAT CODER - PROJECT CODE EXPORT
================================================================================
Project: corporate_simulator_project
Location: C:\Coding Projects\Video Games\Civilization Game Files\corporate_simulator_project
Files Included: 126
Generated: 2025-11-01 01:18:51
================================================================================

This file contains the source code from the project listed above.
Each file section is clearly marked with its path and line numbers.

================================================================================


################################################################################
# FILE: jules_refactor_prompt.txt
# Size: 4729 bytes
################################################################################

/jules

You are an autonomous AI coding agent ("Jules") tasked with a large-scale, asynchronous refactoring project.

## 1. OBJECTIVE
Execute a full thematic refactor of the codebase as defined in `REFACTOR_BLUEPRINT.md`. The goal is to transform a "Civilization Game" into a "Corporate Decision Simulator" (CDS).

## 2. CONTEXT & FILES
* **Primary Instruction Set:** `REFACTOR_BLUEPRINT.md` (Read this first and follow it strictly).
* **Source Code:** All files located in the `old_codebase/` directory.
* **Output Destination:** A new directory you will create, `new_codebase/`.
* **Final Deliverable:** A new GitHub branch named `feat/corporate-sim-refactor-v1` containing the completed `new_codebase/`.

## 3. CORE EXECUTION PLAN
1.  **Create Branch:** Start by creating a new GitHub branch: `feat/corporate-sim-refactor-v1`.
2.  **Create Directory:** Create the `new_codebase/` directory at the project root.
3.  **Iterate and Refactor:** Process *every file* from `old_codebase/`.
    * **Discard:** If a file is on the "Discardable Systems" list in the blueprint (e.g., `visual_engine.py`), **do not** copy it.
    * **Copy & Refactor:** For all other files, copy them to the *identical* path within `new_codebase/` (e.g., `old_codebase/engines/faction_engine.py` -> `new_codebase/engines/faction_engine.py`).
    * **Apply Transformations:** Open the *new* file in `new_codebase/` and apply all relevant transformations from the blueprint.

## 4. TRANSFORMATION RULES

* **For `.py` (Code) Files:**
    * Apply all variable, class, and function name changes from the blueprint (e.g., `civilization.population` -> `company.headcount`).
    * Remove all imports and function calls related to "Discardable Systems."
    * **Apply Code Quality Standards (see section 5).**

* **For `.json` (Data) Files:**
    * Rename the *filename* as specified in the blueprint (e.g., `factions.json` -> `departments.json`).
    * Open the new file and rename *every key* inside it to match the blueprint's mapping (e.g., `faction.name` -> `department.name`).

* **For `.txt` (Prompt) Files:**
    * This is the most critical creative task. **Do not** simply edit the old text.
    * **Delete the old content** and rewrite the *entire prompt from scratch*.
    * The new prompt must perfectly match the "Corporate" persona, professional lexicon, and strategic context defined in the blueprint (e.g., "famine" becomes "budget freeze").
    * Crucially, all new prompts must incorporate the **"Player Ladder"** logic (Step 3.1 in the blueprint), ensuring events are scoped to the user's role (Junior, Manager, CEO).

## 5. CODE QUALITY STANDARDS
You must write code that is easy for another AI to test and diagnose.
* **Documentation:** Add clear, concise docstrings for all refactored functions.
* **Comments:** Add in-line comments explaining *why* a piece of logic exists, especially for complex calculations (e.g., `# Calculate department morale drop based on budget delta`).
* **Labeling:** Use clean, descriptive variable names that match the blueprint (e.g., `political_capital_gain`).
* **Simplicity:** Favor clear, readable code over complex one-liners.

## 6. RESILIENCE & AUTONOMY PROTOCOLS
This is a long-running task. You must handle errors gracefully.
* **Define "Edit Cycle":** An "edit cycle" is one attempt to fix a single file that has failed a test or validation.
* **Protocol 6.1 (Loop Detection):** If you find yourself stuck on a *single file* (e.g., a complex prompt rewrite) and you fail to get it right after **3 consecutive edit cycles**, you must enact the "reset and escalate" protocol.
* **Protocol 6.2 (Reset and Escalate):**
    1.  **Stop:** Stop editing the problematic file.
    2.  **Analyze:** Write an internal analysis (for your own context, not in the code) of *why* it's failing (e.g., "The prompt for `council_engine.py` is too complex and the logic is circular").
    3.  **Attempt 2 (Delete & Regenerate):** Delete the problematic section (e.g., the entire prompt text) and generate a *new, simpler version* from scratch that still meets the blueprint's high-level goal.
* **Protocol 6.3 (Workaround):**
    1.  If the "Delete & Regenerate" attempt fails again, **move on.**
    2.  Delete the problematic file from `new_codebase/`.
    3.  Create a new file `REFACTOR_ISSUES.md` in the `new_codebase/` directory.
    4.  Add a bullet point: `- FAILED: [path/to/file] - Could not refactor. Skipped.`
    5.  Continue to the next file in the queue.

## 7. FINAL OUTPUT
* Commit all changes to the `feat/corporate-sim-refactor-v1` branch.
* The `REFACTOR_ISSUES.md` file (if it exists).
* Report back here with a "TASK_COMPLETE" message.


################################################################################
# FILE: old_codebase\.claude\settings.local.json
# Size: 689 bytes
################################################################################

{
  "permissions": {
    "allow": [
      "Bash(gemini:*)",  
      "Bash(cat:*)",
      "Bash(python:*)",
      "Bash(dir:*)",
      "Bash(findstr:*)",
      "Bash(del test_faction_manager.py test_inner_circle_manager.py)",
      "Bash(run_all_phase3_tests.bat)",
      "Bash(cmd:*)",
      "Bash(if not exist data mkdir data)",
      "Read(//c/**)",
      "Bash(find:*)",
      "Bash(if not exist \"engines\\world_modes\" mkdir \"engines\\world_modes\")",
      "Bash(if not exist \"prompts\\trees\" mkdir \"prompts\\trees\")",
      "Bash(if not exist \"prompts\\visuals\" mkdir \"prompts\\visuals\")",
      "Bash(del test_crisis_parsing.py)"
    ],
    "deny": [],
    "ask": []
  }
}


################################################################################
# FILE: old_codebase\context\civilization_state.json
# Size: 1196 bytes
################################################################################

{
    "meta": {
        "name": "The Golden Mountain Clan",
        "year": -6417,
        "era": "stone_age",
        "founding_date": -6417,
        "world_mode": "historical_earth",
        "earth_region": "nile_valley",
        "butterfly_effects_enabled": true,
        "historical_factions_enabled": false,
        "butterfly_tracker": {
            "divergence_score": 0,
            "timeline_name": "Historical Timeline (Minor Variations)",
            "key_divergences": [],
            "total_divergences": 0,
            "timeline_altered": false
        }
    },
    "leader": {
        "name": "",
        "age": 40,
        "life_expectancy": 55,
        "role": "Leader",
        "traits": [
            "Bold",
            "Pragmatic",
            "Charismatic"
        ],
        "years_ruled": 0,
        "portrait": "leader__1761936732.png"
    },
    "population": 128,
    "resources": {
        "food": 128,
        "wealth": 256,
        "tech_tier": "stone_age"
    },
    "victory_progress": {
        "cultural": 44,
        "technological": 19,
        "military": 0,
        "spiritual": 45,
        "diplomatic": 0
    }
}


################################################################################
# FILE: old_codebase\context\culture.json
# Size: 592 bytes
################################################################################

{
    "values": [
        "Beauty",
        "Expression",
        "Creativity",
        "Tradition",
        "Excellence",
        "Divine Kingship",
        "Monumental Architecture",
        "Eternal Life"
    ],
    "traditions": [
        "Art Festivals",
        "Craftsmanship Competitions",
        "Performance Rituals",
        "Oral Storytelling",
        "Seasonal Celebrations"
    ],
    "taboos": [
        "Harming Kin",
        "Breaking Oaths"
    ],
    "social_structure": "City-state with assembly and elected officials",
    "recent_changes": []
}


################################################################################
# FILE: old_codebase\context\defaults\civilization_state.json
# Size: 568 bytes
################################################################################

{
    "meta": {
        "name": "The Lumina Tribe",
        "year": -71388,
        "era": "classical",
        "founding_date": -20000
    },
    "leader": {
        "name": "Anya, the Seer",
        "age": 552,
        "life_expectancy": 1340,
        "role": "Chieftain",
        "traits": [
            "Prophetic",
            "Diplomatic",
            "Spiritual"
        ],
        "years_ruled": 75
    },
    "population": 3800,
    "resources": {
        "food": 2500,
        "wealth": 3200,
        "tech_tier": "classical"
    }
}


################################################################################
# FILE: old_codebase\context\defaults\culture.json
# Size: 1176 bytes
################################################################################

{
    "values": [
        "Survival",
        "Community",
        "Respect for Elders",
        "Craftsmanship",
        "Adaptation",
        "Aggression",
        "Tradition",
        "Artistic Expression",
        "Destruction",
        "Agriculture",
        "Resilience",
        "Generosity",
        "Wisdom"
    ],
    "traditions": [
        "Oral Storytelling",
        "Seasonal Hunts",
        "Seasonal Hunts and Storytelling Festivals",
        "Seasonal Planting Festivals",
        "Annual Pottery Fairs",
        "Annual Stone Carving Festivals",
        "Order",
        "Farming Festivals",
        "Shelter Maintenance",
        "Farming Innovations",
        "Winter Survival Techniques",
        "Ancestral Veneration"
    ],
    "taboos": [
        "Cannibalism",
        "Harming Kin"
    ],
    "social_structure": "Egalitarian tribe led by a chieftain and council of elders.",
    "recent_changes": [
        "The Grand Effigy was constructed as a sign of devotion to the spirits of the Whispering Caves."
    ],
    "culture_points": 0,
    "current_civic_id": "civic_tribal_code",
    "civic_progress": 0
}


################################################################################
# FILE: old_codebase\context\defaults\history_compressed.json
# Size: 225 bytes
################################################################################

{
    "founding_myth": "In the time before time, the First People emerged from the Whispering Cave, guided by the Great Spirit of the Hunt to this blessed valley.",
    "ancient_eras": [],
    "major_turning_points": []
}


################################################################################
# FILE: old_codebase\context\defaults\history_long.json
# Size: 10375 bytes
################################################################################

{
    "events": [
        {
            "year": -20005,
            "title": "Founding",
            "action": "",
            "narrative": "The tribe settled in the valley."
        },
        {
            "year": -19987,
            "title": "Whispers of the Shaman",
            "action": "Begin reinforcing shelters and gathering extra firewood.",
            "narrative": "Heeding Elara's vision, the tribe immediately set to work reinforcing their shelters and gathering an abundance of firewood. The community's proactive efforts have bolstered their readiness for the coming harsh winter."
        },
        {
            "year": -19986,
            "title": "The Silent Forest",
            "action": "Increase food rationing and focus on gathering edible plants.",
            "narrative": "The tribe implemented stricter food rationing and increased their efforts to gather edible plants. While this conserved existing food stores, the lack of fresh game meant their overall food supply remained strained."
        },
        {
            "year": -19985,
            "title": "The Shadow in the Snow",
            "action": "Send scouts to observe the predator from a safe distance and learn its habits.",
            "narrative": "The scouts bravely ventured towards the western edge, their keen eyes tracking the mysterious predator. They observed from a hidden vantage point, noting the creature's size and hunting patterns, and returned with vital intelligence."
        },
        {
            "year": -19984,
            "title": "The Fading Tracks",
            "action": "i die",
            "narrative": "Chieftain Anu, upon hearing the scouts' report and feeling overwhelmed by the unknown, succumbed to despair and passed away. His reign of five years has come to an abrupt end."
        },
        {
            "year": -19983,
            "title": "The Harsh Winter's Grip",
            "action": "Venture towards the rumored caves to the north, seeking shelter and potential game.",
            "narrative": "A small group braved the blizzard, their determination fueled by desperation. After a grueling trek, they discovered a network of ice-rimmed caves, offering a respite from the storm."
        },
        {
            "year": -19982,
            "title": "Whispers of the Ancients",
            "action": "Send scouts to observe the cave entrance for any signs of activity.",
            "narrative": "Scouts were dispatched to the newly discovered caves. They observed no immediate signs of activity, but the entrance to the caves seemed to hum with a faint, unseen energy."
        },
        {
            "year": -39962,
            "title": "Echoes from the Stone",
            "action": "Attempt to chip away at the resonating stone to study its properties.",
            "narrative": "The attempt to chip away at the resonating stone proved futile, as the tools were too crude to make any impression. However, a faint, warm glow emanated from the stone when struck, hinting at its unusual properties."
        },
        {
            "year": -39961,
            "title": "The Whispering Stone's Secret",
            "action": "Devote more hunters to finding new sources of flint for better tools.",
            "narrative": "The tribe dispatched more hunters to search for flint. Their efforts were successful, leading to the discovery of a new, richer source of high-quality flint, which will allow for the creation of superior tools."
        },
        {
            "year": -39960,
            "title": "The Resonance of the Deep",
            "action": "Avoid the area entirely until the phenomenon subsides.",
            "narrative": "The tribe heeded the Shaman's warning, cautiously avoiding the unsettling area near the new flint deposits. The mysterious hum persisted for a few more days before gradually fading, leaving the agitated animals to calm."
        },
        {
            "year": -39939,
            "title": "The Echoing Tools",
            "action": "Investigate the source of the new flint for more 'special' stones.",
            "narrative": "Chieftain Anu, guided by curiosity and caution, led a small expedition to the new flint source. There, amidst the familiar stones, they discovered a vein of particularly lustrous, faintly shimmering flint."
        },
        {
            "year": -39258,
            "title": "The Whispering Vein",
            "action": "Attempt to craft a tool from the shimmering stone.",
            "narrative": "The attempt to craft a tool from the shimmering stone resulted in an unexpected surge of energy, and the stone crumbled into dust. The craftsman was unharmed, but the unique material was lost."
        },
        {
            "year": -38757,
            "title": "The Curious Luminescence",
            "action": "Study the fungi for its properties.",
            "narrative": "The tribe's scholars carefully studied the phosphorescent fungi, meticulously documenting its properties. Their research revealed that the fungi, when processed, could enhance cognitive function, leading to a small but significant increase in knowledge."
        },
        {
            "year": -38756,
            "title": "The Whispering Gears",
            "action": "Consult the shaman about the cave's spirit.",
            "narrative": "The shaman, after communing with the cave's spirit, confirmed that the rhythmic clicking was not malevolent, but rather the song of the earth itself, guiding the artisans towards a deeper understanding of the world's hidden mechanisms."
        },
        {
            "year": -38255,
            "title": "The Whispering Caves' Divine Mandate",
            "action": "Construct a grand effigy of the Great Spirit of the Hunt.",
            "narrative": "The Lumina Tribe labored for weeks, gathering rare stones and carving sacred symbols to construct the grand effigy. Upon its completion, a hushed awe fell over the tribe as they presented it to the Whispering Caves, hoping the spirits would accept this testament to their devotion."
        },
        {
            "year": -37254,
            "title": "The Unsettling Silence of the Caves",
            "action": "Reinforce the tribe's defenses, just in case.",
            "narrative": "Chieftain Lyra ordered the reinforcement of tribal defenses, and the Lumina Tribe spent the day strengthening their palisades and sharpening their spears. While the immediate threat remained unseen, the added vigilance brought a small measure of comfort to the uneasy villagers."
        },
        {
            "year": -37253,
            "title": "The Whispers Grow Louder",
            "action": "i paint all the huts red with blood of our enemies",
            "narrative": "In a bold display of defiance and power, the tribe's huts were painted crimson with the blood of their enemies. This act intensified the unsettling whispers from the caves, causing a split between those who saw it as a powerful omen and those who feared its dark implications."
        },
        {
            "year": -37251,
            "title": "The Spirits' Discontent",
            "action": "i say that all houses must be red for the erst of time. this is our soul. red hut.",
            "narrative": "Chieftain Lyra, seeking to appease the spirits, declared that all future huts would be built with red clay, a color she proclaimed as the tribe's soul. This decree immediately divided the tribe further, as some saw it as a desperate, uninspired measure, while others believed it was a necessary step to restore balance."
        },
        {
            "year": -36750,
            "title": "The Sacred Echoes",
            "action": "i burn down all houses in the night, going mad and trying to destroy the group",
            "narrative": "In a fit of madness, Kaelen the Stone-Shaper set fire to the tribe's homes, plunging the Lumina Tribe into chaos and despair. The Great Effigy at the Whispering Caves, once a symbol of devotion, now stands amidst the ashes of their civilization."
        },
        {
            "year": -36949,
            "title": "The Unanswered Prayers",
            "action": "a deep cold age beigns, covering the world in snow for 700 years. I say we must hide from the ever present snow",
            "narrative": "A harsh, 700-year cold age descended upon the land, blanketing it in perpetual snow. The Lumina Tribe, heeding Kaelen's words, retreated into their reinforced shelters to survive the encroaching frost."
        },
        {
            "year": -35948,
            "title": "The Whispers of the Effigy",
            "action": "Send a shaman to commune with the spirits at the Whispering Caves.",
            "narrative": "The shaman ventured into the Whispering Caves, returning with a profound understanding. The spirits are indeed pleased with the effigy, but their murmurs are a song of abundance, a promise of bountiful seasons to come."
        },
        {
            "year": -35947,
            "title": "The River's Resonant Song",
            "action": "i fish",
            "narrative": "Heeding the river's song and the shaman's vision, the Lumina Tribe engaged in extensive fishing. The abundance promised by the spirits was realized, bringing a significant haul of fish to bolster their stores."
        },
        {
            "year": -35946,
            "title": "The Whispers of the Great Bear",
            "action": "Send scouts to observe the bear from a safe distance.",
            "narrative": "The scouts returned with tales of the great bear, a majestic and powerful creature. Their observation confirmed its peaceful nature, and the elders interpreted this as a positive omen for the tribe's future prosperity and hunting success."
        },
        {
            "year": -35945,
            "title": "Echoes of the Great Bear",
            "action": "i kill as many of my people as i can",
            "narrative": "In a shocking and devastating turn of events, Kaelen II ordered the sacrifice of a significant portion of the Lumina Tribe. This act of self-destruction has plunged the tribe into disarray, leaving them vulnerable and their future uncertain."
        }
    ]
}


################################################################################
# FILE: old_codebase\context\defaults\religion.json
# Size: 629 bytes
################################################################################

{
    "name": "Animism",
    "type": "Spirit Worship",
    "primary_deity": "The Great Spirit of the Hunt",
    "core_tenets": [
        "All things have a spirit.",
        "The natural world must be respected."
    ],
    "practices": [
        "Shamanic rituals",
        "Cave painting",
        "Spirit Offerings",
        "Harvest Offerings",
        "Symbolic Offerings",
        "Harvest Rituals",
        "Sun appeasement rituals",
        "Ancestral Veneration"
    ],
    "holy_sites": [
        "The Great Oak",
        "Whispering Cave"
    ],
    "influence": "dominant",
    "schisms": []
}


################################################################################
# FILE: old_codebase\context\defaults\technology.json
# Size: 796 bytes
################################################################################

{
    "current_tier": "bronze_age",
    "discoveries": [
        "Fire",
        "Basic Stone Tools",
        "Spears",
        "Improved Stone Tools",
        "Basic Pottery",
        "Advanced Pottery",
        "Preservation Techniques",
        "Advanced Shelters",
        "Advanced Shelter Construction",
        "Preserved Foods",
        "Advanced Hunting Traps",
        "Bronze Casting"
    ],
    "in_progress": [],
    "infrastructure": [
        "Central Campfire",
        "Temporary Shelters",
        "Permanent Huts",
        "Stone Walls",
        "Storage Pits",
        "Reinforced Palisades",
        "Ice Shelters",
        "Watchtowers"
    ],
    "science_points": 0,
    "current_research_id": "tech_agriculture",
    "research_progress": 0
}


################################################################################
# FILE: old_codebase\context\defaults\world_context.json
# Size: 945 bytes
################################################################################

{
    "known_peoples": [
        {
            "name": "The River Clan",
            "relationship": "allied",
            "strength": "unknown",
            "distance": "several days walk",
            "history": "Rarely seen, traded with once for flint."
        },
        {
            "name": "The Sunstone Nomads",
            "relationship": "wary",
            "strength": "unknown",
            "distance": "many days walk",
            "history": "Occasionally sighted, known for their swift raids but also for their intricate metalwork."
        }
    ],
    "geography": {
        "terrain": "Forested valley with a river",
        "climate": "Temperate",
        "resources": [
            "Wild game",
            "Fresh water",
            "Flint"
        ],
        "threats": [
            "Cave Bears",
            "Harsh winters",
            "Raiders",
            "Scarcity"
        ]
    }
}


################################################################################
# FILE: old_codebase\context\factions.json
# Size: 1491 bytes
################################################################################

{
    "factions": [
        {
            "name": "The Hunter Band",
            "leader": "Chief Hunter",
            "approval": 62,
            "support_percentage": 20,
            "status": "Neutral",
            "goals": [
                "Advance hunting and gathering",
                "Increase influence",
                "Secure resources"
            ]
        },
        {
            "name": "The Elders' Circle",
            "leader": "Wise Elder",
            "approval": 61,
            "support_percentage": 22,
            "status": "Neutral",
            "goals": [
                "Advance tradition and wisdom",
                "Increase influence",
                "Secure resources"
            ]
        },
        {
            "name": "The Toolmakers",
            "leader": "Master Craftsman",
            "approval": 61,
            "support_percentage": 29,
            "status": "Neutral",
            "goals": [
                "Advance tool creation",
                "Increase influence",
                "Secure resources"
            ]
        },
        {
            "name": "The Spirit Speakers",
            "leader": "Shaman",
            "approval": 55,
            "support_percentage": 23,
            "status": "Neutral",
            "goals": [
                "Advance spiritual guidance",
                "Increase influence",
                "Secure resources"
            ]
        }
    ]
}


################################################################################
# FILE: old_codebase\context\game_metadata.json
# Size: 103 bytes
################################################################################

{
    "turn_number": 0,
    "active_policy": "military_expansion",
    "population_happiness": 56
}


################################################################################
# FILE: old_codebase\context\history_compressed.json
# Size: 20 bytes
################################################################################

{
    "eras": []
}


################################################################################
# FILE: old_codebase\context\history_long.json
# Size: 22 bytes
################################################################################

{
    "events": []
}


################################################################################
# FILE: old_codebase\context\inner_circle.json
# Size: 2031 bytes
################################################################################

{
    "characters": [
        {
            "name": "Ramesses the Just",
            "role": "War Chief",
            "faction_link": "The Elders' Circle",
            "personality_traits": [
                "Disciplined",
                "Strategic",
                "Brave"
            ],
            "dialogue_sample": "I serve our people with disciplined dedication.",
            "history": [
                "Appointed as War Chief."
            ],
            "metrics": {
                "relationship": 59,
                "influence": 47,
                "loyalty": 58
            },
            "portrait": "advisor_ramesses_the_just_1761936741.png"
        },
        {
            "name": "Cleopatra the Great",
            "role": "Wise Elder",
            "faction_link": "The Elders' Circle",
            "personality_traits": [
                "Wise",
                "Diplomatic",
                "Cautious"
            ],
            "dialogue_sample": "I serve our people with wise dedication.",
            "history": [
                "Appointed as Wise Elder."
            ],
            "metrics": {
                "relationship": 56,
                "influence": 47,
                "loyalty": 72
            },
            "portrait": "advisor_cleopatra_the_great_1761936748.png"
        },
        {
            "name": "Nefertari the Wise",
            "role": "Shaman",
            "faction_link": "The Elders' Circle",
            "personality_traits": [
                "Pious",
                "Contemplative",
                "Influential"
            ],
            "dialogue_sample": "I serve our people with pious dedication.",
            "history": [
                "Appointed as Shaman."
            ],
            "metrics": {
                "relationship": 59,
                "influence": 44,
                "loyalty": 66
            },
            "portrait": "advisor_nefertari_the_wise_1761936756.png"
        }
    ]
}


################################################################################
# FILE: old_codebase\context\religion.json
# Size: 509 bytes
################################################################################

{
    "name": "Animism",
    "type": "Spirit Worship",
    "primary_deity": "The Nile Spirit",
    "core_tenets": [
        "All things have a spirit",
        "The natural world must be respected",
        "Balance must be maintained"
    ],
    "practices": [
        "Shamanic rituals",
        "Spirit offerings",
        "Nature veneration"
    ],
    "holy_sites": [
        "The Sacred Spring",
        "The Ancient Shrine"
    ],
    "influence": "significant",
    "schisms": []
}


################################################################################
# FILE: old_codebase\context\technology.json
# Size: 315 bytes
################################################################################

{
    "current_tier": "stone_age",
    "discoveries": [
        "Fire",
        "Stone Tools",
        "Spears",
        "Basic Agriculture",
        "Pottery"
    ],
    "in_progress": [],
    "infrastructure": [
        "Central Hearth",
        "Temporary Shelters",
        "Food Storage"
    ]
}


################################################################################
# FILE: old_codebase\context\world_context.json
# Size: 1135 bytes
################################################################################

{
    "known_peoples": [
        {
            "name": "Early Saharan peoples",
            "relationship": "wary",
            "strength": "unknown",
            "distance": "distant",
            "history": "Historical presence in the Nile River Valley"
        },
        {
            "name": "Proto-Egyptians",
            "relationship": "neutral",
            "strength": "unknown",
            "distance": "several days journey",
            "history": "Historical presence in the Nile River Valley"
        }
    ],
    "geography": {
        "region": "Nile River Valley",
        "terrain": "Narrow fertile corridor along the Nile, surrounded by vast deserts",
        "climate": "Hot desert - scorching summers, predictable annual floods",
        "resources": [
            "Grain",
            "Papyrus",
            "Fish",
            "Gold",
            "Stone",
            "Natron",
            "Linen"
        ],
        "threats": [
            "Desert raiders",
            "Flooding extremes",
            "Scorching heat",
            "Limited arable land"
        ]
    }
}


################################################################################
# FILE: old_codebase\data\tech_tree.json
# Size: 1436 bytes
################################################################################

{
  "technologies": [
    {
      "id": "tech_agriculture",
      "name": "Agriculture",
      "description": "The cultivation of crops and domestication of animals for food production",
      "era": "stone_age",
      "unlocks_buildings": ["building_granary_001"],
      "prerequisites": []
    },
    {
      "id": "tech_writing",
      "name": "Writing",
      "description": "The ability to record and preserve knowledge through symbols and scripts",
      "era": "bronze_age",
      "unlocks_buildings": ["building_library_001"],
      "prerequisites": []
    },
    {
      "id": "tech_metalworking",
      "name": "Metalworking",
      "description": "The knowledge of extracting and shaping metals into tools and weapons",
      "era": "bronze_age",
      "unlocks_buildings": ["building_workshop_001", "building_barracks_001"],
      "prerequisites": []
    },
    {
      "id": "tech_currency",
      "name": "Currency",
      "description": "A standardized system of exchange using coins or other tradeable items",
      "era": "bronze_age",
      "unlocks_buildings": ["building_market_001"],
      "prerequisites": []
    },
    {
      "id": "tech_masonry",
      "name": "Masonry",
      "description": "The craft of building structures from stone and brick",
      "era": "bronze_age",
      "unlocks_buildings": ["building_temple_001"],
      "prerequisites": []
    }
  ]
}



################################################################################
# FILE: old_codebase\docs\bonus_system.md
# Size: 4432 bytes
################################################################################

# Bonus System Documentation

## Overview
The BonusEngine provides centralized calculation of all game bonuses from multiple sources.

## Architecture

### Components
- `engines/bonus_definitions.py` - Defines all bonus types and values
- `engines/bonus_engine.py` - Aggregates bonuses from all sources
- `engines/world_turns_engine.py` - Uses BonusEngine for per-turn calculations

### Bonus Sources
1. **Characters** (Inner Circle) - Role-based bonuses
2. **Buildings** (Infrastructure) - Placeholder for future implementation
3. **Technologies** (Discoveries) - Placeholder for future implementation
4. **Leader Traits** - Placeholder for future implementation

## Adding New Bonuses

### For Characters (Current)
Edit `engines/bonus_definitions.py`:

```python
CHARACTER_ROLE_BONUSES = {
    'New Role': {
        'science_per_turn': 10,
        'description': 'Role description'
    }
}
```

### For Buildings (Future - Phase 4)
Edit `engines/bonus_definitions.py`:

```python
BUILDING_BONUSES = {
    'Library': {
        'science_per_turn': 5,
        'description': 'Libraries preserve knowledge',
        'cost': {'wealth': 500},
        'era_required': 'bronze_age'
    }
}
```

**No code changes needed** - BonusEngine automatically picks up new definitions!

### For Technologies (Future - Phase 4)
Edit `engines/bonus_definitions.py`:

```python
TECHNOLOGY_BONUSES = {
    'Writing': {
        'science_per_turn': 3,
        'culture_per_turn': 2,
        'description': 'Recording knowledge'
    }
}
```

## Bonus Types

- `food_per_turn` - Food production per turn
- `wealth_per_turn` - Wealth production per turn
- `science_per_turn` - Science points per turn
- `culture_per_turn` - Culture points per turn
- `population_growth` - Population growth modifier
- `happiness` - Happiness modifier

## Testing

Run the test script to verify bonus calculations:

```bash
python test_bonus_engine.py
```

This will:
- Load the current game state
- Calculate all active bonuses
- Verify bonuses match expected values
- Display a detailed bonus summary

## Future Extensions

- [ ] Multiplier bonuses (e.g., +20% food production)
- [ ] Conditional bonuses (e.g., "if near river")
- [ ] Stacking rules (e.g., diminishing returns)
- [ ] Temporary bonuses (e.g., event-based buffs)

## Usage Example

```python
from game_state import GameState
from engines.bonus_engine import BonusEngine
from engines.bonus_definitions import BonusType

# Load game state
game = GameState()

# Create bonus engine
engine = BonusEngine()

# Get science bonuses
science = engine.calculate_bonuses(game, BonusType.SCIENCE_PER_TURN)
print(f"Total science bonus: +{science['total']}")

# Show sources
for source_type, source_name, value in science['sources']:
    print(f"  +{value} from {source_type}: {source_name}")

# Get all active bonuses
all_bonuses = engine.get_all_active_bonuses(game)
print(engine.format_bonus_summary(game))
```

## API Integration

The dashboard API (`/api/dashboard`) automatically includes bonus data:

```json
{
  "active_bonuses": {
    "science_per_turn": {
      "total": 5,
      "sources": [
        {"type": "character", "name": "Scholar Name", "value": 5}
      ]
    }
  }
}
```

## Implementation Notes

### Phase 3 (Current)
- ‚úÖ Bonus definitions centralized
- ‚úÖ BonusEngine aggregates from all sources
- ‚úÖ world_turns_engine.py uses BonusEngine
- ‚úÖ Dashboard API exposes bonus data
- ‚úÖ Parallel verification ensures equivalence

### Phase 4 (Future)
- Building construction system
- Technology tree with prerequisites
- Full migration away from hardcoded formulas

## Troubleshooting

### Bonuses not appearing?
1. Check that the bonus source exists (character role, building, etc.)
2. Verify bonus definition in `bonus_definitions.py`
3. Run `test_bonus_engine.py` to see detailed output
4. Check game state files in `context/` directory

### Mismatch warnings?
If you see "‚ö† BONUS MISMATCH" in console:
1. Compare old vs new calculations
2. Check for edge cases in bonus logic
3. Verify BonusEngine correctly reads game state
4. Report issue with specific values

## TODO Phase 4: Implement building construction system
## TODO Phase 4: Add technology tree with prerequisites
## TODO Phase 4: Implement leader trait evolution



################################################################################
# FILE: old_codebase\engines\action_processor.py
# Size: 43020 bytes
################################################################################

# engines/action_processor.py
"""
Action Processor Module

This module handles processing player actions, determining outcomes,
and managing the consequences of decisions in the game.

Refactored from event_engine.py for better maintainability and separation of concerns.
"""

import google.generativeai as genai
import json
from json import JSONDecodeError
import re
from engines.context_builder import build_action_context
from engines.state_validator import validate_updates, get_validation_summary
from engines.event_generator import api_call_with_retry
from engines.state_updater import apply_updates
from engines.prompt_loader import load_prompt
from model_config import TEXT_MODEL

def process_player_action(game_state, action, event_title, event_narrative):
    """Determines the outcome of a player's FINAL action and applies it (ends the event)."""
    print(f"--- Asking Gemini for outcome of '{action}' (FINAL RESOLUTION) ---")
    model = genai.GenerativeModel(TEXT_MODEL)

    # Build optimized action context
    context = build_action_context(game_state)

    # Build conversation history for context
    conversation_summary = ""
    if game_state.event_conversation:
        conversation_summary = "\n".join([
            f"- Player {entry['player']}: {entry['ai']}"
            for entry in game_state.event_conversation
        ])
        conversation_summary = f"\n<CONVERSATION_HISTORY>\nThe player investigated before deciding:\n{conversation_summary}\n</CONVERSATION_HISTORY>\n"

    # Contextualize the civilization state for outcomes
    pop = context['civilization']['population']
    food = context['civilization']['resources']['food']
    wealth = context['civilization']['resources']['wealth']
    leader_age = context['civilization']['leader']['age']

    # Determine if resources are strained
    food_per_capita = food / max(pop, 1)
    resource_state = ""
    if food_per_capita < 0.5:
        resource_state = "Your people are starving. "
    elif wealth < 50:
        resource_state = "Your treasury is nearly empty. "
    elif food_per_capita > 3.0 and wealth > 3000:
        resource_state = "Your civilization is wealthy and well-fed. "

    # Pre-calculate all formatted values before loading the prompt
    pop_formatted = f"{pop:,}"
    food_formatted = f"{food:,}"
    wealth_formatted = f"{wealth:,}"
    culture_values = ', '.join(context['culture']['values'][:5])
    culture_values_short = ', '.join(context['culture']['values'][:3])
    leader_traits = ', '.join(context['civilization']['leader']['traits'])
    recent_discoveries = ', '.join(context['technology']['recent_discoveries'][-3:])

    # Load prompt template and fill in variables
    prompt_template = load_prompt('actions/process_player_action')
    prompt = prompt_template.format(
        event_title=event_title,
        event_narrative=event_narrative,
        conversation_summary=conversation_summary,
        action=action,
        civ_name=context['civilization']['meta']['name'],
        year=context['civilization']['meta']['year'],
        leader_name=context['civilization']['leader']['name'],
        leader_age=leader_age,
        population=pop_formatted,
        food=food_formatted,
        wealth=wealth_formatted,
        resource_state=resource_state,
        tech_tier=context['civilization']['resources']['tech_tier'],
        culture_values=culture_values,
        culture_values_short=culture_values_short,
        leader_traits=leader_traits,
        religion_name=context['religion']['name'],
        religion_influence=context['religion']['influence'],
        recent_discoveries=recent_discoveries,
        terrain=context['world']['geography']['terrain']
    )

    try:
        # Use retry wrapper for API call
        def make_api_call():
            response = model.generate_content(
                prompt,
                generation_config={
                    "response_mime_type": "application/json",
                    "temperature": 0.7  # Balanced creativity for outcomes
                }
            )
            return response

        response = api_call_with_retry(make_api_call, max_retries=3, initial_delay=2.0)

        # FIX: Sanitize response to remove XML tags, Markdown code fences, and reasoning blocks
        raw_text = response.text.strip()

        # Remove XML-style wrapper tags (e.g., <reasoning>, <thinking>, etc.)
        raw_text = re.sub(r'^<[^>]+>.*?</[^>]+>\s*', '', raw_text, flags=re.DOTALL)

        # Extract JSON from code fences if present
        json_match = re.search(r'```json\s*(\{.*?\})\s*```', raw_text, re.DOTALL)
        if json_match:
            raw_text = json_match.group(1)
        else:
            # Fallback: Remove any remaining code fences
            if raw_text.startswith("```json"):
                raw_text = raw_text[7:]
            elif raw_text.startswith("```"):
                raw_text = raw_text[3:]
            if raw_text.endswith("```"):
                raw_text = raw_text[:-3]

        raw_text = raw_text.strip()
        print(f"DEBUG: Sanitized response (first 200 chars): {raw_text[:200]}")

        outcome = json.loads(raw_text)

        # FIX: Handle nested 'output' key if AI wraps response
        if "output" in outcome and isinstance(outcome["output"], dict):
            outcome = outcome["output"]

        print(f"--- Gemini Outcome Received ---\n{json.dumps(outcome, indent=2)}\n-----------------------------")
    except JSONDecodeError as e:
        print(f"!!!!!!!!!! JSON PARSING ERROR (Outcome) !!!!!!!!!!!\nFailed to parse AI response: {e}")
        print(f"Raw response: {response.text if 'response' in locals() else 'No response'}")
        return {
            "narrative": "The consequences of your action are unclear. The spirits speak in riddles, but the world endures.",
            "updates": {},
            "status": "error"
        }
    except Exception as e:
        error_msg = str(e).lower()
        print(f"!!!!!!!!!! GEMINI API ERROR (Outcome) !!!!!!!!!!!\n{e}")

        # Provide specific, actionable error messages
        if "oauth" in error_msg or "token" in error_msg or "authentication" in error_msg:
            narrative = "‚ö†Ô∏è Authentication Error: Your API credentials have expired. Please update your GEMINI_API_KEY and restart the game."
        elif "404" in error_msg or "not found" in error_msg:
            narrative = "‚ö†Ô∏è API Error: The AI model is not available. Please check your GEMINI_API_KEY and model configuration."
        elif "quota" in error_msg or "rate limit" in error_msg:
            narrative = "‚ö†Ô∏è Rate Limit: API quota exceeded. Please wait a few minutes before continuing."
        else:
            narrative = f"‚ö†Ô∏è API Error: Unable to process your action due to a technical issue. The world holds its breath... (Error: {str(e)[:100]})"

        print(f"NOTE: {narrative}")
        return {
            "narrative": narrative,
            "updates": {},
            "status": "error"
        }

    try:
        # Validate updates before applying
        if "updates" in outcome and outcome["updates"]:
            is_valid, cleaned_updates, errors = validate_updates(outcome["updates"], game_state)

            if errors:
                print(f"--- Validation Warnings ---")
                validation_summary = get_validation_summary(errors)
                print(validation_summary)

            if cleaned_updates:
                print("--- Applying Validated Updates ---")
                apply_updates(game_state, cleaned_updates)
            else:
                print("--- No valid updates to apply ---")
        else:
            print("--- No updates from AI ---")

        # Check if this was a building construction decision
        if "construct" in action.lower() or "build" in action.lower():
            from engines.building_manager import BuildingManager
            building_manager = BuildingManager()

            # Try to match action to a building
            for building_id, building_def in building_manager.get_all_building_types().items():
                if building_def['name'].lower() in action.lower():
                    # Attempt to start construction
                    success, msg = building_manager.start_construction(building_id, game_state)
                    if success:
                        print(f"  üèóÔ∏è {msg}")
                    else:
                        print(f"  ‚ö†Ô∏è Building construction failed: {msg}")
                    break

        # Check if this was a character vignette completion (grant faction approval bonus)
        if hasattr(game_state, 'current_event') and game_state.current_event.get('event_type') == 'character_vignette':
            character_name = game_state.current_event.get('character_name')
            if character_name and hasattr(game_state, 'inner_circle_manager') and hasattr(game_state, 'faction_manager'):
                # Look up the character
                character = game_state.inner_circle_manager.get_by_name(character_name)
                if character:
                    faction_id = character.get('faction_id')
                    if faction_id:
                        # Apply approval bonus for personal relationship building
                        approval_change = 5
                        success = game_state.faction_manager.update_approval(faction_id, approval_change)
                        if success:
                            # Add history entry
                            game_state.faction_manager.add_history_entry(
                                faction_id,
                                f"Personal conversation with {character_name}",
                                approval_change,
                                game_state.turn_number
                            )
                            faction = game_state.faction_manager.get_by_id(faction_id)
                            faction_name = faction.get('name', 'Unknown Faction') if faction else 'Unknown Faction'
                            print(f"  üí¨ Vignette completed: {faction_name} approval +{approval_change} (now {faction['approval']})")
                        else:
                            print(f"  ‚ö†Ô∏è Warning: Failed to update approval for faction {faction_id}")
                    else:
                        print(f"  ‚ÑπÔ∏è Character {character_name} has no faction affiliation")
                else:
                    print(f"  ‚ö†Ô∏è Warning: Character {character_name} not found")

        # Check if this was a faction audience decision (BALANCE_OVERHAUL: Apply asymmetric consequences)
        if hasattr(game_state, 'current_event') and game_state.current_event.get('event_type') == 'faction_audience':
            # Parse which faction was chosen and which were opposed from the action text
            # Extract faction names from the petitions
            petitions = game_state.current_event.get('petitions', [])

            # Identify chosen faction by matching action text to faction names
            chosen_faction = None
            for petition in petitions:
                faction_name = petition.get('faction', '')
                if faction_name.lower() in action.lower():
                    chosen_faction = faction_name
                    break

            if chosen_faction:
                # All other factions in the petition are opposed
                opposed_factions = [p.get('faction') for p in petitions if p.get('faction') != chosen_faction]
                print(f"--- Applying faction decision consequences: {chosen_faction} favored ---")
                from engines.faction_engine import apply_faction_decision_consequences
                apply_faction_decision_consequences(game_state, chosen_faction, opposed_factions)

        # Track consequences of this action
        from engines.consequence_engine import apply_consequences, detect_major_declaration

        consequences = apply_consequences(game_state, action, event_title, outcome.get("narrative", ""))

        # Check if this is a major declaration that should become a permanent decree
        major_declaration = detect_major_declaration(action, event_title, outcome.get("narrative", ""))
        if major_declaration:
            print(f"\nüèõÔ∏è MAJOR DECLARATION DETECTED: {major_declaration['type']} ({major_declaration['importance']})")
            print(f"   Significance Score: {major_declaration['significance_score']}")

            # Create permanent decree
            from engines.law_engine import LawEngine
            from engines.history_compression_engine import HistoryCompressionEngine

            law_engine = LawEngine(game_state)

            # Infer effects from the declaration text
            effects = _infer_decree_effects(major_declaration, game_state)

            # Create the decree
            decree = law_engine.create_decree(
                decree_type=major_declaration['type'],
                title=_generate_decree_title(major_declaration),
                declaration_text=major_declaration['action_text'],
                declared_by=game_state.civilization['leader']['name'],
                effects=effects,
                importance=major_declaration['importance']
            )

            # Add to state and apply effects
            impact_narrative = law_engine.add_decree_to_state(decree)
            print(f"   üìú Permanent decree created: {decree['title']}")
            print(f"   ‚öñÔ∏è {impact_narrative}")

            # Archive in compressed history
            if major_declaration['importance'] == 'civilization_defining':
                history_engine = HistoryCompressionEngine(game_state)
                history_engine.archive_decree(decree)
                print(f"   üìö Archived as civilization-defining moment")

        # Check faction goals against turn outcome (passive faction simulation)
        _check_faction_goals(game_state, outcome, action, event_title)

        # Extract and save policy from council meetings
        if "council" in event_title.lower() or "briefing" in event_title.lower():
            # Parse policy from player's action
            policy_keywords = {
                'military': 'military_expansion',
                'defense': 'military_expansion',
                'war': 'military_expansion',
                'army': 'military_expansion',
                'trade': 'economic_growth',
                'merchant': 'economic_growth',
                'commerce': 'economic_growth',
                'wealth': 'economic_growth',
                'temple': 'religious_devotion',
                'faith': 'religious_devotion',
                'prayer': 'religious_devotion',
                'divine': 'religious_devotion',
                'knowledge': 'scientific_advancement',
                'research': 'scientific_advancement',
                'scholar': 'scientific_advancement',
                'discovery': 'scientific_advancement',
                'culture': 'cultural_development',
                'art': 'cultural_development',
                'tradition': 'cultural_development',
                'expand': 'territorial_expansion',
                'settle': 'territorial_expansion',
                'explore': 'exploration'
            }

            # Check action text for policy keywords
            action_lower = action.lower()
            detected_policy = None
            for keyword, policy in policy_keywords.items():
                if keyword in action_lower:
                    detected_policy = policy
                    break

            # Default to general governance if no specific policy detected
            if detected_policy:
                game_state.active_policy = detected_policy
                print(f"  üìú Active policy set to: {detected_policy}")
            elif game_state.active_policy is None:
                game_state.active_policy = "general_governance"
                print(f"  üìú Active policy defaulted to: general_governance")

        # Log event to history
        log_entry = {
            "year": game_state.civilization['meta']['year'],
            "title": event_title,
            "action": action,
            "narrative": outcome.get("narrative", "The consequences are unclear.")
        }
        game_state.history_long["events"].append(log_entry)

        # Apply resource consumption
        from engines.resource_engine import apply_consumption, apply_passive_generation

        # First, apply passive generation (civilization produces resources)
        production = apply_passive_generation(game_state)
        print(f"  üìà Passive production: +{production['food']} food, +{production['wealth']} wealth")

        # Then apply consumption
        consumption_status = apply_consumption(game_state)
        print(f"  üìâ Consumption: -{consumption_status['food_consumed']} food, -{consumption_status['wealth_consumed']} wealth")

        # Apply automatic happiness changes from resource scarcity (Fix #6)
        from engines.resource_engine import calculate_resource_happiness_impact
        happiness_impact = calculate_resource_happiness_impact(game_state)
        if happiness_impact != 0:
            game_state.population_happiness = max(0, min(100, game_state.population_happiness + happiness_impact))
            if happiness_impact < 0:
                print(f"  üòû Happiness decreased by {abs(happiness_impact)} (resource scarcity)")
            else:
                print(f"  üòä Happiness increased by {happiness_impact} (prosperity)")

        # Apply faction approval happiness modifier
        faction_bonuses = game_state.faction_manager.get_faction_bonuses(game_state)
        game_state.population_happiness += faction_bonuses['happiness_modifier']
        game_state.population_happiness = max(0, min(100, game_state.population_happiness))
        if faction_bonuses['happiness_modifier'] != 0:
            print(f"  üôÇ Faction approval changed happiness by {faction_bonuses['happiness_modifier']:+d}")

        # Add consumption warnings to outcome if any
        if consumption_status['warnings']:
            outcome['resource_warnings'] = consumption_status['warnings']
            outcome['consumption_effects'] = {}

            if 'starvation_deaths' in consumption_status:
                outcome['consumption_effects']['population_loss'] = consumption_status['starvation_deaths']
                print(f"  ‚ò†Ô∏è Starvation! Population loss: -{consumption_status['starvation_deaths']}")

            if 'infrastructure_lost' in consumption_status:
                outcome['consumption_effects']['infrastructure_lost'] = consumption_status['infrastructure_lost']
                print(f"  üèöÔ∏è Bankruptcy! Infrastructure lost: {', '.join(consumption_status['infrastructure_lost'])}")

        # Process building construction (Phase 4)
        from engines.building_manager import BuildingManager
        building_manager = BuildingManager()
        completed_buildings = building_manager.process_turn(game_state)
        if completed_buildings:
            for building_name in completed_buildings:
                print(f"  üèõÔ∏è Construction complete: {building_name}")
                outcome['construction_complete'] = completed_buildings

        # Automatic state progression
        game_state.civilization['leader']['age'] += 1
        game_state.civilization['leader']['years_ruled'] += 1
        game_state.civilization['meta']['year'] += 1
        game_state.turn_number += 1

        # Apply aging effects and trait changes
        from engines.leader_engine import apply_aging_effects, calculate_leader_effectiveness

        aging_changes = apply_aging_effects(game_state)
        if aging_changes:
            for change in aging_changes:
                print(f"  üë§ Leader {change}")

        # Check if leader portrait should be updated
        from engines.image_update_manager import should_update_leader_portrait, get_tracker
        tracker = get_tracker()
        tracker.increment_turns()

        should_update, reason = should_update_leader_portrait(game_state, aging_changes)
        if should_update:
            print(f"  üé® Updating leader portrait: {reason}")
            # Trigger background portrait update
            from engines.visual_engine import update_leader_portrait_async
            update_leader_portrait_async(game_state)

        # Calculate leader effectiveness for bonuses
        effectiveness = calculate_leader_effectiveness(game_state.civilization['leader'])
        print(f"  üí™ Leader effectiveness: {effectiveness:.2f}x")

        # Check if leader exceeds life expectancy and warn
        leader_age = game_state.civilization['leader']['age']
        life_exp = game_state.civilization['leader'].get('life_expectancy', 60)
        if leader_age > life_exp:
            print(f"  ‚ö† Warning: Leader age ({leader_age}) exceeds life expectancy ({life_exp}). Consider abdication.")

        # Process science and culture progression
        from engines.bonus_engine import BonusEngine
        from engines.bonus_definitions import BonusType

        bonus_engine = BonusEngine()
        science_result = bonus_engine.calculate_bonuses(game_state, BonusType.SCIENCE_PER_TURN)
        culture_result = bonus_engine.calculate_bonuses(game_state, BonusType.CULTURE_PER_TURN)

        science_income = int(science_result['total'])
        culture_income = int(culture_result['total'])

        # Apply science progression
        if science_income > 0:
            # Initialize science_points if not present (backwards compatibility)
            if 'science_points' not in game_state.technology:
                game_state.technology['science_points'] = 0

            game_state.technology['science_points'] += science_income
            print(f"  üî¨ Science: +{science_income} points (Total: {game_state.technology['science_points']})")

            current_research_id = game_state.technology.get('current_research_id')
            if current_research_id:
                # Load tech tree to get cost
                try:
                    import os
                    tech_tree_path = os.path.join('data', 'tech_tree.json')
                    if os.path.exists(tech_tree_path):
                        with open(tech_tree_path, 'r') as f:
                            tech_tree_data = json.load(f)
                            technologies = tech_tree_data.get('technologies', [])

                            # Find the current research node
                            current_tech = None
                            for tech in technologies:
                                if tech.get('id') == current_research_id:
                                    current_tech = tech
                                    break

                            if current_tech:
                                tech_cost = current_tech.get('cost', 999)
                                game_state.technology['research_progress'] += science_income

                                print(f"  üìñ Researching '{current_tech['name']}': {game_state.technology['research_progress']}/{tech_cost}")

                                if game_state.technology['research_progress'] >= tech_cost:
                                    # Technology unlocked!
                                    tech_name = current_tech['name']
                                    print(f"  ‚ú® TECHNOLOGY UNLOCKED: {tech_name}!")

                                    # Add to discoveries if not already present
                                    if tech_name not in game_state.technology.get('discoveries', []):
                                        game_state.technology['discoveries'].append(tech_name)

                                    # Clear current research
                                    game_state.technology['current_research_id'] = None
                                    game_state.technology['research_progress'] = 0

                                    # Add to outcome for visibility
                                    outcome['tech_unlocked'] = tech_name
                except Exception as e:
                    print(f"  ‚ö†Ô∏è Error processing tech progression: {e}")

        # Apply culture progression
        if culture_income > 0:
            # Initialize culture_points if not present (backwards compatibility)
            if 'culture_points' not in game_state.culture:
                game_state.culture['culture_points'] = 0

            game_state.culture['culture_points'] += culture_income
            print(f"  üé≠ Culture: +{culture_income} points (Total: {game_state.culture['culture_points']})")

            current_civic_id = game_state.culture.get('current_civic_id')
            if current_civic_id:
                # For MVP, use a placeholder cost since civics tree doesn't exist yet
                # In future, this will load from data/civics_tree.json
                civic_cost = 30  # Placeholder cost for test civic
                civic_name = "Tribal Code"  # Placeholder name

                game_state.culture['civic_progress'] += culture_income

                print(f"  üìú Adopting '{civic_name}': {game_state.culture['civic_progress']}/{civic_cost}")

                if game_state.culture['civic_progress'] >= civic_cost:
                    # Civic unlocked!
                    print(f"  ‚ú® CIVIC ADOPTED: {civic_name}!")

                    # Add to traditions if not already present
                    if civic_name not in game_state.culture.get('traditions', []):
                        game_state.culture['traditions'].append(civic_name)

                    # Clear current civic
                    game_state.culture['current_civic_id'] = None
                    game_state.culture['civic_progress'] = 0

                    # Add to outcome for visibility
                    outcome['civic_adopted'] = civic_name

        return outcome
    except Exception as e:
        print(f"!!!!!!!!!! STATE UPDATE ERROR !!!!!!!!!!!\n{e}")
        return {"narrative": f"A critical error occurred while applying updates: {e}", "updates": {}, "status": "error"}

def generate_interpretation_event(completed_item):
    """
    Generates a special "Interpretation Event" when a new technology or civic is discovered.
    This event prompts the player to decide how to apply the new discovery.
    """
    item_name = completed_item.get("name", "a new discovery")
    item_description = completed_item.get("description", "a significant breakthrough")

    # This prompt is sent to an AI to generate the event details.
    # For now, we are just constructing the prompt and returning a placeholder.
    prompt = f"""
You are the master storyteller for a civilization simulation game.
The player's civilization has just discovered "{item_name}": {item_description}.

<TASK>
Generate a special "Interpretation Event" to reflect this discovery. The event should offer the player a choice on how to interpret and apply this new knowledge.

The event must include:
1.  A `title`: A short, evocative title related to the discovery (e.g., "The Iron Age Dawns," "A New Philosophy").
2.  A `narrative`: 2-3 sentences describing the breakthrough and the new possibilities it opens up for the civilization.
3.  `decision_options`: 2-3 distinct strategic choices for how to apply "{item_name}". Each option should represent a different focus.

<EXAMPLE for "Iron Working">
{{
  "title": "The Age of Iron",
  "narrative": "Our blacksmiths have unlocked the secrets of iron, a metal far stronger than bronze. This discovery could reshape our society, from the tools in our fields to the swords in our soldiers' hands. How shall we direct this newfound power?",
  "decision_options": [
    "Focus on military tools (Forge superior weapons and armor)",
    "Develop agricultural implements (Create better plows and tools for farming)",
    "Promote artisan metalworking (Encourage the creation of iron goods and crafts)"
  ]
}}
</EXAMPLE>

<YOUR_TASK>
Now, generate a similar event for the discovery of "{item_name}".

Output ONLY valid JSON with the fields: "title", "narrative", and "decision_options".
"""

    # In a real implementation, we would call the AI model here with the prompt.
    # For now, we return a placeholder.
    print(f"--- Interpretation Event prompt generated for: {item_name} ---")
    # print(prompt) # Uncomment for debugging the prompt

    return {
        "title": f"The Dawn of {item_name}",
        "narrative": f"The discovery of {item_name} has unlocked new potential for our civilization. Now we must decide how to best utilize this knowledge.",
        "decision_options": []
    }

def _check_faction_goals(game_state, outcome, action='', event_title=''):
    """
    Analyzes turn outcome against faction goals and updates approval.
    Passive faction simulation - factions react to turn outcomes based on their goals.

    Args:
        game_state: Current game state with faction_manager
        outcome: Dictionary with 'updates' and 'narrative' from process_player_action
        action: Player action string
        event_title: Event title string
    """
    # Extract updates from outcome
    updates = outcome.get('updates', {})
    if not updates:
        return  # No changes to evaluate

    # Get event context for richer analysis
    event_action = action
    event_narrative = outcome.get('narrative', '')

    print("--- Checking Faction Goals Against Turn Outcome ---")

    # Iterate through all factions
    for faction in game_state.faction_manager.get_all():
        faction_name = faction.get('name', 'Unknown Faction')
        faction_id = faction.get('id', '')
        goals = faction.get('goals', [])

        if not goals:
            continue  # Skip factions with no goals

        # Track approval changes for this faction
        approval_change = 0
        reasons = []

        # Analyze each goal against the turn outcome
        for goal in goals:
            goal_lower = goal.lower()

            # === WEALTH/TRADE/ECONOMIC GOALS ===
            if any(keyword in goal_lower for keyword in ['wealth', 'trade', 'commerce', 'merchant', 'economic', 'prosperity']):
                wealth_change = updates.get('civilization.resources.wealth', 0)
                if wealth_change > 0:
                    approval_change += 5
                    reasons.append(f"Wealth increased by {wealth_change}, advancing economic goals")
                elif wealth_change < -100:
                    approval_change -= 5
                    reasons.append(f"Wealth decreased by {abs(wealth_change)}, hindering economic goals")

            # === MILITARY/EXPANSION GOALS ===
            if any(keyword in goal_lower for keyword in ['military', 'expand', 'army', 'war', 'conquest', 'territory', 'soldiers']):
                # Check for military-related keywords in action/narrative
                military_keywords = ['attack', 'strike', 'army', 'soldiers', 'war', 'conquest', 'victory', 'defeat']
                action_lower = event_action.lower()
                narrative_lower = event_narrative.lower()

                military_success = any(kw in action_lower or kw in narrative_lower for kw in ['victory', 'conquest', 'expand'])
                military_action = any(kw in action_lower or kw in narrative_lower for kw in military_keywords)

                if military_success:
                    approval_change += 5
                    reasons.append("Military success aligns with expansion goals")
                elif military_action and 'defeat' not in narrative_lower:
                    approval_change += 3
                    reasons.append("Military action taken")

                # Population increase could indicate successful expansion
                population_change = updates.get('civilization.population', 0)
                if population_change > 100:
                    approval_change += 3
                    reasons.append("Population growth suggests successful expansion")

            # === STABILITY/PEACE/TRADITION GOALS ===
            if any(keyword in goal_lower for keyword in ['stability', 'peace', 'tradition', 'order', 'maintain']):
                population_change = updates.get('civilization.population', 0)
                if population_change < -50:
                    approval_change -= 5
                    reasons.append("Population loss threatens stability")
                elif population_change > 0:
                    approval_change += 3
                    reasons.append("Population stability maintained")

                # Check for new traditions added
                if any('culture.traditions.append' in key for key in updates.keys()):
                    approval_change += 5
                    reasons.append("New traditions preserve cultural heritage")

            # === RELIGIOUS/FAITH GOALS ===
            if any(keyword in goal_lower for keyword in ['faith', 'temple', 'divine', 'prayer', 'religion', 'spiritual']):
                # Check for religious infrastructure or practices
                religious_building = any('temple' in str(updates.get(key, '')).lower() for key in updates.keys() if 'infrastructure.append' in key)
                religious_practice = any('religion.practices.append' in key for key in updates.keys())

                if religious_building:
                    approval_change += 5
                    reasons.append("Religious construction advances faith")
                if religious_practice:
                    approval_change += 5
                    reasons.append("New religious practices strengthen devotion")

            # === CULTURAL/ARTISTIC GOALS ===
            if any(keyword in goal_lower for keyword in ['culture', 'art', 'tradition', 'heritage']):
                # Check for cultural developments
                if any('culture.' in key for key in updates.keys()):
                    approval_change += 3
                    reasons.append("Cultural development aligns with goals")

            # === SCIENTIFIC/KNOWLEDGE GOALS ===
            if any(keyword in goal_lower for keyword in ['knowledge', 'research', 'scholar', 'discovery', 'science']):
                # Check for technology discoveries
                if any('technology.discoveries.append' in key for key in updates.keys()):
                    approval_change += 5
                    reasons.append("New discoveries advance knowledge")

        # Apply approval changes if any
        if approval_change != 0:
            success = game_state.faction_manager.update_approval(faction_name, approval_change)
            if success:
                # Add history entry
                reason_text = "; ".join(reasons) if reasons else "Turn outcome affected faction goals"
                game_state.faction_manager.add_history_entry(
                    faction_name,
                    reason_text,
                    approval_change,
                    game_state.turn_number
                )
                print(f"  üìä {faction_name}: {approval_change:+d} approval ({reason_text[:60]}...)")
            else:
                print(f"  ‚ö†Ô∏è Failed to update approval for {faction_name}")

    print("--- Faction Goal Check Complete ---")

def _generate_decree_title(major_declaration):
    """Generate a suitable title for a decree based on the declaration"""
    title = major_declaration.get('event_title', 'Unknown Event')
    action_text = major_declaration.get('action_text', '')

    # Try to extract a pithy title from the action
    action_lower = action_text.lower()

    # Common patterns
    if 'women' in action_lower and ('dominate' in action_lower or 'supreme' in action_lower or 'greater' in action_lower):
        return "The Divine Mandate of Female Supremacy"
    elif 'men' in action_lower and ('dominate' in action_lower or 'supreme' in action_lower):
        return "The Patriarchal Decree"
    elif 'holy law' in action_lower or 'divine law' in action_lower:
        # Extract first few words after "holy law" or similar
        return f"Holy Law of {title.split()[-2]} {title.split()[-1]}"
    elif 'constitution' in action_lower:
        return f"The Constitutional Reforms of {title}"
    elif 'decree' in action_lower or 'mandate' in action_lower:
        # Use the event title
        return f"The {title} Decree"
    else:
        # Default: use event title
        return f"The {title} Proclamation"

def _infer_decree_effects(major_declaration, game_state):
    """
    Infer the effects of a decree from its text and context

    Args:
        major_declaration: Dict with type, importance, action_text
        game_state: Current game state

    Returns:
        Dict of effects to apply
    """
    action_text = major_declaration.get('action_text', '').lower()
    decree_type = major_declaration.get('type', 'cultural')

    effects = {}

    # Social structure changes
    if 'matriarch' in action_text or ('women' in action_text and 'dominate' in action_text):
        effects['social_structure'] = 'matriarchy'
        effects['governance_structure'] = 'matriarchal_theocracy' if decree_type == 'holy_law' else 'matriarchy'
    elif 'patriarch' in action_text or ('men' in action_text and 'dominate' in action_text):
        effects['social_structure'] = 'patriarchy'
        effects['governance_structure'] = 'patriarchal_theocracy' if decree_type == 'holy_law' else 'patriarchy'
    elif 'democracy' in action_text or 'equal voice' in action_text:
        effects['governance_structure'] = 'democracy'
    elif 'theocra' in action_text or 'priest' in action_text and 'rule' in action_text:
        effects['governance_structure'] = 'theocracy'

    # Military composition
    if 'women' in action_text and ('army' in action_text or 'military' in action_text or 'soldier' in action_text):
        effects['military_composition'] = 'female_dominated'
    elif 'men' in action_text and ('army' in action_text or 'military' in action_text):
        effects['military_composition'] = 'male_dominated'

    # Property rights
    if 'women' in action_text and ('property' in action_text or 'own' in action_text):
        effects['property_rights'] = 'female_only'
    elif 'men' in action_text and ('property' in action_text or 'own' in action_text):
        effects['property_rights'] = 'male_only'
    elif 'equal' in action_text and 'property' in action_text:
        effects['property_rights'] = 'equal'

    # Cultural values (infer from text)
    cultural_values = []
    if 'divine' in action_text or 'sacred' in action_text or 'holy' in action_text:
        if 'women' in action_text:
            cultural_values.append('Female Divinity')
        elif 'men' in action_text:
            cultural_values.append('Male Divinity')
        cultural_values.append('Religious Authority')

    if 'martial' in action_text or 'warrior' in action_text or 'military training' in action_text:
        if 'women' in action_text:
            cultural_values.append('Martial Women')
        else:
            cultural_values.append('Warrior Culture')

    if 'hierarchy' in action_text or 'greater' in action_text or 'dominate' in action_text:
        cultural_values.append('Gender Hierarchy' if 'women' in action_text or 'men' in action_text else 'Social Hierarchy')

    if 'knowledge' in action_text or 'wisdom' in action_text or 'scholar' in action_text:
        cultural_values.append('Pursuit of Knowledge')

    if cultural_values:
        effects['cultural_values'] = cultural_values

    # Taboos (infer opposites)
    taboos = []
    if 'women' in action_text and 'dominate' in action_text:
        taboos.extend(['Male Leadership', 'Gender Equality', 'Male Property Ownership'])
    elif 'men' in action_text and 'dominate' in action_text:
        taboos.extend(['Female Leadership', 'Gender Equality', 'Female Property Ownership'])

    if 'forbidden' in action_text or 'banned' in action_text or 'illegal' in action_text:
        # Try to extract what's forbidden
        if 'dissent' in action_text or 'opposition' in action_text:
            taboos.append('Political Dissent')

    if taboos:
        effects['taboos'] = taboos

    # Traditions
    traditions = []
    if 'women' in action_text and 'army' in action_text and 'training' in action_text:
        traditions.append('Universal Female Military Training')
    if 'women' in action_text and 'police' in action_text:
        traditions.append('Female Police Force')
    if 'matriarch' in action_text and 'succession' in action_text:
        traditions.append('Matriarchal Succession')
    elif 'patriarch' in action_text and 'succession' in action_text:
        traditions.append('Patriarchal Succession')

    if traditions:
        effects['traditions'] = traditions

    # Religious effects (for holy laws)
    if decree_type == 'holy_law':
        religious_effects = {}

        # Divine authority
        religious_effects['divine_authority'] = game_state.religion.get('primary_deity', 'The Divine')

        # Core tenets
        core_tenets = []
        if 'women' in action_text and 'dominate' in action_text:
            core_tenets.append('Women are divinely ordained to rule')
            core_tenets.append('Male subordination is sacred law')
        elif 'men' in action_text and 'dominate' in action_text:
            core_tenets.append('Men are divinely ordained to rule')
            core_tenets.append('Female subordination is sacred law')

        if core_tenets:
            religious_effects['core_tenets'] = core_tenets

        # Practices
        practices = []
        if 'women' in action_text and ('priest' in action_text or 'temple' in action_text):
            practices.append('Female-only priesthood')
        if 'hierarchy' in action_text:
            practices.append('Ritual enforcement of gender hierarchy')

        if practices:
            religious_effects['practices'] = practices

        if religious_effects:
            effects['religious_effects'] = religious_effects

    return effects



################################################################################
# FILE: old_codebase\engines\bonus_definitions.py
# Size: 5617 bytes
################################################################################

"""
Bonus Definitions - Central registry for all game bonuses.

Bonus Types:
- food_per_turn: Food production per turn
- wealth_per_turn: Wealth production per turn
- science_per_turn: Science points per turn
- culture_per_turn: Culture points per turn
- population_growth: Population growth rate modifier
- happiness: Happiness modifier

Bonus Sources:
- characters: Inner circle members by role
- buildings: Infrastructure by name (future)
- technologies: Discoveries by name (future)
- leader_traits: Leader traits (future)
"""

# Character role bonuses (migrated from world_turns_engine.py)
CHARACTER_ROLE_BONUSES = {
    'Leader': {
        'science_per_turn': 1,
        'culture_per_turn': 1,
        'description': 'Leaders provide baseline progress (temporary test bonus)'
    },
    'Scholar': {
        'science_per_turn': 5,
        'description': 'Scholars contribute to scientific advancement'
    },
    'Artisan': {
        'culture_per_turn': 5,
        'description': 'Artisans enrich cultural development'
    },
    'Spymaster': {
        'description': 'Spymasters provide intelligence advantages'
        # No numeric bonuses yet, but reserved for future
    },
    'Grand Marshal': {
        'food_per_turn': -5,
        'description': 'Military leaders strengthen defense but consume resources'
        # Future: 'military_strength': 10
    },
    'Chancellor': {
        'wealth_per_turn': 10,
        'description': 'Chancellors manage finances and boost economic output'
    },
    'High Priestess': {
        'description': 'Religious leaders boost faith'
        # Future: 'religious_influence': 5
    }
}

# Building bonuses (Phase 4 - populated from building_types.json)
# BALANCE CHANGE (2025-01): Added per-building maintenance costs
BUILDING_BONUSES = {
    'building_granary_001': {
        'food_per_turn': 10,
        'maintenance_cost': 8,      # NEW: Basic storage, low complexity
        'description': 'Granaries store surplus food'
    },
    'building_barracks_001': {
        'military_strength': 5,
        'maintenance_cost': 15,     # NEW: Soldiers expensive to maintain
        'description': 'Barracks train warriors'
    },
    'building_market_001': {
        'wealth_per_turn': 15,
        'maintenance_cost': 12,     # NEW: Trade infrastructure and staff
        'description': 'Markets facilitate trade'
    },
    'building_library_001': {
        'science_per_turn': 8,
        'maintenance_cost': 20,     # NEW: Scholars + rare books very expensive
        'description': 'Libraries preserve knowledge'
    },
    'building_temple_001': {
        'happiness': 5,
        'culture_per_turn': 5,
        'maintenance_cost': 18,     # NEW: Priests + rituals + upkeep
        'description': 'Temples strengthen faith'
    },
    'building_workshop_001': {
        'culture_per_turn': 3,
        'wealth_per_turn': 5,
        'maintenance_cost': 14,     # NEW: Artisans + materials
        'description': 'Workshops produce goods'
    }
}

# Technology bonuses (placeholder for future implementation)
TECHNOLOGY_BONUSES = {
    # Example structure for Phase 4:
    # 'Agriculture': {
    #     'food_production_multiplier': 1.2,
    #     'description': 'Improved farming techniques'
    # },
    # 'Writing': {
    #     'science_per_turn': 3,
    #     'culture_per_turn': 2,
    #     'description': 'Recording knowledge'
    # }
}

# Leader trait bonuses (integrated with BonusEngine)
LEADER_TRAIT_BONUSES = {
    'Wise': {
        'science_per_turn': 2,
        'description': 'Deep understanding and insight provides scientific progress'
    },
    'Scholar': {
        'science_per_turn': 3,
        'description': 'Devotion to knowledge accelerates technological advancement'
    },
    'Prosperous': {
        'wealth_per_turn': 5,
        'description': 'Brings wealth and abundance to the civilization'
    },
    'Mercantile': {
        'wealth_per_turn': 3,
        'description': 'Skilled in trade and commerce enhances economic output'
    },
    'Visionary': {
        'culture_per_turn': 2,
        'description': 'Sees beyond the present, inspiring cultural development'
    },
    'Charismatic': {
        'culture_per_turn': 1,
        'description': 'Natural inspiration encourages artistic expression'
    }
}

# Bonus type constants for type safety
class BonusType:
    FOOD_PER_TURN = 'food_per_turn'
    WEALTH_PER_TURN = 'wealth_per_turn'
    SCIENCE_PER_TURN = 'science_per_turn'
    CULTURE_PER_TURN = 'culture_per_turn'
    POPULATION_GROWTH = 'population_growth'
    HAPPINESS = 'happiness'

    # Future bonus types
    FOOD_MULTIPLIER = 'food_production_multiplier'
    WEALTH_MULTIPLIER = 'wealth_production_multiplier'
    MILITARY_STRENGTH = 'military_strength'
    MILITARY_EFFECTIVENESS_MULTIPLIER = 'military_effectiveness_multiplier'
    RELIGIOUS_INFLUENCE = 'religious_influence'

# Helper to validate bonus types
def is_valid_bonus_type(bonus_type):
    """Check if bonus type is valid."""
    valid_types = [
        BonusType.FOOD_PER_TURN,
        BonusType.WEALTH_PER_TURN,
        BonusType.SCIENCE_PER_TURN,
        BonusType.CULTURE_PER_TURN,
        BonusType.POPULATION_GROWTH,
        BonusType.HAPPINESS,
        BonusType.FOOD_MULTIPLIER,
        BonusType.WEALTH_MULTIPLIER,
        BonusType.MILITARY_STRENGTH,
        BonusType.MILITARY_EFFECTIVENESS_MULTIPLIER,
        BonusType.RELIGIOUS_INFLUENCE
    ]
    return bonus_type in valid_types



################################################################################
# FILE: old_codebase\engines\bonus_engine.py
# Size: 10499 bytes
################################################################################

"""
BonusEngine - Centralized bonus calculation and aggregation.
Collects bonuses from characters, buildings, technologies, and leader traits.
"""

from engines.bonus_definitions import (
    CHARACTER_ROLE_BONUSES,
    BUILDING_BONUSES,
    TECHNOLOGY_BONUSES,
    LEADER_TRAIT_BONUSES,
    BonusType,
    is_valid_bonus_type
)


class BonusEngine:
    """
    Aggregates bonuses from all sources in the game.

    Usage:
        engine = BonusEngine()
        science = engine.calculate_bonuses(game_state, BonusType.SCIENCE_PER_TURN)
        print(f"Total science bonus: {science['total']}")
        for source_type, source_name, value in science['sources']:
            print(f"  +{value} from {source_type}: {source_name}")
    """

    def __init__(self):
        """Initialize bonus engine."""
        pass

    def calculate_bonuses(self, game_state, bonus_type):
        """
        Calculate total bonuses for a given type from all sources.

        Args:
            game_state: GameState instance
            bonus_type: Bonus type string (use BonusType constants)

        Returns:
            Dictionary with:
            - 'total': Total bonus value (int)
            - 'sources': List of (source_type, source_name, value) tuples
            - 'multipliers': List of (source_type, source_name, multiplier) tuples
        """
        if not is_valid_bonus_type(bonus_type):
            print(f"Warning: Invalid bonus type '{bonus_type}'")
            return {'total': 0, 'sources': [], 'multipliers': []}

        bonuses = {
            'total': 0,
            'sources': [],
            'multipliers': []
        }

        # Collect bonuses from all sources
        self._add_character_bonuses(game_state, bonus_type, bonuses)
        self._add_building_bonuses(game_state, bonus_type, bonuses)
        self._add_technology_bonuses(game_state, bonus_type, bonuses)
        self._add_leader_trait_bonuses(game_state, bonus_type, bonuses)
        self._add_faction_bonuses(game_state, bonus_type, bonuses)

        # Sum up all bonuses
        bonuses['total'] = sum(value for _, _, value in bonuses['sources'])

        return bonuses

    def _add_character_bonuses(self, game_state, bonus_type, bonuses):
        """Add bonuses from inner circle characters and the civilization leader."""
        # Check civilization leader first
        leader = game_state.civilization.get('leader', {})
        if leader:
            leader_role = leader.get('role')
            if leader_role:
                role_bonuses = CHARACTER_ROLE_BONUSES.get(leader_role, {})
                bonus_value = role_bonuses.get(bonus_type, 0)

                if bonus_value > 0:
                    bonuses['sources'].append((
                        'leader',
                        leader.get('name', 'Unknown Leader'),
                        bonus_value
                    ))

        # Check inner circle characters
        if not hasattr(game_state, 'inner_circle_manager'):
            return

        for character in game_state.inner_circle_manager:
            role = character.get('role')
            if not role:
                continue

            role_bonuses = CHARACTER_ROLE_BONUSES.get(role, {})
            bonus_value = role_bonuses.get(bonus_type, 0)

            if bonus_value > 0:
                bonuses['sources'].append((
                    'character',
                    character.get('name', 'Unknown'),
                    bonus_value
                ))

    def _add_building_bonuses(self, game_state, bonus_type, bonuses):
        """
        Add bonuses from constructed buildings with diminishing returns.

        BALANCE CHANGE (2025-01): Duplicate buildings provide reduced bonuses.
        Formula: 1 / (1 + (count - 1) * 0.3)
        - 1st building: 100% effectiveness
        - 2nd building: 77% effectiveness
        - 3rd building: 63% effectiveness
        - 5th building: 45% effectiveness

        This encourages diversification over spamming one building type.
        """
        # Count buildings by type
        building_counts = {}
        building_base_bonuses = {}

        # Phase 4: Use buildings from game state
        if hasattr(game_state, 'buildings'):
            constructed = game_state.buildings.get('constructed_buildings', [])

            for building in constructed:
                building_id = building.get('id')
                building_name = building.get('name', building_id)

                # Count this building type
                building_counts[building_id] = building_counts.get(building_id, 0) + 1

                # Store base bonus for this type
                if building_id not in building_base_bonuses:
                    building_bonuses_def = BUILDING_BONUSES.get(building_id, {})
                    building_base_bonuses[building_id] = {
                        'bonus': building_bonuses_def.get(bonus_type, 0),
                        'name': building_name
                    }

        # Legacy: Also check infrastructure (backward compatibility)
        infrastructure = game_state.technology.get('infrastructure', [])
        for building_name in infrastructure:
            building_counts[building_name] = building_counts.get(building_name, 0) + 1

            if building_name not in building_base_bonuses:
                building_bonuses_def = BUILDING_BONUSES.get(building_name, {})
                building_base_bonuses[building_name] = {
                    'bonus': building_bonuses_def.get(bonus_type, 0),
                    'name': building_name
                }

        # Apply diminishing returns and add to bonuses
        for building_id, count in building_counts.items():
            base_data = building_base_bonuses.get(building_id, {})
            base_bonus = base_data.get('bonus', 0)

            if base_bonus > 0:
                # Calculate total bonus with diminishing returns
                total_bonus = 0
                for i in range(count):
                    diminishing_factor = 1.0 / (1 + i * 0.3)
                    total_bonus += base_bonus * diminishing_factor

                total_bonus = int(total_bonus)

                # Format name to show count
                display_name = base_data.get('name', building_id)
                if count > 1:
                    display_name = f"{display_name} (x{count})"

                bonuses['sources'].append((
                    'building',
                    display_name,
                    total_bonus
                ))

    def _add_technology_bonuses(self, game_state, bonus_type, bonuses):
        """Add bonuses from discovered technologies."""
        discoveries = game_state.technology.get('discoveries', [])

        for tech_name in discoveries:
            tech_bonuses = TECHNOLOGY_BONUSES.get(tech_name, {})
            bonus_value = tech_bonuses.get(bonus_type, 0)

            if bonus_value > 0:
                bonuses['sources'].append((
                    'technology',
                    tech_name,
                    bonus_value
                ))

            # Handle multipliers (e.g., +20% food production)
            multiplier_key = bonus_type.replace('_per_turn', '_multiplier')
            multiplier_value = tech_bonuses.get(multiplier_key, 0)

            if multiplier_value > 0:
                bonuses['multipliers'].append((
                    'technology',
                    tech_name,
                    multiplier_value
                ))

    def _add_leader_trait_bonuses(self, game_state, bonus_type, bonuses):
        """Add bonuses from leader traits."""
        leader = game_state.civilization.get('leader', {})
        traits = leader.get('traits', [])

        for trait in traits:
            trait_bonuses = LEADER_TRAIT_BONUSES.get(trait, {})
            bonus_value = trait_bonuses.get(bonus_type, 0)

            if bonus_value > 0:
                bonuses['sources'].append((
                    'leader_trait',
                    trait,
                    bonus_value
                ))

    def _add_faction_bonuses(self, game_state, bonus_type, bonuses):
        """Add bonuses/multipliers from faction approval levels."""
        if not hasattr(game_state, 'faction_manager'):
            return

        faction_bonuses = game_state.faction_manager.get_faction_bonuses(game_state)

        # Check if this is the military effectiveness multiplier
        if bonus_type == BonusType.MILITARY_EFFECTIVENESS_MULTIPLIER:
            multiplier_value = faction_bonuses.get('military_effectiveness', 1.0)

            if multiplier_value != 1.0:
                bonuses['multipliers'].append((
                    'faction_approval',
                    'Overall Faction Standing',
                    multiplier_value
                ))

    def get_all_active_bonuses(self, game_state):
        """
        Get all active bonuses across all types.
        Useful for debugging and UI display.

        Returns:
            Dictionary mapping bonus_type -> bonus result
        """
        all_bonus_types = [
            BonusType.FOOD_PER_TURN,
            BonusType.WEALTH_PER_TURN,
            BonusType.SCIENCE_PER_TURN,
            BonusType.CULTURE_PER_TURN,
            BonusType.POPULATION_GROWTH,
            BonusType.HAPPINESS
        ]

        active_bonuses = {}
        for bonus_type in all_bonus_types:
            result = self.calculate_bonuses(game_state, bonus_type)
            if result['total'] > 0 or result['sources']:
                active_bonuses[bonus_type] = result

        return active_bonuses

    def format_bonus_summary(self, game_state):
        """
        Create human-readable summary of all active bonuses.
        Useful for logging and debugging.
        """
        active = self.get_all_active_bonuses(game_state)

        if not active:
            return "No active bonuses"

        lines = ["Active Bonuses:"]
        for bonus_type, result in active.items():
            lines.append(f"  {bonus_type}: +{result['total']}")
            for source_type, source_name, value in result['sources']:
                lines.append(f"    +{value} from {source_type}: {source_name}")

        return "\n".join(lines)



################################################################################
# FILE: old_codebase\engines\callback_engine.py
# Size: 4608 bytes
################################################################################

# engines/callback_engine.py
"""
Generates callback events based on past player decisions and consequences.
Makes the world feel alive and reactive.
"""

import google.generativeai as genai
import json
from model_config import TEXT_MODEL
from engines.prompt_loader import load_prompt

def generate_callback_event(game_state, callback_type, callback_data):
    """
    Generate an event that references past player decisions.
    """
    print(f"--- Generating CALLBACK event: {callback_type} ---")
    model = genai.GenerativeModel(TEXT_MODEL)

    civ_name = game_state.civilization['meta']['name']
    leader_name = game_state.civilization['leader']['name']
    era = game_state.civilization['meta']['era']

    # Calculate time passed for narrative context
    current_year = game_state.civilization['meta']['year']
    event_year = callback_data.get('year', current_year - 10)
    years_passed = current_year - event_year

    # Load callback prompt templates (cached after first load)
    callback_prompts = {
        'broken_promise': load_prompt('callbacks/broken_promise'),
        'enemy_revenge': load_prompt('callbacks/enemy_revenge'),
        'ally_request': load_prompt('callbacks/ally_request'),
        'debt_collection': load_prompt('callbacks/debt_collection')
    }

    # Select the appropriate template
    template = callback_prompts.get(callback_type, callback_prompts['broken_promise'])

    # Build format kwargs based on callback type
    format_kwargs = {
        'civ_name': civ_name,
        'leader_name': leader_name,
        'era': era,
        'years_passed': years_passed
    }

    if callback_type == 'broken_promise':
        format_kwargs['promise_text'] = callback_data.get('text', 'Unknown promise')
        format_kwargs['promise_event'] = callback_data.get('event', 'Unknown event')
    elif callback_type == 'enemy_revenge':
        hostility = callback_data.get('hostility', 50)
        format_kwargs['enemy_name'] = callback_data.get('name', 'Unknown Enemy')
        format_kwargs['hostility_level'] = hostility
        format_kwargs['hostility_description'] = (
            'seething with rage' if hostility > 75 else
            'deeply hostile' if hostility > 50 else
            'harboring grudges'
        )
        format_kwargs['enemy_event'] = callback_data.get('event', 'Unknown conflict')
    elif callback_type == 'ally_request':
        strength = callback_data.get('strength', 50)
        format_kwargs['ally_name'] = callback_data.get('name', 'Unknown Ally')
        format_kwargs['alliance_strength'] = strength
        format_kwargs['alliance_description'] = (
            'unbreakable bond' if strength > 75 else
            'strong friendship' if strength > 50 else
            'tentative alliance'
        )
        format_kwargs['ally_event'] = callback_data.get('event', 'Unknown alliance')
    elif callback_type == 'debt_collection':
        format_kwargs['debt_description'] = callback_data.get('description', 'Unknown debt')
        format_kwargs['debt_event'] = callback_data.get('event', 'Unknown event')

    prompt = template.format(**format_kwargs)

    try:
        response = model.generate_content(
            prompt,
            generation_config={
                "response_mime_type": "application/json",
                "temperature": 0.8
            }
        )
        event_data = json.loads(response.text)
        event_data['is_callback'] = True
        event_data['callback_type'] = callback_type
        event_data['callback_data'] = callback_data

        # Add event type to title
        callback_type_label = callback_type.replace('_', ' ').title()
        if 'title' in event_data:
            event_data['title'] = event_data['title'] + f" -- Callback: {callback_type_label}"

        print(f"--- Callback event '{event_data.get('title', 'Unknown')}' generated ---")
        return event_data

    except Exception as e:
        print(f"Error generating callback event: {e}")
        callback_type_label = callback_type.replace('_', ' ').title()
        return {
            "title": f"The Past Returns -- Callback: {callback_type_label}",
            "narrative": "Your past decisions have caught up with you. Someone has returned seeking resolution.",
            "investigation_options": ["Learn what they want", "Assess the situation"],
            "decision_options": ["Face the consequences", "Try to negotiate"],
            "is_callback": True,
            "callback_type": callback_type
        }



################################################################################
# FILE: old_codebase\engines\character_engine.py
# Size: 4633 bytes
################################################################################

import json
import google.generativeai as genai
from model_config import TEXT_MODEL
from engines.prompt_loader import load_prompt

def generate_character_vignette(game_state, character_id):
    """
    Creates a prompt for the AI to start a multi-stage conversation with a character.

    Args:
        game_state: The main game state object.
        character_id: The name of the character to generate the vignette for.

    Returns:
        A dictionary containing the vignette, or None if an error occurs.
    """
    character = None

    # Check if the character is the leader
    if game_state.civilization.get('leader', {}).get('name') == character_id:
        character = game_state.civilization['leader']
    else:
        # Search for the character in the inner circle via manager
        if not hasattr(game_state, 'inner_circle_manager'):
            print(f"Warning: No inner circle manager available. Cannot find character {character_id}.")
            return None

        character = game_state.inner_circle_manager.get_by_name(character_id)

    if not character:
        return None

    # Extract context for richer prompts
    civ_name = game_state.civilization.get('meta', {}).get('name', 'the realm')
    char_name = character.get('name', 'Unknown')
    char_role = character.get('role', 'advisor')
    loyalty = character.get('loyalty', 50)
    relationship = character.get('relationship', 50)

    # Contextualize loyalty and relationship
    if loyalty < 25:
        loyalty_desc = "wavering and doubtful (loyalty: {})".format(loyalty)
    elif loyalty < 50:
        loyalty_desc = "uncertain and conflicted (loyalty: {})".format(loyalty)
    elif loyalty < 75:
        loyalty_desc = "steadfast but tested (loyalty: {})".format(loyalty)
    else:
        loyalty_desc = "unwavering and true (loyalty: {})".format(loyalty)

    if relationship < 25:
        relationship_desc = "distrustful and distant"
    elif relationship < 50:
        relationship_desc = "cautiously respectful"
    elif relationship < 75:
        relationship_desc = "warmly cordial"
    else:
        relationship_desc = "deeply trusting"

    # Load and format the character vignette prompt
    character_json = json.dumps(character, indent=2)
    personality_traits = ', '.join(character.get('personality_traits', []))

    prompt = load_prompt('characters/character_vignette').format(
        char_name=char_name,
        char_role=char_role,
        civ_name=civ_name,
        loyalty_desc=loyalty_desc,
        relationship_desc=relationship_desc,
        character_json=character_json,
        personality_traits=personality_traits
    )

    try:
        model = genai.GenerativeModel(TEXT_MODEL)
        response = model.generate_content(
            prompt,
            generation_config={"response_mime_type": "application/json"},
        )
        raw_data = json.loads(response.text)

        # Validate that AI generated all required fields
        investigation_opts = raw_data.get("investigation_options", [])
        decision_opts = raw_data.get("decision_options", [])

        # Fallback to generic options only if AI completely failed to generate them
        if not investigation_opts or len(investigation_opts) < 2:
            print(f"‚ö†Ô∏è Warning: AI did not generate investigation_options for {char_name}, using fallback")
            investigation_opts = [
                "Ask about the specific details of their dilemma",
                "Inquire about what they've tried so far"
            ]

        if not decision_opts or len(decision_opts) < 2:
            print(f"‚ö†Ô∏è Warning: AI did not generate decision_options for {char_name}, using fallback")
            decision_opts = [
                "Offer counsel on one path forward",
                "Advise a different course of action"
            ]

        # Transform AI response into proper event format expected by frontend
        event_data = {
            "title": f"Audience with {character.get('name')}",
            "narrative": raw_data.get("dialogue", "The character greets you warmly."),
            "investigation_options": investigation_opts,
            "decision_options": decision_opts,
            "event_type": "character_vignette",
            "character_name": character.get('name'),
            "dilemma_summary": raw_data.get("dilemma_summary", "")
        }
        return event_data
    except Exception as e:
        print(f"Error generating character vignette for {character_id}: {e}")
        return None


################################################################################
# FILE: old_codebase\engines\consequence_engine.py
# Size: 15597 bytes
################################################################################

# engines/consequence_engine.py
"""
Tracks consequences of player decisions and manages civilization reputation.
Enables callback events based on past actions.
"""

import re

def initialize_consequences(game_state):
    """Initialize consequence tracking if not present."""
    if 'consequences' not in game_state.civilization:
        game_state.civilization['consequences'] = {
            'promises': [],        # List of promises made
            'broken_promises': [], # List of broken promises
            'alliances': [],       # List of allied groups/civilizations
            'enemies': [],         # List of hostile groups/civilizations
            'reputation': {
                'diplomatic': 50,  # 0-100 scale
                'military': 50,
                'religious': 50,
                'economic': 50
            },
            'debts': [],          # Outstanding debts or obligations
            'favors_owed': [],    # Favors owed to others
            'favors_held': []     # Favors others owe to you
        }

def detect_major_declaration(action_text, event_title, outcome_text):
    """
    Detect if the action is a major declaration (law, decree, constitutional change, etc.)
    Returns dict with declaration details or None
    """
    action_lower = action_text.lower()
    combined = (action_text + ' ' + event_title + ' ' + outcome_text).lower()

    # Keywords indicating major declarations
    holy_law_keywords = ['holy law', 'divine law', 'sacred mandate', 'religious decree', 'god commands', 'divine mandate']
    constitutional_keywords = ['constitution', 'fundamental law', 'government reform', 'restructure government', 'new order']
    cultural_keywords = ['forever', 'eternal', 'all time', 'never forget', 'law stands', 'decree', 'mandate', 'proclaim']
    permanence_keywords = ['forever', 'eternal', 'permanently', 'all time', 'eternity', 'everlasting', 'always']
    authority_keywords = ['decree', 'declare', 'proclaim', 'mandate', 'establish', 'ordain', 'command']

    # Calculate significance score
    significance_score = 0
    decree_type = 'cultural'  # Default

    # Check for holy law indicators (highest weight)
    for keyword in holy_law_keywords:
        if keyword in combined:
            significance_score += 30
            decree_type = 'holy_law'
            break

    # Check for constitutional indicators
    for keyword in constitutional_keywords:
        if keyword in combined:
            significance_score += 25
            decree_type = 'constitutional'
            break

    # Check for permanence language (strong indicator)
    permanence_count = sum(1 for keyword in permanence_keywords if keyword in combined)
    significance_score += permanence_count * 10

    # Check for authority language
    authority_count = sum(1 for keyword in authority_keywords if keyword in combined)
    significance_score += authority_count * 5

    # Check for scope indicators (affects entire civilization)
    scope_keywords = ['all', 'every', 'entire', 'civilization', 'nation', 'people', 'society', 'everyone']
    scope_count = sum(1 for keyword in scope_keywords if keyword in combined)
    significance_score += scope_count * 3

    # Check for enforcement language
    enforcement_keywords = ['enforce', 'punish', 'execute', 'killed', 'death', 'forbidden', 'banned', 'illegal']
    enforcement_count = sum(1 for keyword in enforcement_keywords if keyword in combined)
    significance_score += enforcement_count * 5

    # Length check - declarations are usually substantial
    if len(action_text) > 200:
        significance_score += 10

    # Categorize importance based on score
    importance = 'minor'
    if significance_score >= 50:
        importance = 'civilization_defining'
    elif significance_score >= 30:
        importance = 'major'
    elif significance_score >= 15:
        importance = 'significant'

    # Only return if this seems like a major declaration (score >= 15)
    if significance_score >= 15:
        return {
            'type': decree_type,
            'importance': importance,
            'significance_score': significance_score,
            'action_text': action_text,
            'event_title': event_title
        }

    return None

def analyze_action_for_consequences(action_text, event_title, outcome_text):
    """
    Analyze player action to detect promises, alliances, conflicts, etc.
    Returns dict of detected consequences.
    """
    action_lower = action_text.lower()
    event_lower = event_title.lower()
    outcome_lower = outcome_text.lower()

    consequences = {
        'promises': [],
        'alliances': [],
        'enemies': [],
        'debts': [],
        'reputation_changes': {},
        'major_declaration': None  # For civilization-defining decrees
    }

    # Detect major declarations (holy laws, constitutional changes, major decrees)
    major_declaration = detect_major_declaration(action_text, event_title, outcome_text)
    if major_declaration:
        consequences['major_declaration'] = major_declaration

    # Detect promises (keywords: promise, swear, vow, guarantee, agree to)
    promise_keywords = ['promise', 'swear', 'vow', 'guarantee', 'pledge', 'agree to', 'commit to']
    for keyword in promise_keywords:
        if keyword in action_lower:
            # Extract what was promised
            promise = {
                'text': action_text,
                'event': event_title,
                'fulfilled': False
            }
            consequences['promises'].append(promise)
            break

    # Detect alliances (keywords: ally, alliance, unite, join forces, peace treaty)
    alliance_keywords = ['ally', 'alliance', 'unite', 'join forces', 'peace treaty', 'pact', 'partner']
    for keyword in alliance_keywords:
        if keyword in action_lower or keyword in outcome_lower:
            # Try to extract ally name from event or action
            ally_match = re.search(r'(?:with |to )(the )?([\w\s]+?)(?:\s+clan|\s+tribe|\s+people|\s+nation|\.|\,)', action_lower + ' ' + event_lower)
            ally_name = ally_match.group(2).strip().title() if ally_match else "Unknown Ally"

            alliance = {
                'name': ally_name,
                'event': event_title,
                'strength': 50  # 0-100, starts at neutral alliance
            }
            consequences['alliances'].append(alliance)
            consequences['reputation_changes']['diplomatic'] = 10
            break

    # Detect enemies (keywords: attack, reject, insult, war, hostile, refuse)
    enemy_keywords = ['attack', 'declare war', 'reject', 'insult', 'hostile', 'refuse', 'betray', 'raid']
    for keyword in enemy_keywords:
        if keyword in action_lower:
            # Try to extract enemy name
            enemy_match = re.search(r'(?:against |the )?([\w\s]+?)(?:\s+clan|\s+tribe|\s+people|\s+nation|\.|\,)', action_lower + ' ' + event_lower)
            enemy_name = enemy_match.group(1).strip().title() if enemy_match else "Unknown Enemy"

            enemy = {
                'name': enemy_name,
                'event': event_title,
                'hostility': 50  # 0-100, higher = more hostile
            }
            consequences['enemies'].append(enemy)
            consequences['reputation_changes']['military'] = 10
            consequences['reputation_changes']['diplomatic'] = -10
            break

    # Detect debts/obligations (keywords: borrow, debt, owe, loan, pay later)
    debt_keywords = ['borrow', 'debt', 'owe', 'loan', 'pay later', 'on credit']
    for keyword in debt_keywords:
        if keyword in action_lower or keyword in outcome_lower:
            debt = {
                'description': action_text,
                'event': event_title,
                'repaid': False
            }
            consequences['debts'].append(debt)
            consequences['reputation_changes']['economic'] = -5
            break

    # Reputation changes based on action type
    if 'help' in action_lower or 'aid' in action_lower or 'assist' in action_lower:
        consequences['reputation_changes']['diplomatic'] = consequences['reputation_changes'].get('diplomatic', 0) + 5

    if 'trade' in action_lower or 'merchant' in action_lower or 'sell' in action_lower:
        consequences['reputation_changes']['economic'] = consequences['reputation_changes'].get('economic', 0) + 5

    if 'pray' in action_lower or 'ritual' in action_lower or 'temple' in action_lower or 'sacred' in action_lower:
        consequences['reputation_changes']['religious'] = consequences['reputation_changes'].get('religious', 0) + 5

    if 'defend' in action_lower or 'fortify' in action_lower or 'military' in action_lower:
        consequences['reputation_changes']['military'] = consequences['reputation_changes'].get('military', 0) + 5

    return consequences

def apply_consequences(game_state, action_text, event_title, outcome_text):
    """
    Apply detected consequences to game state.
    """
    initialize_consequences(game_state)

    detected = analyze_action_for_consequences(action_text, event_title, outcome_text)

    # Apply promises
    for promise in detected['promises']:
        game_state.civilization['consequences']['promises'].append(promise)
        print(f"  üìú Promise recorded: '{promise['text'][:50]}...'")

    # Apply alliances
    for alliance in detected['alliances']:
        # Check if ally already exists
        existing = next((a for a in game_state.civilization['consequences']['alliances'] if a['name'] == alliance['name']), None)
        if existing:
            existing['strength'] = min(100, existing['strength'] + 10)
            print(f"  ü§ù Alliance strengthened: {alliance['name']} (strength: {existing['strength']})")
        else:
            game_state.civilization['consequences']['alliances'].append(alliance)
            print(f"  ü§ù New alliance formed: {alliance['name']}")

    # Apply enemies
    for enemy in detected['enemies']:
        # Check if enemy already exists
        existing = next((e for e in game_state.civilization['consequences']['enemies'] if e['name'] == enemy['name']), None)
        if existing:
            existing['hostility'] = min(100, existing['hostility'] + 10)
            print(f"  ‚öîÔ∏è Hostility increased: {enemy['name']} (hostility: {existing['hostility']})")
        else:
            game_state.civilization['consequences']['enemies'].append(enemy)
            print(f"  ‚öîÔ∏è New enemy made: {enemy['name']}")

    # Apply debts
    for debt in detected['debts']:
        game_state.civilization['consequences']['debts'].append(debt)
        print(f"  üí≥ Debt incurred: {debt['description'][:50]}...")

    # Apply reputation changes
    for rep_type, change in detected['reputation_changes'].items():
        old_rep = game_state.civilization['consequences']['reputation'][rep_type]
        new_rep = max(0, min(100, old_rep + change))
        game_state.civilization['consequences']['reputation'][rep_type] = new_rep

        if change != 0:
            direction = "+" if change > 0 else ""
            print(f"  üìä {rep_type.title()} reputation: {old_rep} ‚Üí {new_rep} ({direction}{change})")

    # BALANCE_OVERHAUL: Broken promises incur severe penalties
    if 'broken_promise' in action_text.lower() or 'betrayed' in action_text.lower():
        # Triple the diplomatic penalty
        old_rep = game_state.civilization['consequences']['reputation']['diplomatic']
        new_rep = max(0, old_rep - 30)  # -30 instead of -10
        game_state.civilization['consequences']['reputation']['diplomatic'] = new_rep
        print(f"  üíî BROKEN PROMISE: Diplomatic reputation crashed by -30 (now {new_rep})")

def get_consequence_context(game_state):
    """
    Build a summary of consequences for event generation.
    Returns formatted string for AI prompt.
    """
    initialize_consequences(game_state)
    conseq = game_state.civilization['consequences']

    context_parts = []

    # Active promises
    active_promises = [p for p in conseq['promises'] if not p.get('fulfilled', False)]
    if active_promises:
        context_parts.append(f"Unfulfilled promises: {len(active_promises)}")

    # Broken promises (trust issues)
    if conseq['broken_promises']:
        context_parts.append(f"Broken promises: {len(conseq['broken_promises'])} (reputation damaged)")

    # Alliances
    if conseq['alliances']:
        strong_allies = [a['name'] for a in conseq['alliances'] if a.get('strength', 0) > 70]
        if strong_allies:
            context_parts.append(f"Strong allies: {', '.join(strong_allies[:3])}")

    # Enemies
    if conseq['enemies']:
        hostile_enemies = [e['name'] for e in conseq['enemies'] if e.get('hostility', 0) > 70]
        if hostile_enemies:
            context_parts.append(f"Hostile enemies: {', '.join(hostile_enemies[:3])}")

    # Outstanding debts
    unpaid_debts = [d for d in conseq['debts'] if not d.get('repaid', False)]
    if unpaid_debts:
        context_parts.append(f"Unpaid debts: {len(unpaid_debts)}")

    # Reputation summary
    rep = conseq['reputation']
    rep_summary = f"Reputation - Diplomatic: {rep['diplomatic']}, Military: {rep['military']}, Religious: {rep['religious']}, Economic: {rep['economic']}"
    context_parts.append(rep_summary)

    return "\n".join(context_parts) if context_parts else "No significant consequences yet."

def check_for_callback_opportunity(game_state):
    """
    BALANCE_OVERHAUL: Check if there's an opportunity for a callback event.
    Increased probabilities to make consequences return more frequently.
    Returns (bool, callback_type, callback_data) or (False, None, None)
    """
    initialize_consequences(game_state)
    conseq = game_state.civilization['consequences']
    import random

    # BALANCE_OVERHAUL: Broken promise callback - dramatically increased
    active_promises = [p for p in conseq['promises'] if not p.get('fulfilled', False)]
    if len(active_promises) >= 2:
        # Old promises (5+ turns) have 70% callback chance
        old_promises = [p for p in active_promises if game_state.turn_number - p.get('turn', 0) >= 5]
        if old_promises and random.random() < 0.70:  # Increased from 0.30
            return True, 'broken_promise', old_promises[0]

    # BALANCE_OVERHAUL: Enemy revenge - increased
    hostile_enemies = [e for e in conseq['enemies'] if e.get('hostility', 0) > 60]
    if hostile_enemies:
        if random.random() < 0.40:  # Increased from 0.25
            return True, 'enemy_revenge', hostile_enemies[0]

    # BALANCE_OVERHAUL: Ally request - increased
    strong_allies = [a for a in conseq['alliances'] if a.get('strength', 0) > 50]
    if strong_allies:
        if random.random() < 0.35:  # Increased from 0.20
            return True, 'ally_request', strong_allies[0]

    # BALANCE_OVERHAUL: Debt collection - increased
    unpaid_debts = [d for d in conseq['debts'] if not d.get('repaid', False)]
    if unpaid_debts:
        old_debts = [d for d in unpaid_debts if game_state.turn_number - d.get('turn', 0) >= 3]
        if old_debts and random.random() < 0.50:  # Increased from 0.30
            return True, 'debt_collection', old_debts[0]

    return False, None, None



################################################################################
# FILE: old_codebase\engines\council_engine.py
# Size: 10854 bytes
################################################################################

import json
import google.generativeai as genai
from model_config import TEXT_MODEL
from engines.prompt_loader import load_prompt


def normalize_options(options, option_type="option"):
    """
    Robustly normalize option arrays to ensure they're clean string arrays.

    Args:
        options: Raw options from AI (may be strings, objects, or mixed)
        option_type: Type of option for logging (e.g., "investigation", "decision")

    Returns:
        List of validated string options
    """
    if not options:
        print(f"  ‚ö†Ô∏è Warning: Empty {option_type} options array")
        return []

    if not isinstance(options, list):
        print(f"  ‚ö†Ô∏è Warning: {option_type} options is not a list, converting to list")
        options = [options]

    normalized = []
    for idx, opt in enumerate(options):
        try:
            # Handle string (ideal case)
            if isinstance(opt, str):
                if opt.strip():  # Non-empty string
                    normalized.append(opt.strip())
                else:
                    print(f"  ‚ö†Ô∏è Warning: Empty string in {option_type} options at index {idx}, skipping")

            # Handle dict/object
            elif isinstance(opt, dict):
                # Try multiple possible key names
                text_value = (opt.get('text') or
                             opt.get('action') or
                             opt.get('option') or
                             opt.get('description') or
                             opt.get('label'))

                if text_value and isinstance(text_value, str):
                    normalized.append(str(text_value).strip())
                else:
                    # Last resort: stringify the entire object
                    fallback = str(opt)
                    print(f"  ‚ö†Ô∏è Warning: Could not extract text from {option_type} object at index {idx}, using: {fallback[:50]}")
                    normalized.append(fallback)

            # Handle None
            elif opt is None:
                print(f"  ‚ö†Ô∏è Warning: None value in {option_type} options at index {idx}, skipping")

            # Handle other types (int, bool, etc.)
            else:
                str_value = str(opt)
                print(f"  ‚ö†Ô∏è Warning: Non-string {option_type} option at index {idx} (type: {type(opt).__name__}), converted to: {str_value}")
                normalized.append(str_value)

        except Exception as e:
            print(f"  ‚ùå Error normalizing {option_type} option at index {idx}: {e}, skipping")
            continue

    # Ensure we have at least 2 options (requirement for UI)
    if len(normalized) < 2:
        print(f"  ‚ö†Ô∏è Warning: Only {len(normalized)} {option_type} option(s) found, expected 2+")

    return normalized


def generate_council_meeting(game_state):
    """
    Generates a council meeting event by calling the AI model.

    The prompt instructs the AI to:
    1. Analyze the entire game_state.
    2. Generate 2-3 "advisor reports" summarizing key stats.
    3. Synthesize these reports into 2-3 "pressing matters" for the player to address as a new policy.

    Args:
        game_state (dict): The current state of the game.

    Returns:
        dict: The generated council meeting event as a JSON object.
    """
    game_state_dict = game_state.to_dict()
    game_state_json = json.dumps(game_state_dict, indent=2)

    # Parse some key context for narrative enhancement
    game_dict = game_state.to_dict()
    pop = game_dict.get('civilization', {}).get('population', 0)
    food = game_dict.get('civilization', {}).get('resources', {}).get('food', 0)
    wealth = game_dict.get('civilization', {}).get('resources', {}).get('wealth', 0)
    leader_name = game_dict.get('civilization', {}).get('leader', {}).get('name', 'Leader')

    # Get inner circle advisors for more accurate personas
    advisor_names = []
    advisor_details = []
    if hasattr(game_state, 'inner_circle_manager'):
        for char in game_state.inner_circle_manager.get_all():
            advisor_names.append(char['name'])
            advisor_details.append({
                'name': char['name'],
                'role': char['role'],
                'personality': ', '.join(char.get('personality_traits', [])),
                'recent_history': char.get('history', [])[-3:] if char.get('history') else []
            })

    advisor_context = "\n".join([
        f"- {a['name']} ({a['role']}): {a['personality']}"
        for a in advisor_details
    ]) if advisor_details else "Generic advisors"

    # Build advisor memory context for AI prompt
    advisor_memories = "\n".join([
        f"- {a['name']} ({a['role']}): Last remembers \"{a['recent_history'][-1]}\"" if a['recent_history'] else f"- {a['name']} ({a['role']}): No recent memories"
        for a in advisor_details
    ]) if advisor_details else "No memories available"

    # Pre-calculate formatted values
    pop_formatted = f"{pop:,}"
    food_formatted = f"{food:,}"
    wealth_formatted = f"{wealth:,}"
    food_per_capita = food / max(pop, 1)

    # Load prompt template and fill in variables
    prompt_template = load_prompt('council/council_meeting')
    prompt = prompt_template.format(
        leader_name=leader_name,
        game_state_json=game_state_json,
        advisor_context=advisor_context,
        advisor_memories=advisor_memories,
        population=pop_formatted,
        food=food_formatted,
        wealth=wealth_formatted,
        food_per_capita=food_per_capita
    )
    try:
        model = genai.GenerativeModel(TEXT_MODEL)
        response = model.generate_content(
            prompt,
            generation_config={"response_mime_type": "application/json"},
        )
        council_meeting_data = json.loads(response.text)

        # Normalize options to ensure they're arrays of strings
        council_meeting_data['investigation_options'] = normalize_options(
            council_meeting_data.get('investigation_options', []),
            "investigation"
        )
        council_meeting_data['decision_options'] = normalize_options(
            council_meeting_data.get('decision_options', []),
            "decision"
        )

        # Ensure event_type is set (in case AI doesn't include it)
        if 'event_type' not in council_meeting_data:
            council_meeting_data['event_type'] = 'council_meeting'

        # Add event type to title
        if 'title' in council_meeting_data:
            council_meeting_data['title'] = council_meeting_data['title'] + " -- Council Meeting"

        # Initialize event state
        game_state.current_event = council_meeting_data
        game_state.event_stage = 0
        game_state.event_conversation = []

        return council_meeting_data
    except Exception as e:
        print(f"Error generating council meeting: {e}")
        return None

def generate_first_turn_briefing(game_state):
    """
    Generates a special one-time "First Council Briefing" event for turn 0.
    Introduces the player to their council and presents the first major choice.
    """
    game_state_json = json.dumps(game_state.to_dict(), indent=2)

    # Extract key context from game state
    game_dict = json.loads(game_state_json)
    civ_name = game_dict.get('civilization', {}).get('meta', {}).get('name', 'Your Civilization')
    leader_name = game_dict.get('civilization', {}).get('leader', {}).get('name', 'Leader')
    era = game_dict.get('civilization', {}).get('meta', {}).get('era', 'ancient times')
    culture_values = game_dict.get('culture', {}).get('values', [])

    # Pre-calculate formatted values
    population_formatted = f"{game_dict.get('civilization', {}).get('population', 0):,}"
    food_formatted = f"{game_dict.get('civilization', {}).get('resources', {}).get('food', 0):,}"
    wealth_formatted = f"{game_dict.get('civilization', {}).get('resources', {}).get('wealth', 0):,}"
    culture_values_str = ', '.join(culture_values[:3]) if culture_values else 'being forged'

    # Load prompt template and fill in variables
    prompt_template = load_prompt('council/first_turn_briefing')
    prompt = prompt_template.format(
        leader_name=leader_name,
        civ_name=civ_name,
        era=era,
        culture_values=culture_values_str,
        game_state_json=game_state_json,
        population=population_formatted,
        food=food_formatted,
        wealth=wealth_formatted
    )
    try:
        model = genai.GenerativeModel(TEXT_MODEL)
        response = model.generate_content(
            prompt,
            generation_config={"response_mime_type": "application/json"},
        )
        briefing_data = json.loads(response.text)
        briefing_data["event_type"] = "council_meeting" # Use same type for UI handling

        # Normalize options to ensure they're arrays of strings
        briefing_data['investigation_options'] = normalize_options(
            briefing_data.get('investigation_options', []),
            "investigation (first turn)"
        )
        briefing_data['decision_options'] = normalize_options(
            briefing_data.get('decision_options', []),
            "decision (first turn)"
        )

        # Add event type to title
        if 'title' in briefing_data:
            briefing_data['title'] = briefing_data['title'] + " -- Council Meeting"

        # Initialize event state
        game_state.current_event = briefing_data
        game_state.event_stage = 0
        game_state.event_conversation = []

        return briefing_data
    except Exception as e:
        print(f"Error generating first turn briefing: {e}")
        # Return a hardcoded fallback event
        fallback_data = {
            "title": "A Leader's First Council -- Council Meeting",
            "narrative": "Your advisors gather. It is time to set the course for your civilization.",
            "state_of_realm": "Your people look to you with hope and uncertainty. The path ahead is unclear, but destiny awaits.",
            "advisor_reports": [{"advisor_title": "Elder", "summary": "Our people look to you for guidance."}],
            "pressing_matters": "You must choose a path.",
            "investigation_options": ["Ask the Elder for wisdom", "Consult with the council"],
            "decision_options": ["Focus on Growth", "Focus on Defense"],
            "event_type": "council_meeting"
        }

        # Initialize event state for fallback too
        game_state.current_event = fallback_data
        game_state.event_stage = 0
        game_state.event_conversation = []

        return fallback_data


################################################################################
# FILE: old_codebase\engines\crisis_engine.py
# Size: 11185 bytes
################################################################################

# engines/crisis_engine.py
"""
Crisis event generation based on resource states and civilization conditions.
Triggers special events when civilization is in danger.
"""

import google.generativeai as genai
import json
from model_config import TEXT_MODEL
from engines.prompt_loader import load_prompt

def detect_crisis(game_state):
    """
    Detect if civilization is in a crisis state.
    Returns crisis type or None.
    """
    # BALANCE_OVERHAUL: Initialize crisis momentum tracking if not present
    if not hasattr(game_state, 'crisis_momentum'):
        game_state.crisis_momentum = 0
    if not hasattr(game_state, 'crisis_recovery_timer'):
        game_state.crisis_recovery_timer = 0

    population = game_state.civilization['population']
    food = game_state.civilization['resources']['food']
    wealth = game_state.civilization['resources']['wealth']

    # Calculate food per capita
    food_per_capita = food / max(population, 1)

    # BALANCE_OVERHAUL: Tightened crisis thresholds with earlier warnings
    # Crisis priority (most severe first)
    crisis_type = None

    if food <= 0 or food_per_capita < 0.5:
        crisis_type = 'famine'  # Catastrophic - severe malnutrition
    elif wealth <= 0:
        crisis_type = 'economic_collapse'
    elif food_per_capita < 0.8:
        crisis_type = 'severe_food_shortage'  # Active crisis tier
    elif food_per_capita < 1.8:
        crisis_type = 'food_shortage'  # Warning tier (increased from 1.0)
    elif wealth < 100:
        crisis_type = 'economic_crisis'
    elif wealth < 300:
        crisis_type = 'economic_warning'  # New warning tier

    # Check leader age crisis
    leader = game_state.civilization.get('leader', {})
    if leader.get('age', 0) > leader.get('life_expectancy', 60) + 10:
        crisis_type = 'succession_crisis'

    # If a crisis was detected by thresholds, track momentum and return it
    if crisis_type:
        game_state.crisis_momentum += 1
        game_state.crisis_recovery_timer = 0
        return crisis_type

    # BALANCE_OVERHAUL: CRISIS CASCADING - Multiple crises increase probability of others
    active_crises = []

    # Detect all active crisis conditions
    if food_per_capita < 1.8:
        active_crises.append('food_crisis')
    if wealth < 300:
        active_crises.append('economic_crisis')
    if game_state.population_happiness < 40:
        active_crises.append('happiness_crisis')

    # Cascade logic: if multiple crises, increase severity
    if len(active_crises) >= 2:
        import random

        # Food crisis increases economic crisis chance
        if 'food_crisis' in active_crises and wealth < 500:
            if random.random() < 0.40:  # 40% cascade chance
                return 'economic_crisis'

        # Economic crisis increases food shortage chance
        if 'economic_crisis' in active_crises and food_per_capita < 2.0:
            if random.random() < 0.30:  # 30% cascade chance
                return 'food_shortage'

        # Multiple crises trigger faction betrayal checks
        if len(active_crises) >= 2:
            if random.random() < 0.25:  # 25% compound crisis
                game_state.crisis_momentum += 1
                game_state.crisis_recovery_timer = 0
                return 'compound_crisis'  # New crisis type - multi-system failure

    # BALANCE_OVERHAUL: No crisis - decrement recovery timer
    if game_state.crisis_recovery_timer < 5:
        game_state.crisis_recovery_timer += 1
    else:
        # Full recovery after 5 turns without crisis
        game_state.crisis_momentum = 0

    return None

def generate_crisis_event(game_state, crisis_type):
    """
    Generate a targeted crisis event with high stakes.
    These events demand immediate attention and have severe consequences.
    """
    print(f"--- Generating CRISIS event: {crisis_type} ---")

    # Special handling for succession crisis - use the new high-stakes system
    if crisis_type == 'succession_crisis':
        from engines.leader_engine import trigger_succession_crisis
        succession_data = trigger_succession_crisis(game_state)
        # Convert succession data to event format
        candidates_text = "\n".join([
            f"- **{c['name']}** ({c['archetype']}): Backed by {c['backing_faction']}. Traits: {', '.join(c['traits'])}. Demands: {c['demands']}"
            for c in succession_data['candidates']
        ])
        return {
            "title": "The Throne Lies Empty: A Succession Crisis -- Crisis: Succession",
            "narrative": f"The ancient {game_state.civilization['leader']['name']} has passed beyond mortal years. "
                        f"The throne stands empty, and powerful factions circle with their own candidates. "
                        f"This is not a simple choice of successor - this is a political crisis that will reshape your civilization.\n\n"
                        f"**Candidates:**\n{candidates_text}",
            "investigation_options": [
                "Assess each faction's strength and their candidate's true capabilities",
                "Investigate what concessions each faction might demand if their candidate is chosen"
            ],
            "decision_options": [
                "Choose a successor (opens succession selection)",
                "Delay the decision and let factions struggle (increases instability)"
            ],
            "is_crisis": True,
            "crisis_type": crisis_type,
            "succession_data": succession_data
        }

    model = genai.GenerativeModel(TEXT_MODEL)

    # Build context
    civ_name = game_state.civilization['meta']['name']
    leader_name = game_state.civilization['leader']['name']
    population = game_state.civilization['population']
    food = game_state.civilization['resources']['food']
    wealth = game_state.civilization['resources']['wealth']
    era = game_state.civilization['meta']['era']

    # Calculate severity context
    food_per_capita = food / max(population, 1)
    days_of_food = int(food_per_capita * 30) if food > 0 else 0

    # Load crisis prompt templates (cached after first load)
    crisis_prompts = {
        'famine': load_prompt('crises/famine'),
        'food_shortage': load_prompt('crises/food_shortage'),
        'severe_food_shortage': load_prompt('crises/severe_food_shortage'),
        'economic_collapse': load_prompt('crises/economic_collapse'),
        'economic_crisis': load_prompt('crises/economic_crisis'),
        'economic_warning': load_prompt('crises/economic_warning'),
        'succession_crisis': load_prompt('crises/succession_crisis'),
        'compound_crisis': load_prompt('crises/compound_crisis')
    }

    # Get the appropriate prompt template
    prompt_template = crisis_prompts.get(crisis_type, crisis_prompts['famine'])

    # Format the prompt with variable substitution
    # For succession_crisis, we need leader-specific variables
    if crisis_type == 'succession_crisis':
        prompt = prompt_template.format(
            civ_name=civ_name,
            leader_name=leader_name,
            leader_age=game_state.civilization['leader']['age'],
            leader_life_expectancy=game_state.civilization['leader']['life_expectancy'],
            leader_years_ruled=game_state.civilization['leader'].get('years_ruled', 0),
            era=era
        )
    elif crisis_type == 'compound_crisis':
        prompt = prompt_template.format(
            civ_name=civ_name,
            leader_name=leader_name,
            population=population,
            food=food,
            wealth=wealth,
            happiness=game_state.population_happiness
        )
    elif crisis_type in ['economic_collapse', 'economic_crisis', 'economic_warning']:
        # Economic crises don't need population/food variables
        prompt = prompt_template.format(
            civ_name=civ_name,
            leader_name=leader_name,
            wealth=wealth,
            era=era
        )
    else:
        # Food-related crises need all standard variables
        prompt = prompt_template.format(
            civ_name=civ_name,
            leader_name=leader_name,
            population=population,
            food=food,
            days_of_food=days_of_food,
            era=era
        )

    try:
        response = model.generate_content(
            prompt,
            generation_config={
                "response_mime_type": "application/json",
                "temperature": 0.8
            }
        )
        event_data = json.loads(response.text)
        event_data['is_crisis'] = True
        event_data['crisis_type'] = crisis_type

        # Add event type to title
        crisis_type_label = crisis_type.replace('_', ' ').title()
        if 'title' in event_data:
            event_data['title'] = event_data['title'] + f" -- Crisis: {crisis_type_label}"

        print(f"--- Crisis event '{event_data.get('title', 'Unknown')}' generated ---")
        return event_data

    except Exception as e:
        print(f"Error generating crisis event: {e}")
        # Return emergency fallback
        crisis_type_label = crisis_type.replace('_', ' ').title()
        return {
            "title": f"A Dire Situation -- Crisis: {crisis_type_label}",
            "narrative": "Your civilization faces a grave crisis. Immediate action is required.",
            "investigation_options": ["Assess the situation", "Consult advisors"],
            "decision_options": ["Take emergency action", "Attempt desperate measures"],
            "is_crisis": True,
            "crisis_type": crisis_type
        }

def should_generate_crisis(game_state):
    """
    Determine if next event should be a crisis event.
    Returns (bool, crisis_type or None)
    """
    crisis_type = detect_crisis(game_state)

    if crisis_type:
        # Crisis events have high priority
        # Catastrophic crises trigger 100%
        if crisis_type in ['famine', 'economic_collapse', 'succession_crisis', 'compound_crisis']:
            return True, crisis_type
        # Active crisis tier: high trigger rates
        # Severe food shortage: 90% chance (active suffering)
        elif crisis_type == 'severe_food_shortage':
            import random
            return random.random() < 0.90, crisis_type
        # Warning tier: increased trigger rates to enforce new balance
        # Food shortage: 85% chance, Economic crisis: 80% chance
        elif crisis_type == 'food_shortage':
            import random
            return random.random() < 0.85, crisis_type
        elif crisis_type == 'economic_crisis':
            import random
            return random.random() < 0.80, crisis_type
        # Early warning tier: lower but significant rates
        # Economic warning: 75% chance (early warning)
        elif crisis_type == 'economic_warning':
            import random
            return random.random() < 0.75, crisis_type

    return False, None



################################################################################
# FILE: old_codebase\engines\data_validator.py
# Size: 2787 bytes
################################################################################

# engines/data_validator.py
"""
Data integrity validation for game state.
Checks referential integrity without modifying data.
"""

def validate_faction_references(game_state):
    """
    Validates that all faction_id references in inner_circle point to valid factions.

    Args:
        game_state: The GameState object containing all game data

    Returns:
        list: List of validation error messages (empty if all valid)
    """
    errors = []

    # Get factions data - handle both dict and list formats for backward compatibility
    factions_data = game_state.factions
    if isinstance(factions_data, dict):
        factions_list = factions_data.get('factions', [])
    elif isinstance(factions_data, list):
        factions_list = factions_data
    else:
        return ["ERROR: Invalid factions data structure"]

    # Build set of valid faction IDs
    valid_faction_ids = set()
    for faction in factions_list:
        if isinstance(faction, dict) and 'id' in faction:
            valid_faction_ids.add(faction['id'])

    # If no faction IDs found, system not yet migrated - skip validation
    if not valid_faction_ids:
        return []

    # Check inner circle references
    inner_circle = game_state.inner_circle
    if not isinstance(inner_circle, list):
        return ["ERROR: Invalid inner_circle data structure"]

    for character in inner_circle:
        if not isinstance(character, dict):
            continue

        char_name = character.get('name', 'Unknown')
        faction_id = character.get('faction_id')

        # Only validate if faction_id exists (backward compatibility)
        if faction_id:
            if faction_id not in valid_faction_ids:
                errors.append(
                    f"Character '{char_name}' references invalid faction_id: '{faction_id}'"
                )

    return errors


def validate_all(game_state):
    """
    Runs all validation checks on the game state.

    Args:
        game_state: The GameState object containing all game data

    Returns:
        dict: Dictionary with validation results
            {
                'valid': bool,
                'errors': list of error messages,
                'warnings': list of warning messages
            }
    """
    all_errors = []
    warnings = []

    # Check faction references
    faction_errors = validate_faction_references(game_state)
    all_errors.extend(faction_errors)

    # Add more validators here as they are created
    # e.g., validate_building_references(game_state)
    # e.g., validate_tech_references(game_state)

    return {
        'valid': len(all_errors) == 0,
        'errors': all_errors,
        'warnings': warnings
    }



################################################################################
# FILE: old_codebase\engines\event_generator.py
# Size: 23244 bytes
################################################################################

# engines/event_generator.py
"""
Event Generator Module

This module handles all event generation logic for the civilization game.
It generates initial events and subsequent event stages based on player interactions.

Refactored from event_engine.py for better maintainability and separation of concerns.
"""

import google.generativeai as genai
import json
from json import JSONDecodeError
import time
from engines.context_builder import build_event_context
from engines.tendency_analyzer import analyze_player_tendency, get_tendency_description
from model_config import TEXT_MODEL
from engines.prompt_loader import load_prompt

def api_call_with_retry(func, max_retries=3, initial_delay=1.0):
    """
    Wrapper for API calls with exponential backoff retry logic.

    Args:
        func: Callable that makes the API call
        max_retries: Maximum number of retry attempts
        initial_delay: Initial delay in seconds (doubles on each retry)

    Returns:
        API response or raises last exception
    """
    for attempt in range(max_retries):
        try:
            return func()
        except Exception as e:
            error_msg = str(e).lower()

            # Check for specific error types
            is_rate_limit = 'rate limit' in error_msg or 'quota' in error_msg
            is_auth_error = 'oauth' in error_msg or 'token' in error_msg or 'authentication' in error_msg or '401' in error_msg
            is_network_error = 'network' in error_msg or 'timeout' in error_msg or 'connection' in error_msg

            # Don't retry auth errors - they need user intervention
            if is_auth_error:
                print(f"‚ö†Ô∏è AUTHENTICATION ERROR: {e}")
                print("   Your API credentials may have expired. Please check your GEMINI_API_KEY.")
                raise

            # Last attempt - raise the error
            if attempt == max_retries - 1:
                print(f"‚ö†Ô∏è API call failed after {max_retries} attempts: {e}")
                raise

            # Calculate delay with exponential backoff
            delay = initial_delay * (2 ** attempt)

            # Add extra delay for rate limiting
            if is_rate_limit:
                delay *= 3
                print(f"‚è≥ Rate limit hit. Waiting {delay:.1f}s before retry {attempt + 2}/{max_retries}...")
            elif is_network_error:
                print(f"üåê Network error. Retrying in {delay:.1f}s (attempt {attempt + 2}/{max_retries})...")
            else:
                print(f"üîÑ API error. Retrying in {delay:.1f}s (attempt {attempt + 2}/{max_retries})...")

            time.sleep(delay)

    # Should never reach here, but just in case
    raise Exception("API call failed after all retries")

def generate_event(game_state):
    """Generates a contextually appropriate event with multi-stage interaction design."""
    # Priority 0: First Turn Council Briefing (one-time event)
    if game_state.turn_number == 0:
        print("--- Triggering First Turn Council Briefing ---")
        from engines.council_engine import generate_first_turn_briefing
        return generate_first_turn_briefing(game_state)

    # Check for other special, turn-based events
    # Council meetings: every 7 turns (7, 14, 21, 28...)
    # Faction audiences: every 4 turns (4, 8, 12, 16...)
    # Building events: every 5 turns (5, 10, 15, 20...)
    # These intervals don't heavily overlap, minimizing event collisions
    if game_state.turn_number > 0 and game_state.turn_number % 7 == 0:
        print("--- Triggering Council Meeting Event ---")
        from engines.council_engine import generate_council_meeting
        return generate_council_meeting(game_state)
    elif game_state.turn_number > 0 and game_state.turn_number % 4 == 0:
        print("--- Triggering Faction Audience Event ---")
        from engines.faction_engine import generate_faction_audience
        return generate_faction_audience(game_state)
    elif game_state.turn_number > 0 and game_state.turn_number % 5 == 0:
        print("--- Triggering Building Event ---")
        from engines.building_event_engine import generate_building_event
        return generate_building_event(game_state)

    # Priority 1: Check for crisis events (highest priority)
    from engines.crisis_engine import should_generate_crisis, generate_crisis_event

    is_crisis, crisis_type = should_generate_crisis(game_state)
    if is_crisis:
        print(f"üö® CRISIS DETECTED: {crisis_type.upper()} - Generating crisis event")
        event_data = generate_crisis_event(game_state, crisis_type)

        # Apply crisis updates immediately if present
        if "updates" in event_data and event_data["updates"]:
            from engines.state_validator import validate_updates
            from engines.state_updater import apply_updates
            is_valid, cleaned_updates, errors = validate_updates(event_data["updates"], game_state)

            if errors:
                print(f"--- Crisis Update Validation Warnings ---")
                for error in errors:
                    print(f"  - {error}")

            if cleaned_updates:
                print("--- Applying Crisis Mechanical Consequences ---")
                apply_updates(game_state, cleaned_updates)
            else:
                print("--- No valid crisis updates to apply ---")

        # Initialize event state
        game_state.current_event = event_data
        game_state.event_stage = 0
        game_state.event_conversation = []
        return event_data
    else:
        # Debug logging for crisis detection
        pop = game_state.civilization['population']
        food = game_state.civilization['resources']['food']
        wealth = game_state.civilization['resources']['wealth']
        food_pc = food / max(pop, 1)
        print(f"--- Crisis check: pop={pop}, food={food} ({food_pc:.2f} per capita), wealth={wealth} - No crisis ---")

    # Priority 2: Check for callback events (past consequences return)
    from engines.consequence_engine import check_for_callback_opportunity
    from engines.callback_engine import generate_callback_event

    has_callback, callback_type, callback_data = check_for_callback_opportunity(game_state)
    if has_callback:
        print(f"üìú CALLBACK EVENT: {callback_type} - Generating consequence event")
        event_data = generate_callback_event(game_state, callback_type, callback_data)
        # Initialize event state
        game_state.current_event = event_data
        game_state.event_stage = 0
        game_state.event_conversation = []
        return event_data

    # Priority 3: Generate normal event
    print("--- Generating new multi-stage event via Gemini API ---")
    model = genai.GenerativeModel(TEXT_MODEL)

    # Build optimized context (60% token reduction)
    context = build_event_context(game_state)

    # Enhanced tendency analysis
    primary_tendency, secondary_tendency = analyze_player_tendency(game_state.history_long)
    tendency_desc = get_tendency_description(primary_tendency, secondary_tendency)
    print(f"--- Player Tendency: {primary_tendency.upper()} (secondary: {secondary_tendency}) ---")

    # Get leader traits and event tags
    from engines.leader_engine import get_leader_event_tags, TRAIT_EFFECTS

    leader_tags = get_leader_event_tags(context['civilization']['leader'])
    trait_descriptions = []
    leader_traits = context['civilization']['leader'].get('traits', [])
    for trait in leader_traits:
        trait_data = TRAIT_EFFECTS.get(trait, {})
        if trait_data:
            trait_descriptions.append(f"{trait} ({trait_data.get('description', '')})")

    # Get last event for consequence chaining
    from engines.context_builder import get_last_event_summary, get_recent_event_titles
    last_event = get_last_event_summary(game_state.history_long)

    # Get recent event titles to avoid repetition
    recent_titles = get_recent_event_titles(game_state.history_long, num=4)

    # DEBUG: Log and handle active_policy
    print(f"--- DEBUG: Active policy before event generation: {game_state.active_policy} ---")
    active_policy_str = game_state.active_policy or "general_governance"
    active_policy_display = active_policy_str.replace('_', ' ').title()


    # Enhanced prompt for multi-stage events
    # Contextualize resource levels for AI
    pop = context['civilization']['population']
    food = context['civilization']['resources']['food']
    wealth = context['civilization']['resources']['wealth']
    happiness = game_state.population_happiness

    # Add contextual qualifiers to stats
    food_per_capita = food / max(pop, 1)
    if food_per_capita < 0.5:
        food_context = "critically low - starvation looms"
    elif food_per_capita < 1.0:
        food_context = "dangerously low for this population"
    elif food_per_capita < 2.0:
        food_context = "adequate but tight"
    else:
        food_context = "abundant stockpiles"

    if wealth < 100:
        wealth_context = "nearly bankrupt"
    elif wealth < 500:
        wealth_context = "meager reserves"
    elif wealth < 2000:
        wealth_context = "moderate treasury"
    else:
        wealth_context = "overflowing coffers"

    if happiness < 40:
        happiness_context = "widespread discontent and unrest"
    elif happiness < 60:
        happiness_context = "simmering tensions among the populace"
    elif happiness < 80:
        happiness_context = "cautious contentment"
    else:
        happiness_context = "joyous and thriving populace"

    # Add leader age context
    leader_age = context['civilization']['leader']['age']
    life_exp = context['civilization']['leader'].get('life_expectancy', 60)
    if leader_age > life_exp + 10:
        age_context = f"ancient and frail (far beyond the expected {life_exp} years)"
    elif leader_age > life_exp:
        age_context = f"elderly and weathered (past the expected {life_exp} years)"
    elif leader_age > life_exp - 10:
        age_context = "aging but still vigorous"
    elif leader_age < 30:
        age_context = "young and inexperienced"
    else:
        age_context = "in their prime"

    # Pre-calculate all formatted values and strings for the prompt
    pop_formatted = f"{pop:,}"
    food_formatted = f"{food:,}"
    wealth_formatted = f"{wealth:,}"
    happiness_formatted = f"{happiness:.1f}"
    trait_descriptions_str = ', '.join(trait_descriptions) if trait_descriptions else 'No special traits'
    culture_values_str = ', '.join(context['culture']['values'][:5])
    recent_discoveries_str = ', '.join(context['technology']['recent_discoveries'][-3:])
    recent_infrastructure_str = ', '.join(context['technology']['infrastructure'][-3:])
    leader_traits_str = ', '.join(context['civilization']['leader']['traits'])
    leader_tags_str = ', '.join(leader_tags[:5]) if leader_tags else 'General'
    recent_titles_str = ', '.join(recent_titles)
    infrastructure_recent_str = ', '.join(context['technology']['infrastructure'][-2:]) if context['technology']['infrastructure'] else 'none yet'
    primary_value = context['culture']['values'][0] if context['culture']['values'] else 'survival'

    # Format last_event as string
    if last_event:
        last_event_str = f"Previous event: '{last_event['title']}' - Player chose to '{last_event['action']}'. Result: {last_event['outcome']}"
    else:
        last_event_str = "This is the first event."

    # Load prompt template and fill in variables
    prompt_template = load_prompt('events/generate_event')
    prompt = prompt_template.format(
        era=context['civilization']['meta']['era'],
        civ_name=context['civilization']['meta']['name'],
        year=context['civilization']['meta']['year'],
        leader_name=context['civilization']['leader']['name'],
        leader_age=leader_age,
        age_context=age_context,
        trait_descriptions=trait_descriptions_str,
        population=pop_formatted,
        happiness=happiness_formatted,
        happiness_context=happiness_context,
        food=food_formatted,
        food_context=food_context,
        wealth=wealth_formatted,
        wealth_context=wealth_context,
        active_policy_display=active_policy_display,
        tech_tier=context['civilization']['resources']['tech_tier'],
        terrain=context['world']['geography']['terrain'],
        climate=context['world']['geography']['climate'],
        culture_values=culture_values_str,
        religion_name=context['religion']['name'],
        religion_type=context['religion']['type'],
        religion_influence=context['religion']['influence'],
        recent_discoveries=recent_discoveries_str,
        recent_infrastructure=recent_infrastructure_str,
        leader_traits=leader_traits_str,
        leader_tags=leader_tags_str,
        tendency_desc=tendency_desc,
        recent_titles=recent_titles_str,
        last_event=last_event_str,
        infrastructure_recent=infrastructure_recent_str,
        primary_value=primary_value
    )

    try:
        response = model.generate_content(
            prompt,
            generation_config={
                "response_mime_type": "application/json",
                "temperature": 0.9,
                "top_p": 0.95
            }
        )
        event_data = json.loads(response.text)

        # Add event type to title
        if 'title' in event_data:
            event_data['title'] = event_data['title'] + " -- Event"

        print(f"--- Event '{event_data.get('title', 'Unknown')}' successfully generated (Stage 0) ---")

        # Initialize event state
        game_state.current_event = event_data
        game_state.event_stage = 0
        game_state.event_conversation = []

        return event_data
    except JSONDecodeError as e:
        print(f"!!!!!!!!!! JSON PARSING ERROR !!!!!!!!!!!\nFailed to parse AI response: {e}")
        print(f"Raw response: {response.text if 'response' in locals() else 'No response'}")
        return {
            "title": "A Moment of Confusion -- Event",
            "narrative": "The spirits spoke in riddles that could not be understood. The chronicler needs to rest.",
            "suggested_actions": ["Wait for clarity", "Try again", "Check the server console"]
        }
    except Exception as e:
        error_msg = str(e)
        print(f"!!!!!!!!!! GEMINI API ERROR !!!!!!!!!!!\nError generating event: {e}")

        if "404" in error_msg or "not found" in error_msg.lower():
            print("NOTE: The AI model may not be available. Check your GEMINI_API_KEY and model name.")
        elif "quota" in error_msg.lower() or "rate limit" in error_msg.lower():
            print("NOTE: API quota exceeded. Please wait a moment before trying again.")
        elif "permission" in error_msg.lower() or "forbidden" in error_msg.lower():
            print("NOTE: API key may not have permission to use this model.")

        return {
            "title": "A Moment of Silence -- Event",
            "narrative": "The spirits are quiet, and the world feels still. An error prevented a new story from unfolding.",
            "suggested_actions": ["Wait for a sign", "Check the server console", "Restart the simulation", "Try a different approach"]
        }

def generate_event_stage(game_state, player_response):
    """Generates the next stage of an event based on player's investigation/question."""
    print(f"--- Generating event stage {game_state.event_stage + 1} based on '{player_response}' ---")
    model = genai.GenerativeModel(TEXT_MODEL)

    context = build_event_context(game_state)

    # Check if this is a council meeting
    is_council = game_state.current_event.get('event_type') == 'council_meeting'

    # Build conversation history
    conversation_history = "\n".join([
        f"Player: {entry['player']}\nResponse: {entry['ai']}"
        for entry in game_state.event_conversation
    ])

    # Contextualize resources for stage generation
    pop = context['civilization']['population']
    food = context['civilization']['resources']['food']
    wealth = context['civilization']['resources']['wealth']
    food_per_capita = food / max(pop, 1)

    if food_per_capita < 1.0:
        resource_mood = "hunger gnaws at the people's resolve"
    elif wealth < 100:
        resource_mood = "empty coffers weigh on every decision"
    elif food_per_capita > 3.0 and wealth > 2000:
        resource_mood = "prosperity emboldens the populace"
    else:
        resource_mood = "cautious stability prevails"

    if is_council:
        # COUNCIL MEETING: Conversational dialogue format
        advisor_stances = game_state.current_event.get('advisor_stances', [])
        advisor_list = "\n".join([
            f"- {a['name']} ({a['role']}): {a['position']}"
            for a in advisor_stances
        ])

        # Pre-calculate values for prompt
        central_dilemma = game_state.current_event.get('central_dilemma', 'Strategic decision needed')
        conversation_history_str = conversation_history if conversation_history else "This is the first question."

        # Load prompt template and fill in variables
        prompt_template = load_prompt('events/generate_event_stage_council')
        prompt = prompt_template.format(
            central_dilemma=central_dilemma,
            advisor_list=advisor_list,
            conversation_history=conversation_history_str,
            player_response=player_response
        )
    else:
        # NON-COUNCIL EVENTS: Keep existing narrative format
        # Pre-calculate values for prompt
        event_title = game_state.current_event['title']
        event_narrative = game_state.current_event['narrative']
        current_stage = game_state.event_stage + 1
        leader_name = context['civilization']['leader']['name']
        leader_age = context['civilization']['leader']['age']
        population_formatted = f"{pop:,}"
        food_formatted = f"{food:,}"
        wealth_formatted = f"{wealth:,}"
        tech_tier = context['civilization']['resources']['tech_tier']
        culture_values_str = ', '.join(context['culture']['values'][:5])
        religion_name = context['religion']['name']
        religion_influence = context['religion']['influence']
        conversation_history_str = conversation_history if conversation_history else "This is the first interaction."

        # Load prompt template and fill in variables
        prompt_template = load_prompt('events/generate_event_stage_regular')
        prompt = prompt_template.format(
            event_title=event_title,
            event_narrative=event_narrative,
            current_stage=current_stage,
            leader_name=leader_name,
            leader_age=leader_age,
            population=population_formatted,
            resource_mood=resource_mood,
            food=food_formatted,
            wealth=wealth_formatted,
            tech_tier=tech_tier,
            culture_values=culture_values_str,
            religion_name=religion_name,
            religion_influence=religion_influence,
            conversation_history=conversation_history_str,
            player_response=player_response
        )

    # Hard stage limit check
    if game_state.event_stage >= 6:
        print(f"--- Stage limit reached ({game_state.event_stage + 1}) ---")
        return {
            "narrative": "You've investigated thoroughly. The information swirls in your mind as you consider your options.",
            "investigation_options": [
                "Reflect on all you've learned one more time",
                "Seek final counsel from your closest advisor"
            ],
            "decision_options": [
                "Make the best decision with what you know",
                "Trust your instincts and act decisively"
            ]
        }

    try:
        response = model.generate_content(
            prompt,
            generation_config={
                "response_mime_type": "application/json",
                "temperature": 0.8
            }
        )
        stage_data = json.loads(response.text)

        print(f"--- Event stage {game_state.event_stage + 1} successfully generated ---")

        # Update event state
        # For council meetings, extract dialogue; for others, use narrative
        if is_council and "response" in stage_data:
            speaker = stage_data["response"].get("speaker", "Advisor")
            dialogue = stage_data["response"].get("dialogue", "...")
            ai_response = f"{speaker}: {dialogue}"

            # Add interjections if present
            if "interjections" in stage_data and stage_data["interjections"]:
                for interj in stage_data["interjections"]:
                    ai_response += f"\n{interj.get('speaker', 'Advisor')}: {interj.get('dialogue', '...')}"

            # Ensure narrative field exists at top level for frontend compatibility
            stage_data["narrative"] = ai_response
        else:
            ai_response = stage_data.get("narrative", "...")

        game_state.event_conversation.append({
            "player": player_response,
            "ai": ai_response
        })
        game_state.event_stage += 1

        # Validate we have all required fields
        if "investigation_options" not in stage_data or len(stage_data.get("investigation_options", [])) < 2:
            print("WARNING: Missing investigation_options. Adding fallback.")
            stage_data["investigation_options"] = [
                "Ask for more details",
                "Seek another perspective"
            ]

        if "decision_options" not in stage_data or len(stage_data.get("decision_options", [])) < 2:
            print("WARNING: Missing decision_options. Adding fallback.")
            stage_data["decision_options"] = [
                "Make a cautious decision",
                "Act boldly on current information"
            ]

        return stage_data
    except JSONDecodeError as e:
        print(f"!!!!!!!!!! JSON PARSING ERROR (Event Stage) !!!!!!!!!!!\n{e}")
        print(f"Raw response: {response.text if 'response' in locals() else 'No response'}")
        return {
            "narrative": "The situation grows unclear as you ponder your next move.",
            "investigation_options": ["Try a different approach", "Ask something else"],
            "decision_options": ["Proceed cautiously", "Act boldly"]
        }
    except Exception as e:
        print(f"!!!!!!!!!! GEMINI API ERROR (Event Stage) !!!!!!!!!!!\n{e}")
        return {
            "narrative": "An error clouds your vision, but you must continue.",
            "investigation_options": ["Try again", "Ask differently"],
            "decision_options": ["Trust your judgment", "Act with caution"]
        }



################################################################################
# FILE: old_codebase\engines\faction_engine.py
# Size: 5094 bytes
################################################################################

import json
import google.generativeai as genai
from model_config import TEXT_MODEL
from engines.prompt_loader import load_prompt


def apply_faction_decision_consequences(game_state, chosen_faction, affected_factions):
    """
    BALANCE_OVERHAUL: Apply asymmetric faction approval changes based on petition decisions.
    Favored faction gets moderate bonus, opposed factions get larger penalties (2:1 ratio).

    Args:
        chosen_faction: Faction ID that was favored
        affected_factions: List of faction IDs that were opposed
    """
    if not hasattr(game_state, 'faction_manager'):
        return

    # Favor chosen faction: +20 approval
    game_state.faction_manager.update_approval(chosen_faction, 20)
    game_state.faction_manager.add_history_entry(
        chosen_faction,
        "Decision favored your petition",
        20,
        game_state.turn_number
    )
    print(f"  ‚úì {chosen_faction}: +20 approval (decision favored them)")

    # Penalize opposed factions asymmetrically (2:1 ratio)
    for opposed_faction in affected_factions:
        # Calculate penalty based on faction relationships
        base_penalty = -40  # Base 2:1 ratio

        # Check if this faction has low approval (they hold grudges)
        faction_data = game_state.faction_manager.get_by_id(opposed_faction)
        if faction_data and faction_data.get('approval', 60) < 40:
            base_penalty = -50  # Already angry factions react worse

        game_state.faction_manager.update_approval(opposed_faction, base_penalty)
        game_state.faction_manager.add_history_entry(
            opposed_faction,
            "Decision opposed your interests",
            base_penalty,
            game_state.turn_number
        )
        print(f"  ‚úó {opposed_faction}: {base_penalty} approval (decision opposed them)")

    # Check for conspiracy conditions (2+ factions below 30 approval)
    low_approval_factions = [
        f for f in game_state.faction_manager.get_all()
        if f.get('approval', 60) < 30
    ]

    if len(low_approval_factions) >= 2:
        print(f"  ‚ö†Ô∏è WARNING: {len(low_approval_factions)} factions below 30 approval - CONSPIRACY RISK HIGH")
        # This will trigger conspiracy events in event_engine.py


def generate_faction_audience(game_state):
    """
    Generates faction petitions by calling a generative AI model.

    Constructs a prompt with faction data, sends it to the AI, and processes
    the JSON response to create a faction audience event.

    Args:
        game_state (dict): The current state of the game.

    Returns:
        dict: A dictionary representing the faction audience event,
              or an empty dictionary if an error occurs.
    """
    # Access factions through manager
    if not hasattr(game_state, 'faction_manager'):
        print("Warning: No faction manager available. Skipping faction audience.")
        return {}

    factions = game_state.faction_manager.get_all()
    if not factions:
        print("Warning: No factions available. Skipping faction audience.")
        return {}

    # Contextualize faction approval levels
    faction_contexts = []
    for faction in factions:
        faction_name = faction.get('name', 'Unknown')
        goals = ", ".join(faction.get("goals", []))
        approval = faction.get("approval", 50)

        # Add approval context
        if approval >= 75:
            approval_desc = f"{approval} (Loyal and supportive)"
        elif approval >= 50:
            approval_desc = f"{approval} (Pleased)"
        elif approval >= 25:
            approval_desc = f"{approval} (Discontent)"
        else:
            approval_desc = f"{approval} (Angry and hostile)"

        faction_contexts.append({
            'name': faction_name,
            'goals': goals,
            'approval': approval,
            'approval_desc': approval_desc
        })

    # Build faction list for prompt
    faction_list = ""
    for fc in faction_contexts:
        faction_list += f"- {fc['name']}:\n"
        faction_list += f"  - Goals: {fc['goals']}\n"
        faction_list += f"  - Approval: {fc['approval_desc']}\n"
    prompt = load_prompt('factions/faction_audience').format(
        faction_list=faction_list
    )

    try:
        model = genai.GenerativeModel(TEXT_MODEL)
        response = model.generate_content(
            prompt,
            generation_config={"response_mime_type": "application/json"},
        )
        result = json.loads(response.text)
        result["event_type"] = "faction_audience"

        # Add event type to title
        if 'title' in result:
            result['title'] = result['title'] + " -- Faction Audience"

        # Initialize event state
        game_state.current_event = result
        game_state.event_stage = 0
        game_state.event_conversation = []

        return result
    except Exception as e:
        print(f"Error generating faction audience: {e}")
        return {}


################################################################################
# FILE: old_codebase\engines\faction_manager.py
# Size: 6005 bytes
################################################################################

"""
FactionManager - Centralized faction access with ID and name-based lookups.
Provides backward compatibility while enabling ID-based references.
"""

class FactionManager:
    def __init__(self, factions_data):
        """
        Initialize faction manager.

        Args:
            factions_data: Dictionary with 'factions' key containing list of faction dicts
                         OR a list of faction dicts directly (backward compat)
        """
        # Handle both dict and list formats
        if isinstance(factions_data, dict):
            self._factions = factions_data.get('factions', [])
        elif isinstance(factions_data, list):
            self._factions = factions_data
        else:
            self._factions = []

        # Build indices for fast lookups
        self._id_index = {}
        self._name_index = {}

        for faction in self._factions:
            if 'id' in faction:
                self._id_index[faction['id']] = faction
            if 'name' in faction:
                self._name_index[faction['name']] = faction

    def get_by_id(self, faction_id):
        """
        Get faction by ID (preferred method).

        Args:
            faction_id: Faction ID string (e.g., 'faction_merchants_guild_001')

        Returns:
            Faction dict or None if not found
        """
        return self._id_index.get(faction_id)

    def get_by_name(self, faction_name):
        """
        Get faction by name (legacy compatibility).

        Args:
            faction_name: Faction name string (e.g., 'The Merchant\'s Guild')

        Returns:
            Faction dict or None if not found
        """
        return self._name_index.get(faction_name)

    def get_all(self):
        """
        Get all factions as a list.

        Returns:
            List of faction dicts
        """
        return self._factions

    def to_dict(self):
        """
        Convert to dictionary format for JSON serialization.

        Returns:
            Dictionary with 'factions' key
        """
        return {"factions": self._factions}

    def update_approval(self, faction_id, change):
        """
        Update faction approval rating.

        Args:
            faction_id: Faction ID or name (checks both)
            change: Integer change to apply (can be negative)

        Returns:
            True if updated, False if faction not found
        """
        # Try ID first, then name
        faction = self.get_by_id(faction_id)
        if not faction:
            faction = self.get_by_name(faction_id)

        if faction:
            current = faction.get('approval', 60)
            faction['approval'] = max(0, min(100, current + change))
            return True
        return False

    def __len__(self):
        """Return number of factions."""
        return len(self._factions)

    def __iter__(self):
        """Allow iteration over factions."""
        return iter(self._factions)

    def get_faction_bonuses(self, game_state):
        """
        BALANCE_OVERHAUL: Calculate passive mechanical effects from faction approval levels.
        Returns dict of bonuses/penalties to apply to game state.
        """
        bonuses = {
            'wealth_multiplier': 1.0,
            'military_effectiveness': 1.0,
            'happiness_modifier': 0
        }

        for faction in self._factions:
            faction_id = faction.get('id', '')
            approval = faction.get('approval', 60)

            # Merchant's Guild effects
            if 'merchant' in faction_id.lower():
                if approval >= 75:
                    bonuses['wealth_multiplier'] *= 1.10  # +10% wealth
                elif approval < 50 and approval >= 25:
                    bonuses['wealth_multiplier'] *= 0.90  # -10% wealth
                elif approval < 25:
                    bonuses['wealth_multiplier'] *= 0.75  # -25% wealth

            # Warrior Caste effects
            elif 'warrior' in faction_id.lower() or 'military' in faction_id.lower():
                if approval >= 75:
                    bonuses['military_effectiveness'] *= 1.15  # +15% military
                elif approval < 50 and approval >= 25:
                    bonuses['military_effectiveness'] *= 0.85  # -15% military
                elif approval < 25:
                    bonuses['military_effectiveness'] *= 0.70  # -30% military

            # Priest Order effects
            elif 'priest' in faction_id.lower() or 'religious' in faction_id.lower():
                if approval >= 75:
                    bonuses['happiness_modifier'] += 10
                elif approval < 50 and approval >= 25:
                    bonuses['happiness_modifier'] -= 10
                elif approval < 25:
                    bonuses['happiness_modifier'] -= 20

        return bonuses

    def add_history_entry(self, faction_id, reason, change, turn_number):
        """
        Add history entry to faction for context and UI display.

        Args:
            faction_id: Faction ID or name
            reason: Human-readable reason for the change
            change: Integer change to approval (can be negative)
            turn_number: Current turn number for indexing

        Returns:
            True if added, False if faction not found
        """
        # Try ID first, then name
        faction = self.get_by_id(faction_id)
        if not faction:
            faction = self.get_by_name(faction_id)

        if faction:
            history = faction.setdefault('history', [])
            entry = f"Turn {turn_number}: {reason} ({change:+d} approval)"
            history.append(entry)

            # Keep last 10 entries to avoid JSON bloat
            if len(history) > 10:
                faction['history'] = history[-10:]

            return True
        return False



################################################################################
# FILE: old_codebase\engines\history_compression_engine.py
# Size: 15992 bytes
################################################################################

"""
History Compression Engine - Archives important historical events and decrees
Compresses long-term history while preserving civilization-defining moments
"""

import json
from typing import List, Dict, Any


class HistoryCompressionEngine:
    """Manages compression and archival of historical events"""

    def __init__(self, game_state):
        self.game_state = game_state
        self.current_year = game_state.current_year

    def compress_history(self, events: List[Dict[str, Any]], current_era: str) -> Dict[str, Any]:
        """
        Compress a list of historical events into era-based archives

        Args:
            events: List of event dicts with year, title, action, narrative
            current_era: Current game era

        Returns:
            Compressed history structure
        """
        if not events:
            return self._get_empty_compressed_history()

        # Load existing compressed history
        compressed = self._load_compressed_history()

        # Categorize events by importance
        categorized = self._categorize_events(events)

        # Group into eras (50-year periods for now, 500-year for timeskips)
        era_groups = self._group_by_era(categorized)

        # Add to compressed history
        for era_data in era_groups:
            compressed['eras'].append(era_data)

        # Update metadata
        compressed['last_compression_year'] = self.current_year
        compressed['total_events_compressed'] = compressed.get('total_events_compressed', 0) + len(events)

        return compressed

    def _load_compressed_history(self) -> Dict[str, Any]:
        """Load existing compressed history or create empty structure"""
        try:
            import os
            context_path = self.game_state.context_path
            compressed_path = os.path.join(context_path, 'history_compressed.json')

            if os.path.exists(compressed_path):
                with open(compressed_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
        except Exception as e:
            print(f"Could not load compressed history: {e}")

        return self._get_empty_compressed_history()

    def _get_empty_compressed_history(self) -> Dict[str, Any]:
        """Create empty compressed history structure"""
        return {
            'eras': [],
            'last_compression_year': 0,
            'total_events_compressed': 0,
            'civilization_defining_moments': []
        }

    def _categorize_events(self, events: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
        """
        Categorize events by importance level

        Returns dict with keys: civilization_defining, major, significant, minor
        """
        categorized = {
            'civilization_defining': [],
            'major': [],
            'significant': [],
            'minor': []
        }

        for event in events:
            importance = self._assess_event_importance(event)
            categorized[importance].append({
                **event,
                'importance': importance
            })

        return categorized

    def _assess_event_importance(self, event: Dict[str, Any]) -> str:
        """
        Assess the importance of a historical event

        Returns: 'civilization_defining', 'major', 'significant', or 'minor'
        """
        action = event.get('action', '').lower()
        title = event.get('title', '').lower()
        narrative = event.get('narrative', '').lower()
        combined = action + ' ' + title + ' ' + narrative

        score = 0

        # Check for permanent decree indicators
        decree_keywords = ['forever', 'eternal', 'holy law', 'decree', 'mandate', 'constitution']
        score += sum(5 for keyword in decree_keywords if keyword in combined)

        # Check for major structural changes
        structural_keywords = ['reform', 'revolution', 'new era', 'fundamental', 'transformation']
        score += sum(4 for keyword in structural_keywords if keyword in combined)

        # Check for war/peace
        conflict_keywords = ['war', 'peace treaty', 'alliance', 'conquest', 'defeat']
        score += sum(3 for keyword in conflict_keywords if keyword in combined)

        # Check for cultural/religious changes
        cultural_keywords = ['tradition', 'belief', 'religion', 'culture', 'values']
        score += sum(3 for keyword in cultural_keywords if keyword in combined)

        # Check for technological breakthroughs
        tech_keywords = ['discover', 'invent', 'breakthrough', 'advancement', 'innovation']
        score += sum(3 for keyword in tech_keywords if keyword in combined)

        # Length indicates substantive action
        if len(action) > 200:
            score += 5
        elif len(action) > 100:
            score += 2

        # Categorize based on score
        if score >= 20:
            return 'civilization_defining'
        elif score >= 12:
            return 'major'
        elif score >= 6:
            return 'significant'
        else:
            return 'minor'

    def _group_by_era(self, categorized: Dict[str, List[Dict[str, Any]]]) -> List[Dict[str, Any]]:
        """
        Group categorized events into era structures

        Returns list of era dicts
        """
        all_events = []
        for importance, events in categorized.items():
            all_events.extend(events)

        if not all_events:
            return []

        # Sort by year
        all_events.sort(key=lambda e: e.get('year', 0))

        # Group into eras (we'll define eras by 50-year spans for regular play)
        eras = []
        current_era_events = []
        era_start = None

        for event in all_events:
            year = event.get('year', 0)

            if era_start is None:
                era_start = year

            # Check if we need to start a new era (50 year spans)
            if year - era_start > 50 and current_era_events:
                # Close current era
                eras.append(self._create_era_summary(era_start, year - 1, current_era_events))
                current_era_events = []
                era_start = year

            current_era_events.append(event)

        # Add final era
        if current_era_events:
            final_year = current_era_events[-1].get('year', era_start)
            eras.append(self._create_era_summary(era_start, final_year, current_era_events))

        return eras

    def _create_era_summary(self, start_year: int, end_year: int, events: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Create a summary for an era"""
        # Extract only the most important events for the summary
        civ_defining = [e for e in events if e.get('importance') == 'civilization_defining']
        major = [e for e in events if e.get('importance') == 'major']
        significant = [e for e in events if e.get('importance') == 'significant']

        # Generate era name based on most important event
        era_name = self._generate_era_name(civ_defining + major, start_year, end_year)

        defining_events = []

        # Always include civilization-defining events
        for event in civ_defining:
            defining_events.append({
                'year': event['year'],
                'importance': event['importance'],
                'type': self._classify_event_type(event),
                'title': event['title'],
                'summary': event.get('action', '')[:200] + '...' if len(event.get('action', '')) > 200 else event.get('action', ''),
                'lasting_effects': True
            })

        # Include major events (up to 3)
        for event in major[:3]:
            defining_events.append({
                'year': event['year'],
                'importance': event['importance'],
                'type': self._classify_event_type(event),
                'title': event['title'],
                'summary': event.get('action', '')[:150] + '...' if len(event.get('action', '')) > 150 else event.get('action', ''),
                'lasting_effects': self._has_lasting_effects(event)
            })

        return {
            'name': era_name,
            'start_year': start_year,
            'end_year': end_year,
            'total_events': len(events),
            'defining_events': defining_events,
            'era_character': self._describe_era_character(events)
        }

    def _generate_era_name(self, important_events: List[Dict[str, Any]], start_year: int, end_year: int) -> str:
        """Generate a descriptive name for the era"""
        if not important_events:
            return f"The Years {start_year}-{end_year}"

        # Use the most important event to name the era
        first_event = important_events[0]
        title = first_event.get('title', '')

        # Extract key themes
        action = first_event.get('action', '').lower()

        if 'divine' in action or 'holy' in action or 'sacred' in action:
            return f"The Age of Divine Decree (Years {start_year}-{end_year})"
        elif 'war' in action or 'conquest' in action or 'battle' in action:
            return f"The Age of Conflict (Years {start_year}-{end_year})"
        elif 'peace' in action or 'harmony' in action:
            return f"The Age of Peace (Years {start_year}-{end_year})"
        elif 'reform' in action or 'change' in action:
            return f"The Age of Transformation (Years {start_year}-{end_year})"
        else:
            # Use part of the title
            short_title = ' '.join(title.split()[:3])
            return f"The Era of {short_title} (Years {start_year}-{end_year})"

    def _classify_event_type(self, event: Dict[str, Any]) -> str:
        """Classify the type of event"""
        combined = (event.get('action', '') + ' ' + event.get('title', '')).lower()

        if any(k in combined for k in ['holy law', 'divine', 'sacred mandate']):
            return 'holy_law'
        elif any(k in combined for k in ['constitution', 'government reform']):
            return 'constitutional'
        elif any(k in combined for k in ['war', 'battle', 'conquest']):
            return 'military'
        elif any(k in combined for k in ['peace', 'treaty', 'alliance']):
            return 'diplomatic'
        elif any(k in combined for k in ['tradition', 'culture', 'belief']):
            return 'cultural'
        elif any(k in combined for k in ['discover', 'invent', 'technology']):
            return 'technological'
        elif any(k in combined for k in ['religion', 'temple', 'priest']):
            return 'religious'
        else:
            return 'general'

    def _has_lasting_effects(self, event: Dict[str, Any]) -> bool:
        """Determine if an event has lasting effects"""
        action = event.get('action', '').lower()
        permanence_keywords = ['forever', 'eternal', 'always', 'permanently', 'established', 'decree', 'law']
        return any(keyword in action for keyword in permanence_keywords)

    def _describe_era_character(self, events: List[Dict[str, Any]]) -> str:
        """Generate a brief description of the era's overall character"""
        if not events:
            return "A quiet period in history"

        # Count event types
        type_counts = {}
        for event in events:
            event_type = self._classify_event_type(event)
            type_counts[event_type] = type_counts.get(event_type, 0) + 1

        # Find dominant theme
        dominant_type = max(type_counts.items(), key=lambda x: x[1])[0] if type_counts else 'general'

        descriptions = {
            'holy_law': "An era of religious transformation and divine mandate",
            'constitutional': "A period of governmental reform and structural change",
            'military': "A time marked by warfare and military expansion",
            'diplomatic': "An age of diplomacy, alliances, and political maneuvering",
            'cultural': "A flourishing of cultural development and tradition",
            'technological': "An era of innovation and technological advancement",
            'religious': "A time of spiritual growth and religious devotion",
            'general': "A period of varied developments and general growth"
        }

        return descriptions.get(dominant_type, "A dynamic period in civilization's history")

    def archive_decree(self, decree: Dict[str, Any]) -> None:
        """
        Immediately archive a civilization-defining decree

        Args:
            decree: The permanent decree to archive
        """
        compressed = self._load_compressed_history()

        # Add to civilization-defining moments
        if 'civilization_defining_moments' not in compressed:
            compressed['civilization_defining_moments'] = []

        moment = {
            'year': decree['declared_year'],
            'type': decree['type'],
            'title': decree['title'],
            'declared_by': decree['declared_by'],
            'summary': decree['declaration_text'][:300] + '...' if len(decree['declaration_text']) > 300 else decree['declaration_text'],
            'decree_id': decree['id'],
            'importance': decree['importance'],
            'archived_year': self.current_year
        }

        compressed['civilization_defining_moments'].append(moment)

        # Save compressed history
        self._save_compressed_history(compressed)

    def _save_compressed_history(self, compressed: Dict[str, Any]) -> None:
        """Save compressed history to disk"""
        try:
            import os
            context_path = self.game_state.context_path
            compressed_path = os.path.join(context_path, 'history_compressed.json')

            with open(compressed_path, 'w', encoding='utf-8') as f:
                json.dump(compressed, f, indent=4, ensure_ascii=False)
        except Exception as e:
            print(f"Error saving compressed history: {e}")

    def get_compressed_summary(self, max_eras: int = 5) -> str:
        """
        Get a formatted summary of compressed history for AI context

        Args:
            max_eras: Maximum number of recent eras to include

        Returns:
            Formatted string summarizing compressed history
        """
        compressed = self._load_compressed_history()

        if not compressed.get('eras') and not compressed.get('civilization_defining_moments'):
            return "No compressed history available."

        lines = ["=== COMPRESSED HISTORICAL ARCHIVE ===\n"]

        # Include civilization-defining moments first
        if compressed.get('civilization_defining_moments'):
            lines.append("CIVILIZATION-DEFINING MOMENTS:")
            for moment in compressed['civilization_defining_moments'][-5:]:  # Last 5
                lines.append(f"  ‚Ä¢ Year {moment['year']}: {moment['title']}")
                lines.append(f"    ({moment['type']}, declared by {moment['declared_by']})")
            lines.append("")

        # Include recent eras
        if compressed.get('eras'):
            recent_eras = compressed['eras'][-max_eras:]
            lines.append("RECENT HISTORICAL ERAS:")
            for era in recent_eras:
                lines.append(f"\n  {era['name']}")
                lines.append(f"  Character: {era['era_character']}")
                if era.get('defining_events'):
                    lines.append("  Key Events:")
                    for event in era['defining_events'][:3]:  # Top 3 per era
                        lines.append(f"    - Year {event['year']}: {event['title']} ({event['type']})")

        return "\n".join(lines)



################################################################################
# FILE: old_codebase\engines\image_engine.py
# Size: 7171 bytes
################################################################################

import google.generativeai as genai
import json
from PIL import Image
import io
import base64
from engines.context_builder import build_image_context
from model_config import IMAGE_MODEL

def generate_settlement_image(game_state):
    """
    Generates a new settlement visualization based on the current game state
    using the configured image generation model, then resizes it.
    """
    print("--- Generating new settlement image via Gemini API ---")
    model = genai.GenerativeModel(IMAGE_MODEL)

    # Build optimized visual context
    context = build_image_context(game_state)

    # Determine settlement size descriptor
    pop = context['civilization']['population']
    if pop < 100:
        size_desc = "small primitive camp"
    elif pop < 500:
        size_desc = "modest village"
    elif pop < 2000:
        size_desc = "thriving town"
    elif pop < 10000:
        size_desc = "large settlement"
    else:
        size_desc = "sprawling city"

    # Extract key visual elements from recent history
    recent_event_context = ""
    if context['recent_major_events']['events']:
        latest = context['recent_major_events']['events'][-1]
        recent_event_context = f"\nRecent historical context: {latest.get('narrative', '')[:100]}"

    # Extract contextual details
    culture_values = context['culture'].get('values', [])
    primary_values = ', '.join(culture_values[:3]) if culture_values else 'survival and tradition'

    # Structured image prompt with enhanced narrative guidance
    prompt = f"""Generate a richly detailed, atmospheric view of {context['civilization']['name']}, a {size_desc} in the {context['civilization']['era']} era.

**VISUAL NARRATIVE PURPOSE:** Capture the unique identity of this civilization. This is not a generic settlement - it's {context['civilization']['name']}, shaped by its culture, terrain, and history.

SETTLEMENT IDENTITY:
- Civilization: {context['civilization']['name']}
- Era: {context['civilization']['era']}
- Technology Level: {context['civilization']['tech_tier']} (CRITICAL: architecture style must be era-authentic)
- Population: {context['civilization']['population']:,} souls (settlement size MUST match this - {size_desc})
- Cultural Character: Values {primary_values}

ENVIRONMENTAL SETTING:
- Terrain: {context['world']['terrain']} (integrate this terrain visually - rivers, hills, forests, etc.)
- Climate: {context['world']['climate']} (affects vegetation, weather, sky, atmosphere)
- Natural Resources: {', '.join(context['world'].get('resources', ['basic resources']))} (show mines, farms, quarries, etc.){recent_event_context}

CULTURAL & RELIGIOUS LANDSCAPE:
- Primary Religion: {context['religion']['name']} (religious structures should be prominent)
- Holy Sites: {', '.join(context['religion'].get('holy_sites', ['sacred grounds']))} (incorporate into layout)
- Social Structure: {context['culture']['social_structure']} (show class divisions - palaces vs dwellings)
- Cultural Aesthetic: Values like "{primary_values}" should influence architecture (e.g., martial culture = fortifications, artistic culture = decorative elements, religious culture = grand temples)

VISUAL STORYTELLING REQUIREMENTS:
1. **Era-Authentic Architecture**: {context['civilization']['tech_tier']} must dictate building style
   - stone_age: Primitive huts, campfires, animal hide tents
   - bronze_age: Mud brick, early stone, simple walls
   - iron_age: Solid stone buildings, defensive fortifications
   - classical: Grand architecture, organized city planning, columns
   - medieval: Castles, cathedrals, dense medieval urban core
   - renaissance: Ornate buildings, public squares, artistic details

2. **Population-Appropriate Scale**: {context['civilization']['population']:,} people = {size_desc}

3. **Terrain Integration**: Settlement works WITH {context['world']['terrain']} (not generic flat land)

4. **Climate Atmosphere**: {context['world']['climate']} affects everything - vegetation, sky, weather, colors

5. **Cultural Identity**: The values "{primary_values}" should be VISIBLE in the layout and architecture

6. **Religious Presence**: {context['religion']['name']} worship creates visible landmarks

TECHNICAL REQUIREMENTS:
- Perspective: Isometric or elevated top-down showing full settlement
- Art Style: Painterly, strategy game aesthetic (think Civilization, Age of Empires)
- Lighting: Atmospheric (golden hour, dramatic clouds, natural lighting)
- Detail: Rich foreground detail, atmospheric background
- NO text, UI, labels, or modern elements
- Color palette matching {context['civilization']['era']} era and {context['world']['climate']} climate

**REACTIVITY REQUIREMENT:**
This is {context['civilization']['name']} - make it DISTINCTIVE. Its {context['civilization']['tech_tier']} technology, {context['world']['terrain']} terrain, {context['world']['climate']} climate, and focus on "{primary_values}" should create a unique visual signature.

Generate a single, breathtaking settlement scene that tells this civilization's story."""

    try:
        response = model.generate_content(prompt)

        image_data = None
        # Robustly search for the image data in the response parts
        if response.candidates and response.candidates[0].content and response.candidates[0].content.parts:
            for part in response.candidates[0].content.parts:
                if part.inline_data and part.inline_data.data:
                    image_data = part.inline_data.data
                    break

        if image_data:
            image_path = "static/settlement.png"

            # Open the image from the binary data using Pillow
            img = Image.open(io.BytesIO(image_data))

            # Resize the image to be 200% larger using a high-quality filter
            new_size = (img.width * 2, img.height * 2)
            resized_img = img.resize(new_size, Image.Resampling.LANCZOS)

            # Save the resized image
            resized_img.save(image_path)

            print(f"--- Settlement image successfully generated, resized, and saved to {image_path} ---")
            return {"image_path": image_path, "success": True}
        else:
            raise ValueError("No image data found in the API response.")

    except Exception as e:
        print(f"!!!!!!!!!! GEMINI API ERROR (Image Generation) !!!!!!!!!!!")
        print(f"Error generating image: {e}")
        return {"image_path": "static/placeholder.png", "success": False, "error": str(e)}

def edit_settlement_image(game_state, current_image_path):
    """
    Edits an existing settlement visualization based on new game state changes.
    (Placeholder for future implementation)
    """
    print("--- Editing settlement image (placeholder) ---")
    # Future implementation will involve image-to-image generation or editing
    # For now, it will just return the existing image or a placeholder.
    return {"image_path": current_image_path, "success": True, "message": "Image editing not yet implemented, returning current image."}




################################################################################
# FILE: old_codebase\engines\image_update_manager.py
# Size: 6645 bytes
################################################################################

"""
Image Update Manager - Intelligent decision logic for when to regenerate images.

This module determines when character portraits and settlement images should be updated
based on significant game state changes, while avoiding excessive API calls.
"""

from typing import Dict, Any, Optional, Tuple
import copy


class ImageUpdateTracker:
    """Tracks the last state when images were generated to detect significant changes."""

    def __init__(self):
        self.last_portrait_state = {}
        self.last_settlement_state = {}

    def update_portrait_state(self, game_state):
        """Record current state after generating a portrait."""
        leader = game_state.civilization.get('leader', {})
        self.last_portrait_state = {
            'age': leader.get('age', 0),
            'traits': copy.deepcopy(leader.get('traits', [])),
            'wealth': game_state.civilization.get('resources', {}).get('wealth', 0),
            'turns_since_update': 0
        }

    def update_settlement_state(self, game_state):
        """Record current state after generating a settlement image."""
        civ = game_state.civilization
        self.last_settlement_state = {
            'population': civ.get('population', 0),
            'era': civ.get('meta', {}).get('era', 'stone_age'),
            'infrastructure': copy.deepcopy(civ.get('technology', {}).get('infrastructure', [])),
        }

    def increment_turns(self):
        """Increment turn counter for portrait updates."""
        if 'turns_since_update' in self.last_portrait_state:
            self.last_portrait_state['turns_since_update'] += 1


# Global tracker instance
_tracker = ImageUpdateTracker()


def should_update_leader_portrait(game_state,
                                  aging_changes: Optional[list] = None) -> Tuple[bool, str]:
    """
    Determine if the leader portrait should be regenerated.

    Returns:
        (should_update, reason) - Boolean and string explaining why
    """
    leader = game_state.civilization.get('leader', {})
    current_age = leader.get('age', 0)
    current_traits = leader.get('traits', [])
    current_wealth = game_state.civilization.get('resources', {}).get('wealth', 0)

    last_state = _tracker.last_portrait_state

    # First portrait generation (no previous state)
    if not last_state:
        return True, "Initial portrait generation"

    # Check 1: Every 10 turns (as requested)
    turns_since = last_state.get('turns_since_update', 0)
    if turns_since >= 10:
        return True, f"Regular update after {turns_since} turns"

    # Check 2: Trait changes (aging effects are significant)
    if aging_changes and len(aging_changes) > 0:
        # Only update for significant trait changes
        for change in aging_changes:
            if 'gained' in change.lower() or 'lost' in change.lower():
                return True, f"Trait change: {aging_changes[0]}"

    # Check 3: Significant age milestones (every 20% of life expectancy)
    last_age = last_state.get('age', 0)
    life_exp = leader.get('life_expectancy', 80)

    age_percent_now = (current_age / life_exp) * 100
    age_percent_last = (last_age / life_exp) * 100

    # Detect crossing 20% thresholds (0-20%, 20-40%, 40-60%, 60-80%, 80-100%)
    threshold_now = int(age_percent_now / 20)
    threshold_last = int(age_percent_last / 20)

    if threshold_now > threshold_last:
        return True, f"Age milestone: {threshold_now * 20}% of life expectancy"

    # Check 4: Wealth tier changes (major prosperity/poverty changes)
    last_wealth = last_state.get('wealth', 0)
    wealth_tier_now = _get_wealth_tier(current_wealth)
    wealth_tier_last = _get_wealth_tier(last_wealth)

    if wealth_tier_now != wealth_tier_last:
        return True, f"Wealth change: {wealth_tier_last} -> {wealth_tier_now}"

    # No significant changes detected
    return False, "No significant changes"


def should_update_settlement_image(game_state) -> Tuple[bool, str]:
    """
    Determine if the settlement image should be regenerated.

    Returns:
        (should_update, reason) - Boolean and string explaining why
    """
    civ = game_state.civilization
    current_pop = civ.get('population', 0)
    current_era = civ.get('meta', {}).get('era', 'stone_age')
    current_infra = civ.get('technology', {}).get('infrastructure', [])

    last_state = _tracker.last_settlement_state

    # First settlement generation (no previous state)
    if not last_state:
        return True, "Initial settlement generation"

    # Check 1: Era change (major visual impact)
    last_era = last_state.get('era', 'stone_age')
    if current_era != last_era:
        return True, f"Era change: {last_era} -> {current_era}"

    # Check 2: Population size category change
    last_pop = last_state.get('population', 0)
    size_cat_now = _get_settlement_size_category(current_pop)
    size_cat_last = _get_settlement_size_category(last_pop)

    if size_cat_now != size_cat_last:
        return True, f"Settlement growth: {size_cat_last} -> {size_cat_now}"

    # Check 3: Major infrastructure additions (only significant ones)
    last_infra = last_state.get('infrastructure', [])
    significant_infra = ['Walls', 'Great Temple', 'Grand Market', 'Palace', 'Observatory']

    for infra in current_infra:
        if infra in significant_infra and infra not in last_infra:
            return True, f"Major infrastructure: {infra} completed"

    # No significant changes detected
    return False, "No significant changes"


def _get_wealth_tier(wealth: int) -> str:
    """Categorize wealth into tiers for comparison."""
    if wealth < 50:
        return "impoverished"
    elif wealth < 200:
        return "modest"
    elif wealth < 500:
        return "prosperous"
    elif wealth < 1000:
        return "wealthy"
    else:
        return "opulent"


def _get_settlement_size_category(population: int) -> str:
    """Categorize population into settlement size categories."""
    if population < 100:
        return "camp"
    elif population < 500:
        return "village"
    elif population < 2000:
        return "town"
    elif population < 10000:
        return "city"
    else:
        return "metropolis"


def get_tracker() -> ImageUpdateTracker:
    """Get the global image update tracker."""
    return _tracker


def reset_tracker():
    """Reset the tracker (useful for testing or new games)."""
    global _tracker
    _tracker = ImageUpdateTracker()



################################################################################
# FILE: old_codebase\engines\inner_circle_manager.py
# Size: 3966 bytes
################################################################################

"""
InnerCircleManager - Centralized character access and relationship tracking.
"""

class InnerCircleManager:
    def __init__(self, characters_data):
        """
        Initialize inner circle manager.

        Args:
            characters_data: List of character dicts OR dict with 'characters' key
        """
        # Handle both list and dict formats
        if isinstance(characters_data, dict):
            self._characters = characters_data.get('characters', [])
        elif isinstance(characters_data, list):
            self._characters = characters_data
        else:
            self._characters = []

        # Build name index for fast lookups
        self._name_index = {char['name']: char for char in self._characters}

    def get_by_name(self, character_name):
        """
        Get character by name.

        Args:
            character_name: Character name string

        Returns:
            Character dict or None if not found
        """
        return self._name_index.get(character_name)

    def get_by_faction_id(self, faction_id):
        """
        Get all characters linked to a faction.

        Args:
            faction_id: Faction ID string

        Returns:
            List of character dicts
        """
        return [char for char in self._characters
                if char.get('faction_id') == faction_id]

    def get_all(self):
        """
        Get all characters as a list.

        Returns:
            List of character dicts
        """
        return self._characters

    def to_dict(self):
        """
        Convert to dictionary format for JSON serialization.

        Returns:
            Dictionary with 'characters' key
        """
        return {"characters": self._characters}

    def update_metrics(self, character_name, relationship=0, influence=0, loyalty=0):
        """
        Update character metrics.

        Args:
            character_name: Character name
            relationship: Change to relationship metric
            influence: Change to influence metric
            loyalty: Change to loyalty metric

        Returns:
            True if updated, False if character not found
        """
        character = self.get_by_name(character_name)
        if not character:
            return False

        metrics = character.setdefault('metrics', {})

        if relationship != 0:
            current = metrics.get('relationship', 50)
            metrics['relationship'] = max(0, min(100, current + relationship))

        if influence != 0:
            current = metrics.get('influence', 50)
            metrics['influence'] = max(0, min(100, current + influence))

        if loyalty != 0:
            current = metrics.get('loyalty', 50)
            metrics['loyalty'] = max(0, min(100, current + loyalty))

        return True

    def add_memory(self, character_name, memory_text, turn_number):
        """
        Add memory to character history for context indexing.

        Args:
            character_name: Character name
            memory_text: Description of the memory/event
            turn_number: Current turn number for indexing

        Returns:
            True if added, False if character not found
        """
        character = self.get_by_name(character_name)
        if not character:
            return False

        history = character.setdefault('history', [])
        memory = f"Turn {turn_number}: {memory_text}"
        history.append(memory)

        # Keep last 10 memories to avoid JSON bloat
        if len(history) > 10:
            character['history'] = history[-10:]

        return True

    def __len__(self):
        """Return number of characters."""
        return len(self._characters)

    def __iter__(self):
        """Allow iteration over characters."""
        return iter(self._characters)



################################################################################
# FILE: old_codebase\engines\law_engine.py
# Size: 21400 bytes
################################################################################

"""
Law Engine - Manages permanent decrees and their propagation through history
Ensures major player decisions (laws, holy mandates, constitutional changes) persist and evolve realistically
"""

import json
import os
from typing import Dict, List, Any, Optional
from datetime import datetime


class LawEngine:
    """Handles permanent decrees, their enforcement, and historical evolution"""

    DECREE_TYPES = {
        'holy_law': 'Divine mandate backed by religious authority',
        'constitutional': 'Fundamental governance structure change',
        'cultural': 'Major cultural or social restructuring',
        'military': 'Permanent military doctrine or organization',
        'economic': 'Foundational economic policy or structure',
        'religious': 'Religious practice or structure (non-divine)',
    }

    ENFORCEMENT_LEVELS = ['absolute', 'strong', 'moderate', 'weakening', 'nominal', 'defunct']

    IMPORTANCE_LEVELS = ['civilization_defining', 'major', 'significant', 'minor']

    def __init__(self, game_state):
        """Initialize the law engine with current game state"""
        self.game_state = game_state
        self.civilization = game_state.civilization
        self.religion = game_state.religion
        self.culture = game_state.culture
        self.current_year = game_state.current_year

    def create_decree(self,
                     decree_type: str,
                     title: str,
                     declaration_text: str,
                     declared_by: str,
                     effects: Dict[str, Any],
                     importance: str = 'major') -> Dict[str, Any]:
        """
        Create a new permanent decree

        Args:
            decree_type: Type of decree (holy_law, constitutional, cultural, etc.)
            title: Short title of the decree
            declaration_text: Full text of the declaration
            declared_by: Name/title of the character who declared it
            effects: Dictionary of specific effects this decree has
            importance: How important this decree is (civilization_defining, major, significant, minor)

        Returns:
            The created decree object
        """
        if decree_type not in self.DECREE_TYPES:
            decree_type = 'cultural'  # Default fallback

        if importance not in self.IMPORTANCE_LEVELS:
            importance = 'major'

        # Generate unique ID
        decree_id = f"decree_{self.current_year}_{len(self.civilization.get('permanent_decrees', []))}"

        decree = {
            'id': decree_id,
            'type': decree_type,
            'title': title,
            'declared_year': self.current_year,
            'declared_by': declared_by,
            'declaration_text': declaration_text,
            'importance': importance,
            'enforcement_level': 'absolute',  # Start at maximum enforcement
            'effects': effects,
            'historical_impact': [
                {
                    'year': self.current_year,
                    'event': f"Decree declared by {declared_by}",
                    'enforcement_level': 'absolute'
                }
            ],
            'resistance_level': 0,  # 0-100 scale of societal resistance
            'support_level': 100,   # 0-100 scale of societal support
            'schisms_caused': [],
            'modified_years': []
        }

        return decree

    def add_decree_to_state(self, decree: Dict[str, Any]) -> str:
        """
        Add a decree to the civilization state and apply its immediate effects

        Returns:
            Narrative description of the decree's immediate impact
        """
        # Initialize permanent_decrees if it doesn't exist
        if 'permanent_decrees' not in self.civilization:
            self.civilization['permanent_decrees'] = []

        self.civilization['permanent_decrees'].append(decree)

        # Apply immediate effects
        narrative = self._apply_decree_effects(decree, is_initial=True)

        return narrative

    def _apply_decree_effects(self, decree: Dict[str, Any], is_initial: bool = False) -> str:
        """
        Apply a decree's effects to the current game state

        Args:
            decree: The decree to apply
            is_initial: Whether this is the initial declaration (True) or ongoing enforcement (False)

        Returns:
            Narrative describing the effects
        """
        effects = decree.get('effects', {})
        narratives = []

        # Social structure changes
        if 'social_structure' in effects:
            old_structure = self.civilization.get('social_structure', 'tribal')
            new_structure = effects['social_structure']
            self.civilization['social_structure'] = new_structure

            if is_initial:
                narratives.append(f"The social structure transforms from {old_structure} to {new_structure}")
            else:
                narratives.append(f"The {new_structure} system remains firmly in place")

        # Cultural values
        if 'cultural_values' in effects:
            current_values = self.culture.get('values', [])
            for value in effects['cultural_values']:
                if value not in current_values:
                    current_values.append(value)
                    if is_initial:
                        narratives.append(f"'{value}' becomes a core cultural value")
            self.culture['values'] = current_values

        # Taboos
        if 'taboos' in effects:
            current_taboos = self.culture.get('taboos', [])
            for taboo in effects['taboos']:
                if taboo not in current_taboos:
                    current_taboos.append(taboo)
                    if is_initial:
                        narratives.append(f"'{taboo}' is now forbidden by law")
            self.culture['taboos'] = current_taboos

        # Traditions
        if 'traditions' in effects:
            current_traditions = self.culture.get('traditions', [])
            for tradition in effects['traditions']:
                if tradition not in current_traditions:
                    current_traditions.append(tradition)
                    if is_initial:
                        narratives.append(f"'{tradition}' becomes an enforced tradition")
            self.culture['traditions'] = current_traditions

        # Military composition
        if 'military_composition' in effects:
            # This would affect military units, but we'll store it as metadata
            self.civilization['military_doctrine'] = effects['military_composition']
            if is_initial:
                narratives.append(f"Military organization changes to: {effects['military_composition']}")

        # Property rights
        if 'property_rights' in effects:
            self.civilization['property_system'] = effects['property_rights']
            if is_initial:
                narratives.append(f"Property rights restructured: {effects['property_rights']}")

        # Governance changes
        if 'governance_structure' in effects:
            old_gov = self.civilization.get('government_type', 'chiefdom')
            self.civilization['government_type'] = effects['governance_structure']
            if is_initial:
                narratives.append(f"Government transforms from {old_gov} to {effects['governance_structure']}")

        # Religious effects (for holy laws)
        if decree['type'] == 'holy_law' and 'religious_effects' in effects:
            self._apply_religious_effects(decree, effects['religious_effects'], is_initial)
            if is_initial:
                narratives.append(f"Religious doctrine permanently altered by divine mandate")

        if not narratives:
            narratives.append("The decree's influence permeates society")

        return ". ".join(narratives) + "."

    def _apply_religious_effects(self, decree: Dict[str, Any], religious_effects: Dict[str, Any], is_initial: bool):
        """Apply effects specific to religious decrees"""
        # Add to holy laws in religion
        if 'holy_laws' not in self.religion:
            self.religion['holy_laws'] = []

        holy_law = {
            'law': decree['title'],
            'divine_authority': religious_effects.get('divine_authority', self.religion.get('primary_deity', 'The Divine')),
            'declared_year': decree['declared_year'],
            'sacred_status': 'absolute' if decree['enforcement_level'] == 'absolute' else 'revered',
            'decree_id': decree['id']
        }

        # Check if already exists
        existing = next((hl for hl in self.religion['holy_laws'] if hl.get('decree_id') == decree['id']), None)
        if not existing:
            self.religion['holy_laws'].append(holy_law)

        # Add core tenets
        if 'core_tenets' in religious_effects:
            current_tenets = self.religion.get('core_tenets', [])
            for tenet in religious_effects['core_tenets']:
                if tenet not in current_tenets:
                    current_tenets.append(tenet)
            self.religion['core_tenets'] = current_tenets

        # Modify practices
        if 'practices' in religious_effects:
            current_practices = self.religion.get('practices', [])
            for practice in religious_effects['practices']:
                if practice not in current_practices:
                    current_practices.append(practice)
            self.religion['practices'] = current_practices

    def enforce_active_decrees(self) -> List[str]:
        """
        Enforce all active decrees, ensuring their effects are reflected in current state
        Returns list of enforcement narratives
        """
        decrees = self.civilization.get('permanent_decrees', [])
        if not decrees:
            return []

        narratives = []

        for decree in decrees:
            # Skip defunct decrees
            if decree.get('enforcement_level') == 'defunct':
                continue

            # Re-apply effects based on enforcement level
            if decree.get('enforcement_level') in ['absolute', 'strong', 'moderate']:
                # Full enforcement
                self._apply_decree_effects(decree, is_initial=False)
            elif decree.get('enforcement_level') == 'weakening':
                # Partial enforcement - might be fading
                narratives.append(f"The decree '{decree['title']}' is weakening but still influences society")
            elif decree.get('enforcement_level') == 'nominal':
                # Barely enforced - mostly cultural memory
                narratives.append(f"The ancient decree '{decree['title']}' exists only in tradition")

        return narratives

    def evolve_decree(self, decree: Dict[str, Any], years_passed: int) -> str:
        """
        Evolve a decree over time based on cultural fit and resistance

        Args:
            decree: The decree to evolve
            years_passed: How many years have passed since last evolution

        Returns:
            Narrative describing how the decree evolved
        """
        current_enforcement = decree.get('enforcement_level', 'absolute')
        resistance = decree.get('resistance_level', 0)
        support = decree.get('support_level', 100)

        # Calculate cultural fit based on decree effects vs current culture
        cultural_fit = self._calculate_cultural_fit(decree)

        # Determine evolution direction
        if cultural_fit > 70 and support > 70:
            # Decree strengthens
            if current_enforcement == 'moderate':
                decree['enforcement_level'] = 'strong'
                return f"The decree '{decree['title']}' has become deeply rooted in society, enforcement strengthening"
            elif current_enforcement == 'weakening':
                decree['enforcement_level'] = 'moderate'
                return f"The decree '{decree['title']}' sees renewed support and enforcement"
        elif cultural_fit < 30 or resistance > 70:
            # Decree weakens
            enforcement_progression = ['absolute', 'strong', 'moderate', 'weakening', 'nominal', 'defunct']
            current_index = enforcement_progression.index(current_enforcement)
            if current_index < len(enforcement_progression) - 1:
                new_enforcement = enforcement_progression[current_index + 1]
                decree['enforcement_level'] = new_enforcement

                if new_enforcement == 'defunct':
                    return f"The decree '{decree['title']}' has fallen completely out of practice, now defunct"
                elif new_enforcement == 'nominal':
                    return f"The decree '{decree['title']}' is barely enforced, existing only in name"
                else:
                    return f"The decree '{decree['title']}' faces growing resistance, enforcement weakening"

        # Stable - minor adjustments
        decree['resistance_level'] = max(0, min(100, resistance + (50 - cultural_fit) // 10))
        decree['support_level'] = max(0, min(100, support + (cultural_fit - 50) // 10))

        return f"The decree '{decree['title']}' remains {current_enforcement} in enforcement"

    def _calculate_cultural_fit(self, decree: Dict[str, Any]) -> int:
        """
        Calculate how well a decree fits current cultural values (0-100)
        Higher = better fit = more likely to persist
        """
        fit_score = 50  # Neutral baseline

        effects = decree.get('effects', {})

        # Check if decree's cultural values match current culture
        if 'cultural_values' in effects:
            current_values = self.culture.get('values', [])
            matching_values = sum(1 for v in effects['cultural_values'] if v in current_values)
            fit_score += matching_values * 10

        # Check if decree's taboos are still taboo
        if 'taboos' in effects:
            current_taboos = self.culture.get('taboos', [])
            matching_taboos = sum(1 for t in effects['taboos'] if t in current_taboos)
            fit_score += matching_taboos * 10

        # Holy laws have inherent staying power if religion is strong
        if decree['type'] == 'holy_law':
            religious_influence = self.religion.get('influence', 'moderate')
            if religious_influence == 'dominant':
                fit_score += 20
            elif religious_influence == 'significant':
                fit_score += 10
            elif religious_influence == 'waning':
                fit_score -= 20

        # Importance affects staying power
        importance = decree.get('importance', 'major')
        if importance == 'civilization_defining':
            fit_score += 15
        elif importance == 'major':
            fit_score += 10

        return max(0, min(100, fit_score))

    def generate_resistance_events(self, decree: Dict[str, Any]) -> Optional[str]:
        """
        Generate events showing resistance or support for a decree
        Returns None if no significant events, or a narrative string
        """
        resistance = decree.get('resistance_level', 0)
        support = decree.get('support_level', 100)
        enforcement = decree.get('enforcement_level', 'absolute')

        # High resistance + strong enforcement = conflict events
        if resistance > 60 and enforcement in ['absolute', 'strong']:
            events = [
                f"Underground movements form to resist the '{decree['title']}' decree",
                f"Open protests erupt against the enforcement of '{decree['title']}'",
                f"Factions splinter over disagreement with '{decree['title']}'",
                f"A rebellion is brewing among those opposed to '{decree['title']}'"
            ]
            import random
            return random.choice(events)

        # High support + weakening enforcement = calls for renewal
        if support > 70 and enforcement in ['weakening', 'nominal']:
            events = [
                f"Religious leaders call for renewed enforcement of '{decree['title']}'",
                f"Traditionalists demand the ancient decree '{decree['title']}' be upheld",
                f"A movement forms to restore the sacred law '{decree['title']}'"
            ]
            import random
            return random.choice(events)

        return None

    def get_active_decrees(self, min_enforcement: str = 'weakening') -> List[Dict[str, Any]]:
        """
        Get all decrees that are still actively enforced

        Args:
            min_enforcement: Minimum enforcement level to include

        Returns:
            List of active decree objects
        """
        enforcement_hierarchy = ['absolute', 'strong', 'moderate', 'weakening', 'nominal', 'defunct']
        min_index = enforcement_hierarchy.index(min_enforcement)

        decrees = self.civilization.get('permanent_decrees', [])
        active = []

        for decree in decrees:
            enforcement = decree.get('enforcement_level', 'absolute')
            if enforcement_hierarchy.index(enforcement) <= min_index:
                active.append(decree)

        return active

    def get_decree_summary(self, decree: Dict[str, Any]) -> str:
        """Generate a concise summary of a decree for AI prompts"""
        return (
            f"{decree['title']} ({decree['type']}, {decree['declared_year']}): "
            f"{decree['declaration_text'][:100]}... "
            f"[Enforcement: {decree['enforcement_level']}, "
            f"Support: {decree.get('support_level', 100)}%, "
            f"Resistance: {decree.get('resistance_level', 0)}%]"
        )

    def get_all_decrees_summary(self) -> str:
        """Get a formatted summary of all active decrees for AI context"""
        active_decrees = self.get_active_decrees(min_enforcement='nominal')

        if not active_decrees:
            return "No permanent decrees currently in effect."

        summary_lines = ["=== PERMANENT DECREES IN EFFECT ==="]

        for decree in active_decrees:
            summary_lines.append(f"\n‚Ä¢ {self.get_decree_summary(decree)}")

        return "\n".join(summary_lines)

    def process_timeskip(self, years_passed: int) -> Dict[str, Any]:
        """
        Process all decrees through a timeskip, evolving them realistically

        Args:
            years_passed: How many years have passed

        Returns:
            Dictionary containing:
                - evolved_decrees: List of how each decree changed
                - major_events: List of significant events caused by decrees
                - defunct_decrees: List of decrees that became defunct
                - new_schisms: List of religious schisms caused
        """
        decrees = self.civilization.get('permanent_decrees', [])

        result = {
            'evolved_decrees': [],
            'major_events': [],
            'defunct_decrees': [],
            'new_schisms': [],
            'decree_narratives': []
        }

        for decree in decrees:
            # Skip already defunct
            if decree.get('enforcement_level') == 'defunct':
                continue

            # Evolve the decree
            evolution_narrative = self.evolve_decree(decree, years_passed)
            result['evolved_decrees'].append({
                'decree': decree['title'],
                'narrative': evolution_narrative
            })

            # Check if it became defunct
            if decree.get('enforcement_level') == 'defunct':
                result['defunct_decrees'].append(decree['title'])

            # Generate resistance/support events
            event = self.generate_resistance_events(decree)
            if event:
                result['major_events'].append(event)

            # Check for schisms (especially for holy laws)
            if decree['type'] == 'holy_law' and decree.get('resistance_level', 0) > 50:
                schism_name = f"Reformist opposition to {decree['title']}"
                if schism_name not in decree.get('schisms_caused', []):
                    decree.setdefault('schisms_caused', []).append(schism_name)
                    result['new_schisms'].append(schism_name)

            # Add to historical impact
            decree.setdefault('historical_impact', []).append({
                'year': self.current_year,
                'event': evolution_narrative,
                'enforcement_level': decree.get('enforcement_level')
            })

            # Create summary for timeskip narrative
            if decree.get('enforcement_level') in ['absolute', 'strong', 'moderate']:
                result['decree_narratives'].append(
                    f"The {decree['type']} '{decree['title']}' (declared {decree['declared_year']}) "
                    f"continues to shape society with {decree['enforcement_level']} enforcement"
                )

        return result



################################################################################
# FILE: old_codebase\engines\leader_engine.py
# Size: 19655 bytes
################################################################################

# engines/leader_engine.py
"""
Leader mechanics: traits, aging, succession, legacy bonuses.
Adds personality and strategic depth to leadership.
"""

# BALANCE_OVERHAUL: Comprehensive trait definitions with real trade-offs
# Every trait now has penalties as well as bonuses for strategic depth
TRAIT_EFFECTS = {
    # Combat/Military Traits - powerful but socially/economically costly
    'Brave': {
        'description': 'Fearless in battle, inspires troops',
        'bonuses': {'military_reputation': 5, 'combat_success': 0.15},
        'penalties': {'diplomatic_reputation': -5, 'wealth_generation': -0.05},
        'event_tags': ['military', 'warfare', 'defense']
    },
    'Warrior': {
        'description': 'Skilled in combat and strategy',
        'bonuses': {'military_reputation': 10, 'combat_success': 0.20},
        'penalties': {'wealth_generation': -0.15, 'economic_reputation': -10},
        'event_tags': ['military', 'warfare', 'conquest']
    },
    'Ruthless': {
        'description': 'Willing to do whatever it takes',
        'bonuses': {'military_reputation': 15, 'harsh_success': 0.20},
        'penalties': {'diplomatic_reputation': -15, 'happiness': -10, 'unrest_chance': 0.20},
        'event_tags': ['cruelty', 'pragmatism', 'conquest']
    },

    # Wisdom/Intelligence Traits - great for knowledge, poor for practical matters
    'Wise': {
        'description': 'Deep understanding and insight',
        'bonuses': {'investigation_depth': 1, 'advisor_quality': 0.15},
        'penalties': {'military_reputation': -5},
        'event_tags': ['wisdom', 'learning', 'teaching']
    },
    'Scholar': {
        'description': 'Devoted to knowledge and learning',
        'bonuses': {'tech_progress': 0.15, 'discovery_chance': 0.15},
        'penalties': {'practical_resource_generation': -0.15, 'military_reputation': -10},
        'event_tags': ['technology', 'learning', 'discovery']
    },

    # Spiritual/Religious Traits - powerful for faith, antagonizes secular factions
    'Pious': {
        'description': 'Deeply religious and faithful',
        'bonuses': {'religious_reputation': 15, 'priest_faction_approval': 10},
        'penalties': {'merchant_faction_approval': -20, 'tech_progress': -0.10},
        'event_tags': ['religion', 'faith', 'ritual']
    },
    'Mystic': {
        'description': 'Connected to spiritual forces',
        'bonuses': {'religious_reputation': 10, 'ritual_power': 0.20},
        'penalties': {'diplomatic_reputation': -10, 'economic_reputation': -5},
        'event_tags': ['religion', 'magic', 'spirits']
    },
    'Visionary': {
        'description': 'Sees beyond the present',
        'bonuses': {'cultural_progress': 0.10, 'prophecy_bonus': 0.15},
        'penalties': {},
        'event_tags': ['culture', 'vision', 'prophecy']
    },

    # Social/Diplomatic Traits - excellent for peace, weak in crisis
    'Charismatic': {
        'description': 'Naturally inspiring and persuasive',
        'bonuses': {'diplomatic_reputation': 10, 'alliance_strength': 0.15},
        'penalties': {'military_effectiveness': -0.10},
        'event_tags': ['diplomacy', 'persuasion', 'leadership']
    },
    'Diplomatic': {
        'description': 'Skilled negotiator and peacemaker',
        'bonuses': {'diplomatic_reputation': 15, 'peace_bonus': 0.20},
        'penalties': {'military_reputation': -10, 'warrior_faction_approval': -15},
        'event_tags': ['diplomacy', 'peace', 'negotiation']
    },
    'Just': {
        'description': 'Fair and honorable in all things',
        'bonuses': {'diplomatic_reputation': 6, 'promise_weight': 0.15},
        'penalties': {},
        'event_tags': ['justice', 'honor', 'law']
    },

    # Economic Traits - wealthy but politically divisive
    'Prosperous': {
        'description': 'Brings wealth and abundance',
        'bonuses': {'economic_reputation': 10, 'wealth_generation': 0.15},
        'penalties': {'warrior_faction_approval': -10, 'military_effectiveness': -0.10},
        'event_tags': ['economy', 'trade', 'wealth']
    },
    'Mercantile': {
        'description': 'Skilled in trade and commerce',
        'bonuses': {'economic_reputation': 15, 'trade_bonus': 0.20, 'merchant_faction_approval': 15},
        'penalties': {'warrior_faction_approval': -20, 'military_effectiveness': -0.15},
        'event_tags': ['trade', 'commerce', 'market']
    },

    # Negative/Complex Traits
    'Tactical': {
        'description': 'Master strategist and planner',
        'bonuses': {'military_reputation': 6, 'defensive_bonus': 0.15},
        'penalties': {},
        'event_tags': ['military', 'strategy', 'planning']
    },
    'Cunning': {
        'description': 'Clever and resourceful',
        'bonuses': {'diplomatic_reputation': 5, 'negotiation_bonus': 0.15},
        'penalties': {},
        'event_tags': ['diplomacy', 'intrigue', 'negotiation']
    },
    'Ambitious': {
        'description': 'Driven to achieve greatness',
        'bonuses': {'all_progress': 0.10, 'risk_events': 0.15},
        'penalties': {},
        'event_tags': ['ambition', 'risk', 'growth']
    },
    'Paranoid': {
        'description': 'Distrustful but vigilant',
        'bonuses': {'defensive_bonus': 0.20},
        'penalties': {'diplomatic_reputation': -5},
        'event_tags': ['suspicion', 'defense', 'isolation']
    },

    # Age-Related Traits (gained through aging)
    'Ancient': {
        'description': 'Lived far beyond normal years',
        'bonuses': {'wisdom_bonus': 0.15},
        'penalties': {'health_penalty': 0.30, 'effectiveness': -0.20},
        'event_tags': ['wisdom', 'age', 'legacy']
    },
    'Experienced': {
        'description': 'Seasoned by years of rule',
        'bonuses': {'all_reputation': 5, 'decision_quality': 0.10},
        'penalties': {},
        'event_tags': ['experience', 'wisdom', 'leadership']
    }
}

def get_trait_bonus(leader, bonus_type):
    """
    BALANCE_OVERHAUL: Calculate total bonus from all leader traits for a specific type.
    Now handles both bonuses and penalties.

    Args:
        leader: Leader dict with 'traits' list
        bonus_type: Type of bonus (e.g., 'military_reputation', 'combat_success')

    Returns:
        Total bonus value (additive, can be negative)
    """
    traits = leader.get('traits', [])
    total_bonus = 0

    for trait in traits:
        trait_data = TRAIT_EFFECTS.get(trait, {})

        # Add bonuses
        bonuses = trait_data.get('bonuses', {})
        if bonus_type in bonuses:
            total_bonus += bonuses[bonus_type]

        # Apply penalties (penalties are stored as negative values or subtracted)
        penalties = trait_data.get('penalties', {})
        if bonus_type in penalties:
            penalty_value = penalties[bonus_type]
            # If penalty is stored as positive (e.g., 15), make it negative
            if penalty_value > 0:
                total_bonus -= penalty_value
            else:
                # If penalty is already negative (e.g., -15), add it directly
                total_bonus += penalty_value

    return total_bonus

def get_leader_event_tags(leader):
    """
    Get all event tags from leader traits.
    These can be used to weight event generation toward leader's strengths.
    """
    traits = leader.get('traits', [])
    tags = []

    for trait in traits:
        trait_data = TRAIT_EFFECTS.get(trait, {})
        tags.extend(trait_data.get('event_tags', []))

    return list(set(tags))  # Remove duplicates

def apply_aging_effects(game_state):
    """
    Apply age-based trait modifications and health effects.
    As leaders age, they gain wisdom but lose health.
    """
    leader = game_state.civilization['leader']
    age = leader.get('age', 0)
    life_exp = leader.get('life_expectancy', 60)
    traits = leader.get('traits', [])

    changes = []

    # Age milestones
    age_percent = (age / life_exp) * 100

    # Young leader (< 40% of life expectancy) - no changes

    # Middle age (40-70% of life expectancy) - gain Experienced
    if 40 <= age_percent < 70 and 'Experienced' not in traits and 'Ancient' not in traits:
        traits.append('Experienced')
        changes.append("gained 'Experienced' trait")

    # Old age (70-90% of life expectancy) - no new traits, just slower

    # Ancient age (> 90% of life expectancy) - gain Ancient, lose some traits
    if age_percent > 90 and 'Ancient' not in traits:
        # Remove Experienced if present
        if 'Experienced' in traits:
            traits.remove('Experienced')

        # Remove physically demanding traits
        physical_traits = ['Warrior', 'Brave']
        for trait in physical_traits:
            if trait in traits:
                traits.remove(trait)
                changes.append(f"lost '{trait}' trait (too old)")

        # Add Ancient
        traits.append('Ancient')
        changes.append("gained 'Ancient' trait")

    # Update traits
    leader['traits'] = traits[:5]  # Max 5 traits

    return changes

def calculate_leader_effectiveness(leader, game_state=None):
    """
    Calculate overall leader effectiveness with crisis momentum penalty.
    This is a wrapper that applies crisis penalties if game_state is provided.
    """
    # Calculate base effectiveness using age and traits
    age = leader.get('age', 0)
    life_exp = leader.get('life_expectancy', 60)
    traits = leader.get('traits', [])

    # Base effectiveness: 1.0
    effectiveness = 1.0

    # BALANCE_OVERHAUL: Aggressive age-based decline with event triggers
    age_percent = (age / life_exp) * 100
    if age_percent < 30:
        # Youth: inexperienced
        effectiveness *= 0.90
    elif 30 <= age_percent < 60:
        # Prime: peak performance
        effectiveness *= 1.10
    elif 60 <= age_percent < 80:
        # Aging: slight decline
        effectiveness *= 1.05
        # 10% chance of health concern events (implement in event_engine.py)
    elif 80 <= age_percent < 90:
        # Elderly: noticeable decline
        effectiveness *= 0.95
        # 25% chance of "Questioning Authority" events
    elif 90 <= age_percent < 100:
        # Ancient: severe decline
        effectiveness *= 0.80
        # 40% chance of succession crisis events
    else:
        # Death's door: imminent death
        effectiveness *= 0.70
        # 50% chance of sudden death each turn

    # Trait bonuses
    if 'Wise' in traits or 'Scholar' in traits:
        effectiveness *= 1.05
    if 'Charismatic' in traits:
        effectiveness *= 1.05
    if 'Ancient' in traits:
        effectiveness *= 0.9  # Health penalty

    # BALANCE_OVERHAUL: Apply crisis momentum penalty if game_state provided
    if game_state and hasattr(game_state, 'crisis_momentum') and game_state.crisis_momentum > 0:
        momentum_penalty = min(0.20, game_state.crisis_momentum * 0.02)  # Max -20%
        effectiveness *= (1.0 - momentum_penalty)

    return max(0.5, min(1.5, effectiveness))  # Clamp between 0.5 and 1.5

def generate_successor_candidates(game_state):
    """
    Generate 3 potential successors with different trait combinations.
    Player will choose during succession event.
    """
    import random

    current_leader = game_state.civilization['leader']
    civ_name = game_state.civilization['meta']['name']

    # Get civilization's dominant characteristics for successor generation
    cultural_values = game_state.culture.get('values', [])[:3]

    candidates = []

    # Candidate archetypes
    archetypes = [
        {
            'type': 'Military',
            'traits': ['Warrior', 'Brave', 'Tactical'],
            'age_range': (25, 40),
            'description': 'A proven military leader'
        },
        {
            'type': 'Diplomatic',
            'traits': ['Charismatic', 'Diplomatic', 'Just'],
            'age_range': (30, 50),
            'description': 'A skilled negotiator and peacemaker'
        },
        {
            'type': 'Spiritual',
            'traits': ['Pious', 'Visionary', 'Mystic'],
            'age_range': (28, 45),
            'description': 'A devout religious leader'
        },
        {
            'type': 'Scholar',
            'traits': ['Scholar', 'Wise', 'Cunning'],
            'age_range': (32, 48),
            'description': 'A brilliant mind and strategist'
        },
        {
            'type': 'Merchant',
            'traits': ['Mercantile', 'Prosperous', 'Charismatic'],
            'age_range': (30, 45),
            'description': 'A wealthy trader and economist'
        }
    ]

    # Select 3 random archetypes
    selected = random.sample(archetypes, 3)

    # Name pools (simple for now)
    name_pool = [
        'Aldric', 'Beatrix', 'Cedric', 'Diana', 'Elara', 'Finn', 'Gaia', 'Hector',
        'Iris', 'Jareth', 'Kira', 'Lorian', 'Maya', 'Nero', 'Orin', 'Petra',
        'Quinn', 'Raven', 'Silas', 'Thora', 'Uma', 'Victor', 'Wren', 'Xander',
        'Yara', 'Zephyr', 'Aria', 'Bram', 'Cora', 'Dax'
    ]

    for archetype in selected:
        # Generate random name
        name = random.choice([n for n in name_pool if n != current_leader.get('name')])

        # Random age in range
        age = random.randint(*archetype['age_range'])

        # Select 2-3 traits from archetype
        trait_count = random.randint(2, 3)
        traits = random.sample(archetype['traits'], trait_count)

        candidates.append({
            'name': name,
            'age': age,
            'type': archetype['type'],
            'traits': traits,
            'description': archetype['description']
        })

    return candidates

def trigger_succession_crisis(game_state):
    """
    BALANCE_OVERHAUL: Generate high-stakes succession event with faction-backed candidates.
    This is a political crisis, not a menu choice.
    """
    import random

    print("=" * 60)
    print("SUCCESSION CRISIS: THE THRONE LIES EMPTY")
    print("=" * 60)

    # Generate 3-5 candidates backed by different factions
    candidates = []

    # Get factions to back candidates
    factions = game_state.faction_manager.get_all() if hasattr(game_state, 'faction_manager') else []

    # Candidate 1: Merchant-backed (economic focus)
    merchant_faction = next((f for f in factions if 'merchant' in f.get('id', '').lower()), None)
    candidates.append({
        'name': random.choice(['Aldric the Wealthy', 'Beatrix the Prosperous', 'Cedric the Trader']),
        'archetype': 'Merchant',
        'traits': ['Mercantile', 'Charismatic'],
        'backing_faction': merchant_faction.get('name') if merchant_faction else 'Merchant Guild',
        'backing_faction_id': merchant_faction.get('id') if merchant_faction else 'merchants',
        'approval_changes': {
            'merchant': +30,
            'warrior': -35,
            'priest': -20
        },
        'demands': 'Reduce tariffs and expand trade routes within 5 turns'
    })

    # Candidate 2: Warrior-backed (military focus)
    warrior_faction = next((f for f in factions if 'warrior' in f.get('id', '').lower() or 'military' in f.get('id', '').lower()), None)
    candidates.append({
        'name': random.choice(['Diana the Bold', 'Hector the Conqueror', 'Thora the Fierce']),
        'archetype': 'Warrior',
        'traits': ['Warrior', 'Brave'],
        'backing_faction': warrior_faction.get('name') if warrior_faction else 'Warrior Caste',
        'backing_faction_id': warrior_faction.get('id') if warrior_faction else 'warriors',
        'approval_changes': {
            'merchant': -40,
            'warrior': +35,
            'priest': -15
        },
        'demands': 'Increase military funding by 30% within 5 turns'
    })

    # Candidate 3: Priest-backed (spiritual focus)
    priest_faction = next((f for f in factions if 'priest' in f.get('id', '').lower() or 'religious' in f.get('id', '').lower()), None)
    candidates.append({
        'name': random.choice(['Elara the Devout', 'Silas the Blessed', 'Maya the Prophet']),
        'archetype': 'Priest',
        'traits': ['Pious', 'Visionary'],
        'backing_faction': priest_faction.get('name') if priest_faction else 'Priest Order',
        'backing_faction_id': priest_faction.get('id') if priest_faction else 'priests',
        'approval_changes': {
            'merchant': -25,
            'warrior': -20,
            'priest': +30
        },
        'demands': 'Fund temple construction and religious festivals within 5 turns'
    })

    # Candidate 4: People's candidate (if happiness low)
    if game_state.population_happiness < 50:
        candidates.append({
            'name': random.choice(['Finn the Common', 'Kira the Voice', 'Orin the Just']),
            'archetype': 'Populist',
            'traits': ['Just', 'Charismatic'],
            'backing_faction': 'The Common People',
            'backing_faction_id': 'people',
            'approval_changes': {
                'merchant': -30,
                'warrior': -30,
                'priest': -30
            },
            'demands': 'Increase happiness by 20 points within 5 turns or face riots',
            'special': 'happiness_boost'  # +20 happiness immediately if chosen
        })

    return {
        'event_type': 'succession_crisis',
        'candidates': candidates,
        'transition_crisis_duration': 10,  # 10 turns of instability
        'rival_claimant_chance': 0.40  # 40% chance of coup attempt from losing faction
    }

def apply_legacy_bonus(game_state, previous_leader):
    """
    Apply legacy bonuses from previous leader to civilization.
    Well-ruled civilizations carry forward benefits.
    """
    years_ruled = previous_leader.get('years_ruled', 0)
    traits = previous_leader.get('traits', [])

    legacy = {
        'bonuses_applied': [],
        'narrative': ''
    }

    # Long reign bonus
    if years_ruled > 50:
        bonus_rep = min(years_ruled // 10, 20)  # Max +20
        for rep_type in ['diplomatic', 'military', 'religious', 'economic']:
            current = game_state.civilization.get('consequences', {}).get('reputation', {}).get(rep_type, 50)
            game_state.civilization['consequences']['reputation'][rep_type] = min(100, current + bonus_rep)

        legacy['bonuses_applied'].append(f"+{bonus_rep} to all reputations (long reign)")
        legacy['narrative'] = f"The long and stable {years_ruled}-year reign leaves a lasting positive legacy."

    # Trait-specific legacies
    if 'Wise' in traits or 'Scholar' in traits:
        # Technology boost
        legacy['bonuses_applied'].append("Cultural wisdom preserved")
        legacy['narrative'] += " The leader's wisdom is preserved in the teachings of the next generation."

    if 'Warrior' in traits or 'Brave' in traits:
        # Military tradition
        legacy['bonuses_applied'].append("Military tradition strengthened")
        legacy['narrative'] += " A martial legacy inspires future warriors."

    if 'Pious' in traits or 'Visionary' in traits:
        # Religious influence
        legacy['bonuses_applied'].append("Spiritual foundation deepened")
        legacy['narrative'] += " The leader's faith becomes a cornerstone of society."

    return legacy



################################################################################
# FILE: old_codebase\engines\prompt_loader.py
# Size: 2194 bytes
################################################################################

# engines/prompt_loader.py
"""
Prompt Loader Utility

Centralized system for loading AI prompts from external text files.
Separates prompt content from application logic for easier maintenance.
"""

import os
from pathlib import Path

# Cache for loaded prompts (avoids repeated file I/O)
_prompt_cache = {}


def load_prompt(prompt_path, use_cache=True):
    """
    Load a prompt from the /prompts directory.

    Args:
        prompt_path: Relative path within /prompts (e.g., 'events/generate_event')
        use_cache: Whether to use the in-memory cache (default: True)

    Returns:
        String containing the prompt template with {variables} for .format()

    Example:
        prompt = load_prompt('events/generate_event')
        filled = prompt.format(civ_name="Rome", leader_name="Caesar")
    """
    # Check cache first
    if use_cache and prompt_path in _prompt_cache:
        return _prompt_cache[prompt_path]

    # Construct full path
    base_dir = Path(__file__).parent.parent  # Go up to civilization_game/
    prompt_file = base_dir / 'prompts' / f'{prompt_path}.txt'

    try:
        with open(prompt_file, 'r', encoding='utf-8') as f:
            content = f.read()

        # Cache the loaded prompt
        if use_cache:
            _prompt_cache[prompt_path] = content

        return content

    except FileNotFoundError:
        error_msg = (
            f"‚ö†Ô∏è PROMPT FILE NOT FOUND: {prompt_file}\n"
            f"Expected location: prompts/{prompt_path}.txt\n"
            f"This is a critical error - the prompt file is missing."
        )
        print(error_msg)
        raise FileNotFoundError(error_msg)

    except Exception as e:
        error_msg = f"‚ö†Ô∏è ERROR LOADING PROMPT '{prompt_path}': {e}"
        print(error_msg)
        raise


def clear_cache():
    """Clear the prompt cache. Useful for reloading prompts during development."""
    global _prompt_cache
    _prompt_cache = {}
    print("‚úì Prompt cache cleared")


def get_cached_prompts():
    """Return list of currently cached prompt paths. Useful for debugging."""
    return list(_prompt_cache.keys())



################################################################################
# FILE: old_codebase\engines\resource_engine.py
# Size: 13044 bytes
################################################################################

# engines/resource_engine.py
"""
Resource management and consumption mechanics.
Handles food/wealth depletion, crisis detection, and resource constraints.
"""

def calculate_consumption(game_state):
    """
    Calculate per-turn resource consumption based on population and infrastructure.

    BALANCE CHANGES (2025-01):
    - Increased base food consumption from pop/10 to pop/4 (2.5x increase)
    - Restored harsh stone age inefficiency (1.3x -> 2.0x)
    - Added infrastructure scaling to food consumption (+0.5% per building)

    Returns dict with consumption rates.
    """
    population = game_state.civilization.get('population', 0)
    era = game_state.civilization.get('meta', {}).get('era', 'stone_age')

    # Base food consumption: 1 food per 4 people (was 1 per 10)
    base_food_consumption = population // 4  # CHANGED: 2.5x increase

    # Era affects efficiency (better eras consume less per capita due to tech)
    # Stone age is harsh subsistence living, players should want to advance
    era_efficiency = {
        'stone_age': 2.0,      # CHANGED: Restored harsh inefficiency (was 1.8)
        'bronze_age': 1.7,     # CHANGED: Still inefficient (was 1.5)
        'iron_age': 1.4,       # CHANGED: Improving (was 1.3)
        'classical': 1.2,      # CHANGED: Getting better (was 1.1)
        'medieval': 1.0,       # CHANGED: Efficient (was 1.0)
        'renaissance': 0.9,    # CHANGED: Advanced techniques (was 0.9)
        'industrial': 0.8,     # CHANGED: Mechanization (was 0.8)
        'modern': 0.7         # CHANGED: High-tech (was 0.7)
    }

    efficiency_multiplier = era_efficiency.get(era, 1.0)

    # Infrastructure scaling: more buildings = larger urban population = more consumption
    infrastructure_count = len(game_state.technology.get('infrastructure', []))
    infrastructure_scaling = 1 + (infrastructure_count * 0.005)  # +0.5% per building

    food_consumption = int(base_food_consumption * efficiency_multiplier * infrastructure_scaling)

    # Wealth consumption from infrastructure maintenance
    # BALANCE CHANGE: Different buildings have different costs (Fix #7)
    from engines.bonus_definitions import BUILDING_BONUSES

    total_base_maintenance = 0
    infrastructure_count = 0

    # Calculate maintenance from modern building system
    if hasattr(game_state, 'buildings'):
        constructed = game_state.buildings.get('constructed_buildings', [])
        infrastructure_count += len(constructed)

        for building in constructed:
            building_id = building.get('id')
            building_def = BUILDING_BONUSES.get(building_id, {})
            total_base_maintenance += building_def.get('maintenance_cost', 10)

    # Legacy infrastructure support (backward compatibility)
    legacy_infrastructure = game_state.technology.get('infrastructure', [])
    infrastructure_count += len(legacy_infrastructure)
    for building_name in legacy_infrastructure:
        building_def = BUILDING_BONUSES.get(building_name, {})
        total_base_maintenance += building_def.get('maintenance_cost', 10)

    if infrastructure_count == 0:
        wealth_consumption = 0
    else:
        # Apply exponential scaling (Fix #3)
        scaling_factor = 1 + (infrastructure_count * 0.05)  # +5% per building
        wealth_consumption = int(total_base_maintenance * scaling_factor)

    return {
        'food': food_consumption,
        'wealth': wealth_consumption
    }

def apply_consumption(game_state):
    """
    Apply resource consumption and return status.
    Returns dict with consumption details and warnings.
    """
    consumption = calculate_consumption(game_state)

    current_food = game_state.civilization['resources']['food']
    current_wealth = game_state.civilization['resources']['wealth']

    # Apply consumption
    new_food = current_food - consumption['food']
    new_wealth = current_wealth - consumption['wealth']

    game_state.civilization['resources']['food'] = max(0, new_food)
    game_state.civilization['resources']['wealth'] = max(0, new_wealth)

    # Detect crisis conditions
    status = {
        'food_consumed': consumption['food'],
        'wealth_consumed': consumption['wealth'],
        'food_remaining': game_state.civilization['resources']['food'],
        'wealth_remaining': game_state.civilization['resources']['wealth'],
        'warnings': []
    }

    # Food crisis levels
    population = game_state.civilization['population']
    food_per_capita = game_state.civilization['resources']['food'] / max(population, 1)

    if new_food < 0:
        status['warnings'].append('FAMINE_CRITICAL')
        # Starvation causes population loss
        starvation_deaths = abs(new_food) * 5  # 5 deaths per missing food unit
        game_state.civilization['population'] = max(50, population - starvation_deaths)
        status['starvation_deaths'] = starvation_deaths
    elif food_per_capita < 0.5:
        status['warnings'].append('FAMINE_WARNING')
    elif food_per_capita < 1.0:
        status['warnings'].append('FOOD_LOW')

    # Wealth crisis
    if new_wealth < 0:
        status['warnings'].append('BANKRUPTCY')
        # Bankruptcy causes infrastructure decay
        decay_count = min(len(game_state.technology.get('infrastructure', [])), 2)
        if decay_count > 0:
            decayed = game_state.technology['infrastructure'][-decay_count:]
            game_state.technology['infrastructure'] = game_state.technology['infrastructure'][:-decay_count]
            status['infrastructure_lost'] = decayed
    elif new_wealth < 100:
        status['warnings'].append('WEALTH_LOW')

    # BALANCE_OVERHAUL: Food stockpile decay (spoilage, pests, waste)
    # Prevents infinite stockpile turtling and encourages active resource management
    current_food = game_state.civilization['resources']['food']
    if current_food > 0:
        if current_food > 500:
            # Excessive stockpile decays faster (10% per turn)
            decay_amount = int(current_food * 0.10)
            game_state.civilization['resources']['food'] = max(0, current_food - decay_amount)
            status['food_decay'] = decay_amount
        else:
            # Normal decay (5% per turn)
            decay_amount = int(current_food * 0.05)
            game_state.civilization['resources']['food'] = max(0, current_food - decay_amount)
            status['food_decay'] = decay_amount

    return status

def calculate_resource_happiness_impact(game_state):
    """
    Calculate happiness change based on resource scarcity.

    Low food/wealth automatically reduces happiness, creating feedback loop:
    Scarcity ‚Üí Unhappiness ‚Üí Lower productivity (Fix #2) ‚Üí Worse scarcity

    This is applied automatically each turn after consumption.

    Returns: happiness delta (positive or negative integer)
    """
    happiness_change = 0
    population = game_state.civilization.get('population', 0)
    food = game_state.civilization['resources']['food']
    wealth = game_state.civilization['resources']['wealth']

    # Food scarcity penalties (scaled by severity)
    food_per_capita = food / max(population, 1)
    if food_per_capita < 0.3:
        happiness_change -= 20  # Starvation: massive penalty
    elif food_per_capita < 0.6:
        happiness_change -= 10  # Hunger: major penalty
    elif food_per_capita < 1.0:
        happiness_change -= 5   # Food insecurity: minor penalty

    # Wealth scarcity penalties (can't pay workers, maintain services)
    if wealth < 50:
        happiness_change -= 15  # Bankrupt: major penalty
    elif wealth < 200:
        happiness_change -= 8   # Poor: moderate penalty
    elif wealth < 500:
        happiness_change -= 3   # Tight: minor penalty

    # Abundance bonuses (prosperity breeds contentment)
    if food_per_capita > 5.0 and wealth > 2000:
        happiness_change += 5   # Prosperous: bonus

    return happiness_change

def check_resource_constraints(game_state, required_resources):
    """
    Check if civilization has required resources for an action.

    Args:
        game_state: Current game state
        required_resources: dict like {'food': 500, 'wealth': 200}

    Returns:
        (bool, list): (can_afford, list_of_missing_resources)
    """
    missing = []

    for resource, amount in required_resources.items():
        current = game_state.civilization['resources'].get(resource, 0)
        if current < amount:
            missing.append(f"{resource} (need {amount}, have {current})")

    return len(missing) == 0, missing

def generate_resource_production(game_state):
    """
    Calculate passive resource generation based on civ state.
    This represents natural growth between events.
    """
    population = game_state.civilization['population']
    era = game_state.civilization.get('meta', {}).get('era', 'stone_age')

    # Food production from population (farmers)
    # Stone age is subsistence society - higher farmer percentage
    farmer_percentage = {
        'stone_age': 0.45,      # 45% farmers (subsistence)
        'bronze_age': 0.40,     # 40% farmers
        'iron_age': 0.35,       # 35% farmers
        'classical': 0.30,      # 30% farmers
        'medieval': 0.30,
        'renaissance': 0.25,
        'industrial': 0.20,
        'modern': 0.15
    }
    farmers = int(population * farmer_percentage.get(era, 0.3))

    # Era affects productivity (rebalanced for stone age)
    era_productivity = {
        'stone_age': 1.5,       # Increased from 1 to 1.5 for survivability
        'bronze_age': 2,
        'iron_age': 3,
        'classical': 4,
        'medieval': 5,
        'renaissance': 7,
        'industrial': 10,
        'modern': 15
    }

    food_production = int(farmers * era_productivity.get(era, 1))

    # Wealth production from trade/economy (remaining population)
    trader_percentage = {
        'stone_age': 0.25,      # Increased from 0.20 for better wealth generation
        'bronze_age': 0.25,
        'iron_age': 0.30,
        'classical': 0.35,
        'medieval': 0.35,
        'renaissance': 0.40,
        'industrial': 0.45,
        'modern': 0.50
    }
    traders = int(population * trader_percentage.get(era, 0.2))
    wealth_production = traders * era_productivity.get(era, 1) // 2

    return {
        'food': food_production,
        'wealth': wealth_production
    }

def apply_passive_generation(game_state):
    """Apply passive resource generation with leader effectiveness bonus."""
    production = generate_resource_production(game_state)

    # Apply leader effectiveness multiplier
    from engines.leader_engine import calculate_leader_effectiveness

    effectiveness = calculate_leader_effectiveness(game_state.civilization.get('leader', {}))

    # BALANCE_OVERHAUL: Apply happiness productivity penalty
    # Low happiness mechanically hurts economy, not just narrative flavor
    # Updated thresholds and multipliers (2025-01 balance changes)
    happiness = game_state.population_happiness
    if happiness >= 80:
        happiness_multiplier = 1.15  # Thriving: +15% productivity
    elif happiness >= 60:
        happiness_multiplier = 1.0   # Content: normal productivity
    elif happiness >= 40:
        happiness_multiplier = 0.85  # Discontent: -15% productivity
    elif happiness >= 20:
        happiness_multiplier = 0.65  # Unrest: -35% productivity
    else:
        happiness_multiplier = 0.5   # Rebellion: -50% productivity

    effectiveness = effectiveness * happiness_multiplier

    # Apply bonus to production
    final_food = int(production['food'] * effectiveness)
    final_wealth = int(production['wealth'] * effectiveness)

    # BALANCE_OVERHAUL: Apply faction approval bonuses/penalties
    if hasattr(game_state, 'faction_manager'):
        faction_bonuses = game_state.faction_manager.get_faction_bonuses(game_state)
        final_wealth = int(final_wealth * faction_bonuses['wealth_multiplier'])

    # BONUS_ENGINE_INTEGRATION: Add bonuses from characters, buildings, etc.
    from engines.bonus_engine import BonusEngine
    from engines.bonus_definitions import BonusType

    bonus_engine = BonusEngine()
    food_bonuses = bonus_engine.calculate_bonuses(game_state, BonusType.FOOD_PER_TURN)
    wealth_bonuses = bonus_engine.calculate_bonuses(game_state, BonusType.WEALTH_PER_TURN)

    final_food += food_bonuses['total']
    final_wealth += wealth_bonuses['total']

    game_state.civilization['resources']['food'] += final_food
    game_state.civilization['resources']['wealth'] += final_wealth

    return {
        'food': final_food,
        'wealth': final_wealth,
        'base_food': production['food'],
        'base_wealth': production['wealth'],
        'effectiveness': effectiveness
    }



################################################################################
# FILE: old_codebase\engines\state_updater.py
# Size: 15836 bytes
################################################################################

# engines/state_updater.py
"""
State Updater Module

This module handles applying updates to the game state, including
both regular turn updates and world turn updates from NPCs and factions.

Refactored from event_engine.py for better maintainability and separation of concerns.
"""

import re
from engines.state_validator import validate_updates

def calculate_life_expectancy(era):
    """Calculate realistic life expectancy based on civilization era."""
    era_life_expectancy = {
        'stone_age': 35,
        'bronze_age': 40,
        'iron_age': 45,
        'classical': 50,
        'medieval': 55,
        'renaissance': 60,
        'industrial': 65,
        'modern': 75
    }
    return era_life_expectancy.get(era.lower(), 50)

def apply_updates(game_state, updates, is_timeskip=False):
    """
    Robustly applies updates from the AI to the game state using dot notation,
    including list indices and a custom '.append' syntax.
    Now with validation for better error handling and automatic leader succession.

    Args:
        game_state: The game state object to modify
        updates: Dictionary of updates to apply
        is_timeskip: If True, numeric values are treated as absolute replacements,
                     not incremental changes. Also allows list replacements.
    """
    mode = "Timeskip" if is_timeskip else "Turn"
    print(f"--- Applying AI {mode} Updates ---")

    # Validate updates first (with context-appropriate rules)
    is_valid, cleaned_updates, errors = validate_updates(updates, game_state, is_timeskip=is_timeskip)

    if errors:
        print("--- Validation Warnings (Timeskip) ---")
        for error in errors:
            print(f"  - {error}")

    # Use cleaned updates if available, otherwise fall back to original
    updates_to_apply = cleaned_updates if cleaned_updates else updates

    # Check if new leader is being set - if so, ensure years_ruled resets
    leader_keys = [k for k in updates_to_apply.keys() if 'civilization.leader' in k]
    if 'civilization.leader.name' in updates_to_apply:
        # New leader succession - ensure proper reset
        if 'civilization.leader.years_ruled' not in updates_to_apply:
            updates_to_apply['civilization.leader.years_ruled'] = 0
            print("  ‚ö† Auto-resetting years_ruled to 0 for new leader")

        # Get the era (either from updates or current state)
        era = updates_to_apply.get('civilization.meta.era') or game_state.civilization.get('meta', {}).get('era', 'stone_age')
        expected_life_exp = calculate_life_expectancy(era)

        # Validate and correct life expectancy
        if 'civilization.leader.life_expectancy' in updates_to_apply:
            ai_life_exp = updates_to_apply['civilization.leader.life_expectancy']
            # Check if AI value is realistic (within ¬±25 of expected)
            if abs(ai_life_exp - expected_life_exp) > 25:
                print(f"  ‚ö† AI provided unrealistic life_expectancy ({ai_life_exp}) for {era} era. Correcting to {expected_life_exp}")
                updates_to_apply['civilization.leader.life_expectancy'] = expected_life_exp
        else:
            # No life expectancy provided - set it
            updates_to_apply['civilization.leader.life_expectancy'] = expected_life_exp
            print(f"  ‚ö† Auto-setting life_expectancy to {expected_life_exp} based on {era} era")

    state_map = {
        "civilization": game_state.civilization,
        "culture": game_state.culture,
        "religion": game_state.religion,
        "technology": game_state.technology,
        "world": game_state.world
    }

    for key_path, value in updates_to_apply.items():
        try:
            is_append = key_path.endswith('.append')
            if is_append:
                key_path = key_path[:-7]

            parts = key_path.split('.')

            if parts[0] not in state_map:
                print(f"Warning: Invalid root key '{parts[0]}' in path. Skipping.")
                continue

            current_obj = state_map[parts[0]]

            # Traverse down to the object/list that needs modification
            for part in parts[1:-1]:
                match = re.match(r"(\w+)\[(\d+)\]", part)
                if match:
                    key, index = match.groups()
                    current_obj = current_obj[key][int(index)]
                else:
                    if part not in current_obj:
                        print(f"Warning: Path segment '{part}' not found in '{key_path}'. Skipping.")
                        break
                    current_obj = current_obj[part]
            else:
                last_part = parts[-1]

                if is_append:
                    if last_part not in current_obj:
                        print(f"Warning: Target list '{last_part}' not found in '{key_path}'. Skipping.")
                        continue

                    target_list = current_obj[last_part]
                    if isinstance(target_list, list):
                        if isinstance(value, str) and value not in target_list:
                            target_list.append(value)
                            print(f"  ‚úì Appended '{value}' to {'.'.join(parts)}")
                        elif isinstance(value, dict):
                            target_list.append(value)
                            print(f"  ‚úì Appended object to {'.'.join(parts)}")
                    else:
                        print(f"Warning: '{key_path}' is not a list, cannot append.")
                else:
                    # Handle assignment to a specific list index or a dictionary key
                    match = re.match(r"(\w+)\[(\d+)\]", last_part)
                    if match:
                        key, index = match.groups()
                        current_obj[key][int(index)] = value
                        print(f"  ‚úì Set {key_path} = {value}")
                    else:
                        target = current_obj.get(last_part)

                        # Timeskip mode: always replace values (absolute assignment)
                        if is_timeskip:
                            old_value = current_obj[last_part]
                            current_obj[last_part] = value

                            # Show different formatting for different types
                            if isinstance(value, int) and isinstance(old_value, int):
                                print(f"  ‚úì Set {'.'.join(parts)}: {old_value} ‚Üí {value}")
                            elif isinstance(value, list):
                                print(f"  ‚úì Replaced {'.'.join(parts)} with {len(value)} items")
                            else:
                                print(f"  ‚úì Set {'.'.join(parts)} = {value}")

                        # Turn mode: add integers, replace everything else
                        else:
                            if isinstance(target, int) and isinstance(value, int):
                                old_value = current_obj[last_part]
                                current_obj[last_part] += value
                                print(f"  ‚úì Updated {'.'.join(parts)}: {old_value} ‚Üí {current_obj[last_part]} ({value:+d})")
                            else:
                                current_obj[last_part] = value
                                print(f"  ‚úì Set {'.'.join(parts)} = {value}")
        except (KeyError, IndexError, TypeError, ValueError) as e:
            print(f"Error applying update '{key_path}': {e}. Path may be invalid or type mismatch. Skipping.")

    # Check if settlement image should be updated (after all updates applied)
    from engines.image_update_manager import should_update_settlement_image
    should_update, reason = should_update_settlement_image(game_state)
    if should_update:
        print(f"  üé® Updating settlement image: {reason}")
        # Trigger background settlement update
        from engines.visual_engine import update_settlement_image_async
        update_settlement_image_async(game_state)

    # Prune lists to prevent infinite growth
    prune_cultural_lists(game_state)
    print("------------------------------------")

def prune_cultural_lists(game_state):
    """
    Prevents culture values, traditions, and discoveries from growing infinitely.
    Keeps only the most recent/relevant items (max 15 each).
    """
    max_items = 15

    # Prune culture values (keep last 15)
    if len(game_state.culture.get('values', [])) > max_items:
        original_len = len(game_state.culture['values'])
        game_state.culture['values'] = game_state.culture['values'][-max_items:]
        print(f"  ‚ö† Pruned culture.values from {original_len} to {max_items} items")

    # Prune culture traditions (keep last 15)
    if len(game_state.culture.get('traditions', [])) > max_items:
        original_len = len(game_state.culture['traditions'])
        game_state.culture['traditions'] = game_state.culture['traditions'][-max_items:]
        print(f"  ‚ö† Pruned culture.traditions from {original_len} to {max_items} items")

    # Prune technology discoveries (keep last 20 for tech)
    max_tech = 20
    if len(game_state.technology.get('discoveries', [])) > max_tech:
        original_len = len(game_state.technology['discoveries'])
        game_state.technology['discoveries'] = game_state.technology['discoveries'][-max_tech:]
        print(f"  ‚ö† Pruned technology.discoveries from {original_len} to {max_tech} items")


def apply_world_turn_updates(game_state, world_updates):
    """Applies updates from the WorldTurnsEngine to the game state."""
    if not isinstance(world_updates, dict):
        print("Warning: world_updates is not a dictionary. Skipping.")
        return

    # Process faction updates using manager
    faction_updates = world_updates.get('faction_updates', [])
    if faction_updates:
        if not hasattr(game_state, 'faction_manager'):
            print("Warning: No faction manager available. Skipping faction updates.")
        else:
            for update in faction_updates:
                faction_name = update.get('name')
                if faction_name:
                    approval_change = update.get('approval_change', 0)
                    reason = update.get('reason', 'World events')
                    # Use manager for update (handles both ID and name lookups)
                    success = game_state.faction_manager.update_approval(faction_name, approval_change)
                    if success:
                        faction = game_state.faction_manager.get_by_name(faction_name)
                        # Add history entry for this change
                        game_state.faction_manager.add_history_entry(
                            faction_name,
                            reason,
                            approval_change,
                            game_state.turn_number
                        )
                        print(f"  - Faction '{faction_name}' approval changed by {approval_change:+d} to {faction['approval']}")
                    else:
                        print(f"  - Warning: Faction '{faction_name}' not found")

    # Process inner circle updates using manager
    inner_circle_updates = world_updates.get('inner_circle_updates', [])
    if inner_circle_updates:
        if not hasattr(game_state, 'inner_circle_manager'):
            print("Warning: No inner circle manager available. Skipping inner circle updates.")
        else:
            for update in inner_circle_updates:
                char_name = update.get('name')
                if char_name:
                    loyalty_change = update.get('loyalty_change', 0)
                    opinion_change = update.get('opinion_change', 0)
                    # Use manager for update (maps opinion_change to relationship)
                    success = game_state.inner_circle_manager.update_metrics(
                        char_name,
                        loyalty=loyalty_change,
                        relationship=opinion_change
                    )
                    if success:
                        print(f"  - Inner Circle '{char_name}' loyalty changed by {loyalty_change:+d}, opinion by {opinion_change:+d}")
                    else:
                        print(f"  - Warning: Character '{char_name}' not found")

                    # Add memory if provided (for council meetings)
                    if update.get('memory'):
                        mem_success = game_state.inner_circle_manager.add_memory(
                            char_name,
                            update['memory'],
                            game_state.turn_number
                        )
                        if mem_success:
                            print(f"  üìù Added memory for '{char_name}': {update['memory']}")
                        else:
                            print(f"  - Warning: Could not add memory for '{char_name}'")

    # Process neighboring civilization updates
    neighboring_civilization_updates = world_updates.get('neighboring_civilization_updates', [])
    if neighboring_civilization_updates:
        known_peoples = game_state.world.get('known_peoples', [])
        if not isinstance(known_peoples, list):
            print("Warning: known_peoples is not a list. Skipping neighbor updates.")
        else:
            # Relationship ladder: hostile ‚Üí unfriendly ‚Üí neutral ‚Üí friendly ‚Üí allied
            relationship_ladder = ["hostile", "unfriendly", "neutral", "friendly", "allied"]

            for update in neighboring_civilization_updates:
                civ_name = update.get('name')
                if civ_name:
                    # Find the civilization
                    civ = None
                    for people in known_peoples:
                        if people.get('name') == civ_name:
                            civ = people
                            break

                    if civ:
                        relationship_change = update.get('relationship_change', 0)
                        current_relationship = civ.get('relationship', 'neutral')

                        # Find current position on ladder
                        try:
                            current_index = relationship_ladder.index(current_relationship)
                        except ValueError:
                            # Default to neutral if current relationship not recognized
                            current_index = 2

                        # Calculate new position (clamped to ladder bounds)
                        # Each +/-10 points = one step on the ladder
                        steps = relationship_change // 10
                        new_index = max(0, min(len(relationship_ladder) - 1, current_index + steps))
                        new_relationship = relationship_ladder[new_index]

                        # Update the relationship
                        civ['relationship'] = new_relationship

                        if new_relationship != current_relationship:
                            print(f"  - Neighbor '{civ_name}' relationship changed from {current_relationship} to {new_relationship} (change: {relationship_change:+d})")
                        else:
                            print(f"  - Neighbor '{civ_name}' relationship unchanged ({current_relationship}, change: {relationship_change:+d})")
                    else:
                        print(f"  - Warning: Civilization '{civ_name}' not found in known_peoples")



################################################################################
# FILE: old_codebase\engines\state_validator.py
# Size: 13703 bytes
################################################################################

# engines/state_validator.py
"""
Validates AI-generated state updates before applying them.
Prevents invalid paths, out-of-bounds values, and malformed updates.

SCHEMA DOCUMENTATION:
---------------------
Valid update paths for AI:

NUMERIC UPDATES (incremental changes):
  - civilization.population: ¬±1000 (change to population)
  - civilization.resources.food: ¬±2000 (change to food stores)
  - civilization.resources.wealth: ¬±5000 (change to wealth)
  - civilization.leader.age: +0 to +2 (automatic aging, rarely modified)

APPEND OPERATIONS (add new items to lists):
  - culture.values.append: string (new cultural value)
  - culture.traditions.append: string (new tradition)
  - culture.taboos.append: string (new taboo)
  - religion.practices.append: string (new religious practice)
  - religion.core_tenets.append: string (new core belief)
  - religion.holy_sites.append: string (new sacred location)
  - technology.discoveries.append: string (new discovery)
  - technology.infrastructure.append: string (new infrastructure)

RESTRICTIONS:
  - Cannot create new keys at civilization root (e.g., civilization.scouts_dispatched)
  - Cannot use invalid root keys (e.g., population.change, food.change, narrative.append)
  - Cannot append to lists that don't exist in schema
  - Values are clamped to reasonable bounds
  - Duplicates are automatically filtered
"""

def validate_updates(updates, game_state, is_timeskip=False):
    """
    Validates AI update object before application.
    Returns (is_valid, cleaned_updates, errors)

    Args:
        updates: Dictionary of updates to validate
        game_state: The current game state
        is_timeskip: If True, uses more lenient validation rules for 500-year jumps
    """
    errors = []
    cleaned_updates = {}

    state_map = {
        "civilization": game_state.civilization,
        "culture": game_state.culture,
        "religion": game_state.religion,
        "technology": game_state.technology,
        "world": game_state.world
    }

    for key_path, value in updates.items():
        # Skip empty or invalid paths
        if not key_path or not isinstance(key_path, str):
            errors.append(f"Invalid key path: {key_path}")
            continue

        # Parse path
        keys = key_path.split('.')

        # Validate root key
        if keys[0] not in state_map:
            errors.append(f"Invalid root key '{keys[0]}' in path '{key_path}'")
            continue

        # Check if this is an append operation
        is_append = keys[-1] == 'append'

        # Validate path exists
        try:
            current_level = state_map[keys[0]]

            # For append operations, we need to navigate to the parent dict containing the list
            # For "culture.traditions.append": navigate through [] (nothing), final_key = "traditions"
            # For "culture.subkey.traditions.append": navigate through ["subkey"], final_key = "traditions"
            if is_append:
                path_keys = keys[1:-2] if len(keys) > 2 else []
                final_key = keys[-2]
            else:
                path_keys = keys[1:-1]
                final_key = keys[-1]

            # Navigate to the parent level
            for key in path_keys:
                if isinstance(current_level, dict) and key not in current_level:
                    errors.append(f"Path not found: '{key_path}' (missing '{key}')")
                    break
                current_level = current_level[key]
            else:
                # For append operations, verify the target is a list
                if is_append:
                    if isinstance(current_level, dict) and final_key in current_level:
                        if not isinstance(current_level[final_key], list):
                            errors.append(f"Cannot append to non-list at '{key_path}' (target is {type(current_level[final_key]).__name__})")
                            continue
                    else:
                        # List doesn't exist - reject the append
                        valid_append_paths = [
                            'culture.values.append', 'culture.traditions.append', 'culture.taboos.append',
                            'religion.practices.append', 'religion.core_tenets.append', 'religion.holy_sites.append',
                            'technology.discoveries.append', 'technology.infrastructure.append'
                        ]
                        errors.append(f"List path not found: '{key_path}' - '{final_key}' does not exist. Valid append paths: {', '.join(valid_append_paths)}")
                        continue
                # For regular operations, STRICTLY block creating new keys
                elif isinstance(current_level, dict) and final_key not in current_level:
                    # Block all new key creation - the schema must already have the key
                    errors.append(f"Cannot create new key '{final_key}' at '{key_path}'. Key does not exist in schema. Only existing keys can be updated.")
                    continue

                # Validate value bounds
                if isinstance(current_level, dict):
                    target = current_level.get(final_key)
                elif isinstance(current_level, list):
                    # For list operations, target is the list itself
                    target = current_level
                else:
                    errors.append(f"Invalid path type at '{key_path}'")
                    continue

                validated_value = validate_value(key_path, target, value, is_timeskip=is_timeskip)

                if validated_value is not None:
                    cleaned_updates[key_path] = validated_value
                else:
                    errors.append(f"Invalid value for '{key_path}': {value}")

        except (KeyError, TypeError) as e:
            errors.append(f"Path validation error for '{key_path}': {str(e)}")
            continue

    is_valid = len(errors) == 0
    return is_valid, cleaned_updates, errors

def validate_value(key_path, target, value, is_timeskip=False):
    """
    Validates individual values with bounds checking.
    Returns cleaned value or None if invalid.

    Args:
        key_path: The dot-notation path being validated
        target: The current value at that path
        value: The new value to validate
        is_timeskip: If True, uses absolute value validation for 500-year jumps
    """
    # Numeric bounds checking
    if isinstance(target, int) and isinstance(value, int):
        # Specific bounds for different fields
        if 'population' in key_path:
            if is_timeskip:
                # Timeskip: absolute population value (0 to 100,000)
                if value < 10:  # Minimum viable population
                    return 10
                if value > 100000:  # Reasonable cap for ancient/medieval era
                    return 100000
                return value
            else:
                # Turn: incremental change (¬±1000 max)
                if value < -target + 10:  # Prevent negative population
                    return max(-target + 10, -1000)
                if value > 1000:  # Limit population increase
                    return 1000
                return value

        elif 'food' in key_path:
            if is_timeskip:
                # Timeskip: absolute food value (-5000 to 20000)
                if value < -5000:
                    return -5000
                if value > 20000:
                    return 20000
                return value
            else:
                # Turn: incremental change (¬±2000 max)
                if value < -2000:
                    return -2000
                if value > 2000:
                    return 2000
                return value

        elif 'wealth' in key_path:
            if is_timeskip:
                # Timeskip: absolute wealth value (-10000 to 50000)
                if value < -10000:
                    return -10000
                if value > 50000:
                    return 50000
                return value
            else:
                # Turn: incremental change (¬±5000 max)
                if value < -5000:
                    return -5000
                if value > 5000:
                    return 5000
                return value

        elif 'age' in key_path:
            if is_timeskip:
                # Timeskip: absolute age value (0 to 100)
                if value < 0:
                    return 0
                if value > 100:
                    return 100
                return value
            else:
                # Turn: age increase (+0 to +2 per turn)
                if value < 0:
                    return 0
                if value > 2:
                    return 2
                return value

        elif 'year' in key_path:
            # Year advancement validation
            if 'meta.year' in key_path:
                if is_timeskip:
                    # Timeskip: must be exactly +500
                    if value != 500:
                        return 500
                else:
                    # Regular turn: must be exactly +1
                    if value != 1:
                        return 1
            return value

        return value

    # List validation
    elif isinstance(target, list):
        if is_timeskip and isinstance(value, list):
            # Timeskip: allow full list replacement
            if len(value) > 20:  # Reasonable max length
                return value[:20]  # Truncate if too long
            return value
        elif isinstance(value, str):
            # Append operation: add single string item
            if value in target:
                return None  # Skip duplicates
            if len(target) >= 20:
                return None  # Prevent infinite list growth
            return value
        else:
            return None

    # String/boolean - pass through
    elif isinstance(value, (str, bool)):
        return value

    # Type mismatch
    else:
        return None


def get_validation_summary(errors):
    """
    Creates a human-readable summary of validation errors.
    Useful for logging and debugging.

    Args:
        errors: List of error messages from validate_updates

    Returns:
        Formatted string summarizing the errors
    """
    if not errors:
        return "‚úì All updates valid"

    summary = [f"‚ö†Ô∏è Found {len(errors)} validation error(s):"]

    # Categorize errors
    invalid_roots = []
    invalid_paths = []
    invalid_values = []
    new_keys = []

    for error in errors:
        if "Invalid root key" in error:
            invalid_roots.append(error)
        elif "Path not found" in error or "List path not found" in error:
            invalid_paths.append(error)
        elif "Cannot create new key" in error:
            new_keys.append(error)
        else:
            invalid_values.append(error)

    if invalid_roots:
        summary.append(f"\n  Invalid Root Keys ({len(invalid_roots)}):")
        for err in invalid_roots[:3]:  # Show first 3
            summary.append(f"    - {err}")
        if len(invalid_roots) > 3:
            summary.append(f"    ... and {len(invalid_roots) - 3} more")

    if invalid_paths:
        summary.append(f"\n  Invalid Paths ({len(invalid_paths)}):")
        for err in invalid_paths[:3]:
            summary.append(f"    - {err}")
        if len(invalid_paths) > 3:
            summary.append(f"    ... and {len(invalid_paths) - 3} more")

    if new_keys:
        summary.append(f"\n  Attempted New Key Creation ({len(new_keys)}):")
        for err in new_keys[:3]:
            summary.append(f"    - {err}")
        if len(new_keys) > 3:
            summary.append(f"    ... and {len(new_keys) - 3} more")

    if invalid_values:
        summary.append(f"\n  Invalid Values ({len(invalid_values)}):")
        for err in invalid_values[:3]:
            summary.append(f"    - {err}")
        if len(invalid_values) > 3:
            summary.append(f"    ... and {len(invalid_values) - 3} more")

    summary.append("\n  Refer to state_validator.py SCHEMA DOCUMENTATION for valid paths.")

    return "\n".join(summary)


def print_schema_help():
    """
    Prints the valid schema paths for reference.
    Useful for debugging and documentation.
    """
    print("=" * 60)
    print("STATE VALIDATOR - VALID UPDATE PATHS")
    print("=" * 60)
    print()
    print("NUMERIC UPDATES (incremental changes):")
    print("  civilization.population: ¬±1000")
    print("  civilization.resources.food: ¬±2000")
    print("  civilization.resources.wealth: ¬±5000")
    print()
    print("APPEND OPERATIONS (add to lists):")
    print("  culture.values.append")
    print("  culture.traditions.append")
    print("  culture.taboos.append")
    print("  religion.practices.append")
    print("  religion.core_tenets.append")
    print("  religion.holy_sites.append")
    print("  technology.discoveries.append")
    print("  technology.infrastructure.append")
    print()
    print("RESTRICTIONS:")
    print("  - No arbitrary key creation")
    print("  - No invalid root keys (must be: civilization, culture, religion, technology, world)")
    print("  - Values clamped to reasonable bounds")
    print("  - Duplicates filtered automatically")
    print("=" * 60)



################################################################################
# FILE: old_codebase\engines\tendency_analyzer.py
# Size: 3814 bytes
################################################################################

# engines/tendency_analyzer.py
"""
Advanced player tendency analysis for event generation.
Analyzes player behavior patterns to create personalized events.
"""

def analyze_player_tendency(history_long, num_events=5):
    """
    Analyzes recent player actions and outcomes to determine behavioral tendencies.
    Returns primary tendency and secondary tendency for richer event generation.
    """
    tendencies = {
        "culture": 0,
        "religion": 0,
        "technology": 0,
        "survival": 0,
        "diplomacy": 0,
        "warfare": 0,
        "exploration": 0,
        "chaos": 0
    }

    # Keyword mappings with weighted importance
    keyword_map = {
        "culture": ["culture", "tradition", "value", "art", "festival", "pottery", "craft", "story"],
        "religion": ["faith", "spirit", "ritual", "pray", "deity", "sacred", "divine", "shaman", "worship"],
        "technology": ["tool", "discover", "build", "invent", "construct", "forge", "craft", "innovate", "improve"],
        "survival": ["food", "hunt", "gather", "survive", "shelter", "winter", "famine", "harvest"],
        "diplomacy": ["clan", "stranger", "trade", "ally", "peace", "negotiate", "treaty", "gift"],
        "warfare": ["attack", "defend", "raid", "battle", "weapon", "enemy", "conquer", "blood"],
        "exploration": ["scout", "explore", "venture", "journey", "discover", "cave", "unknown", "map"],
        "chaos": ["burn", "destroy", "mad", "chaos", "wild", "reckless", "desperate", "abandon"]
    }

    events = history_long.get("events", [])[-num_events:]

    if not events:
        return "survival", "balanced"

    # Analyze both actions and outcomes with recency weighting
    for i, event in enumerate(events):
        # More recent events weighted higher
        recency_weight = (i + 1) / len(events)

        action = event.get("action", "").lower()
        outcome = event.get("narrative", "").lower()

        # Analyze action (player intent)
        for tendency, keywords in keyword_map.items():
            for keyword in keywords:
                if keyword in action:
                    tendencies[tendency] += 2.0 * recency_weight  # Actions weighted more than outcomes
                if keyword in outcome:
                    tendencies[tendency] += 1.0 * recency_weight

    # If no clear tendency, return survival
    if max(tendencies.values()) == 0:
        return "survival", "balanced"

    # Get primary tendency
    primary = max(tendencies, key=tendencies.get)

    # Get secondary tendency (second highest, but must be significant)
    sorted_tendencies = sorted(tendencies.items(), key=lambda x: x[1], reverse=True)
    secondary = sorted_tendencies[1][0] if sorted_tendencies[1][1] > sorted_tendencies[0][1] * 0.5 else None

    return primary, secondary if secondary else "balanced"

def get_tendency_description(primary, secondary):
    """Returns a human-readable description of player tendencies."""
    desc_map = {
        "culture": "cultural development and artistic expression",
        "religion": "spiritual matters and religious devotion",
        "technology": "technological advancement and innovation",
        "survival": "ensuring survival and resource management",
        "diplomacy": "diplomatic relations and trade",
        "warfare": "military strength and conquest",
        "exploration": "exploration and discovery",
        "chaos": "unpredictable and risky decisions"
    }

    primary_desc = desc_map.get(primary, "balanced survival")

    if secondary and secondary != "balanced":
        secondary_desc = desc_map.get(secondary, "")
        return f"{primary_desc}, with secondary focus on {secondary_desc}"
    else:
        return primary_desc



################################################################################
# FILE: old_codebase\engines\timeskip_engine.py
# Size: 6412 bytes
################################################################################

# engines/timeskip_engine.py
import google.generativeai as genai
import json
from json import JSONDecodeError
import re
from engines.image_engine import generate_settlement_image
from engines.context_builder import build_timeskip_context
from engines.tendency_analyzer import analyze_player_tendency, get_tendency_description
from engines.state_validator import validate_updates
from engines.state_updater import apply_updates, calculate_life_expectancy
from engines.prompt_loader import load_prompt
from model_config import TIMESKIP_MODEL

def perform_timeskip(game_state):
    """
    Performs a ~500 year timeskip by calling the Gemini API to generate
    a narrative and a set of impactful game state updates.
    Optimized for faster response by deferring image generation.
    Integrates permanent decrees and their evolution over time.
    """
    print("--- Performing 500-Year Timeskip via Gemini API ---")
    model = genai.GenerativeModel(TIMESKIP_MODEL)

    # Build expanded context for 500-year jump (12 events)
    context = build_timeskip_context(game_state)

    # Analyze trajectory
    primary_tendency, secondary_tendency = analyze_player_tendency(game_state.history_long, num_events=10)
    tendency_desc = get_tendency_description(primary_tendency, secondary_tendency)
    print(f"--- Civilization Trajectory: {tendency_desc} ---")

    # Get permanent decrees summary for AI context
    from engines.law_engine import LawEngine
    law_engine = LawEngine(game_state)
    decrees_summary = law_engine.get_all_decrees_summary()
    print(f"--- Active Permanent Decrees: {len(law_engine.get_active_decrees())} ---")

    # Extract key narrative elements from player's history
    recent_events = context['recent_history']['events'][-8:]
    event_themes = [e.get('title', 'Unknown') for e in recent_events]

    # Determine dominant cultural values that should continue
    primary_values = ', '.join(context['culture']['values'][:3]) if context['culture']['values'] else 'survival and strength'

    prompt = load_prompt('timeskip/timeskip_500_years').format(
        civ_name=context['civilization']['meta']['name'],
        civ_year=context['civilization']['meta']['year'],
        civ_era=context['civilization']['meta']['era'],
        founding_leader_name=context['civilization']['leader']['name'],
        leader_age=context['civilization']['leader']['age'],
        population=f"{context['civilization']['population']:,}",
        food=f"{context['civilization']['resources']['food']:,}",
        wealth=f"{context['civilization']['resources']['wealth']:,}",
        tech_tier=context['civilization']['resources']['tech_tier'],
        primary_values=primary_values,
        religion_name=context['religion']['name'],
        religion_influence=context['religion']['influence'],
        primary_tendency=primary_tendency,
        tendency_desc=tendency_desc,
        event_themes='\n'.join([f"‚Ä¢ {title}" for title in event_themes]),
        decrees_summary=decrees_summary
    )

    try:
        response = model.generate_content(
            prompt,
            generation_config={
                "response_mime_type": "application/json",
                "temperature": 0.7  # Reduced for faster, more focused generation
            }
        )
        outcome = json.loads(response.text)
        print(f"--- Gemini Timeskip Outcome Received ---\n{json.dumps(outcome, indent=2)}\n-----------------------------")

        # Process decree evolution over 500 years
        print("--- Processing Decree Evolution ---")
        decree_results = law_engine.process_timeskip(years_passed=500)

        # Add decree narratives to the outcome if they exist
        if decree_results['decree_narratives']:
            print(f"  ‚Ä¢ {len(decree_results['evolved_decrees'])} decrees evolved")
            if decree_results['defunct_decrees']:
                print(f"  ‚Ä¢ {len(decree_results['defunct_decrees'])} decrees became defunct")
            if decree_results['new_schisms']:
                print(f"  ‚Ä¢ {len(decree_results['new_schisms'])} religious schisms occurred")

        # Enforce active decrees on current state
        law_engine.enforce_active_decrees()
        print("--- Active decrees enforced on civilization state ---")

        # Generate settlement evolution image (shows civilization progress)
        try:
            from engines.visual_engine import generate_settlement_evolution
            year = outcome.get('updates', {}).get('civilization.meta.year', 0)
            print("--- Generating settlement evolution image ---")
            import threading
            threading.Thread(
                target=generate_settlement_evolution,
                args=(game_state, year),
                daemon=True
            ).start()
        except Exception as img_error:
            print(f"Note: Settlement evolution image generation skipped: {img_error}")

        return outcome
    except JSONDecodeError as e:
        print(f"!!!!!!!!!! JSON PARSING ERROR (Timeskip) !!!!!!!!!!!\nFailed to parse AI response: {e}")
        print(f"Raw response: {response.text if 'response' in locals() else 'No response'}")
        return {
            "narrative": "The chronicler's records have become muddled. Five centuries pass, but the details are unclear.",
            "updates": {"civilization.meta.year": 500}
        }
    except Exception as e:
        error_msg = str(e)
        print(f"!!!!!!!!!! GEMINI API ERROR (Timeskip) !!!!!!!!!!!\n{e}")

        # Provide specific guidance for common errors
        if "404" in error_msg or "not found" in error_msg.lower():
            print("NOTE: The AI model may not be available. Check your GEMINI_API_KEY and model name.")
            print("SUGGESTION: Update the model name in timeskip_engine.py line 15 to 'gemini-1.5-flash' or another available model.")
        elif "quota" in error_msg.lower() or "rate limit" in error_msg.lower():
            print("NOTE: API quota exceeded. Please wait before trying again.")
        elif "permission" in error_msg.lower() or "forbidden" in error_msg.lower():
            print("NOTE: API key may not have permission to use this model.")

        return {
            "narrative": "The ages blur into a confusing haze, and the thread of history is lost. (An API error occurred during the timeskip.)",
            "updates": {"civilization.meta.year": 500}
        }




################################################################################
# FILE: old_codebase\engines\tree_generator.py
# Size: 3149 bytes
################################################################################

import json
import google.generativeai as genai
from model_config import TEXT_MODEL
from utils.prompt_loader import load_prompt

class TreeGenerator:
    """
    Generates technology and civics trees using an AI model.
    """

    def generate_tech_tree(self, config: dict) -> dict:
        """
        Generates a technology tree based on the provided configuration.

        Args:
            config: A dictionary containing configuration details like 'era', 'genre_control', etc.

        Returns:
            A dictionary representing the parsed JSON of the technology tree.
        """
        era = config.get("era", "Ancient")
        genre_control = config.get("genre_control", "Standard fantasy")

        prompt = load_prompt('trees/generate_tech_tree').format(era=era, genre_control=genre_control)

        print(f"--- Tech Tree Prompt ---\n{prompt}\n------------------------")

        try:
            model = genai.GenerativeModel(TEXT_MODEL)
            response = model.generate_content(
                prompt,
                generation_config={"response_mime_type": "application/json"}
            )
            return json.loads(response.text)
        except Exception as e:
            print(f"Error generating tech tree: {e}")
            # Fallback to a minimal tech tree
            return [
                {
                    "id": "tech_placeholder",
                    "name": "Placeholder Tech",
                    "description": "Error generating tree. Using placeholder.",
                    "cost": 0,
                    "prerequisites": [],
                    "era": era
                }
            ]

    def generate_civics_tree(self, config: dict) -> dict:
        """
        Generates a civics tree based on the provided configuration.

        Args:
            config: A dictionary containing configuration details like 'era', 'genre_control', etc.

        Returns:
            A dictionary representing the parsed JSON of the civics tree.
        """
        era = config.get("era", "Ancient")
        genre_control = config.get("genre_control", "Standard fantasy")

        prompt = load_prompt('trees/generate_civics_tree').format(era=era, genre_control=genre_control)

        print(f"--- Civics Tree Prompt ---\n{prompt}\n-------------------------")

        try:
            model = genai.GenerativeModel(TEXT_MODEL)
            response = model.generate_content(
                prompt,
                generation_config={"response_mime_type": "application/json"}
            )
            return json.loads(response.text)
        except Exception as e:
            print(f"Error generating civics tree: {e}")
            # Fallback to a minimal civics tree
            return [
                {
                    "id": "civic_placeholder",
                    "name": "Placeholder Civic",
                    "description": "Error generating tree. Using placeholder.",
                    "cost": 0,
                    "prerequisites": [],
                    "era": era
                }
            ]


################################################################################
# FILE: old_codebase\engines\victory_engine.py
# Size: 9124 bytes
################################################################################

# engines/victory_engine.py
"""
Victory condition and failure state detection.
Tracks progress toward different win conditions and checks for game-ending failures.
"""

def initialize_victory_tracking(game_state):
    """Initialize victory tracking if not present."""
    if 'victory_progress' not in game_state.civilization:
        game_state.civilization['victory_progress'] = {
            'cultural': 0,      # 0-100
            'technological': 0, # 0-100
            'military': 0,      # 0-100
            'spiritual': 0,     # 0-100
            'diplomatic': 0     # 0-100 (bonus path)
        }

def calculate_victory_progress(game_state):
    """
    Calculate progress toward each victory condition.
    Returns dict with progress percentages and thresholds.
    """
    initialize_victory_tracking(game_state)

    progress = game_state.civilization['victory_progress']
    population = game_state.civilization['population']
    era = game_state.civilization['meta']['era']

    # Cultural Victory: Based on traditions, values, cultural influence
    cultural_factors = 0
    cultural_factors += min(len(game_state.culture.get('values', [])) * 3, 30)  # Max 30 from values
    cultural_factors += min(len(game_state.culture.get('traditions', [])) * 4, 40)  # Max 40 from traditions
    cultural_factors += min(game_state.civilization.get('consequences', {}).get('reputation', {}).get('diplomatic', 0) // 3, 30)  # Max 30 from reputation

    progress['cultural'] = min(100, cultural_factors)

    # Technological Victory: Based on discoveries, infrastructure, era
    tech_factors = 0
    tech_factors += min(len(game_state.technology.get('discoveries', [])) * 2, 40)  # Max 40 from discoveries
    tech_factors += min(len(game_state.technology.get('infrastructure', [])) * 3, 30)  # Max 30 from infrastructure

    # Era bonus (progression through ages)
    era_values = {
        'stone_age': 0, 'bronze_age': 10, 'iron_age': 20, 'classical': 30,
        'medieval': 40, 'renaissance': 50, 'industrial': 60, 'modern': 80
    }
    tech_factors += era_values.get(era, 0)

    progress['technological'] = min(100, tech_factors)

    # Military Victory: Based on enemies defeated, military reputation, population strength
    military_factors = 0
    enemies = game_state.civilization.get('consequences', {}).get('enemies', [])
    military_factors += min(len(enemies) * 15, 45)  # Max 45 from having enemies (shows conflict)

    military_rep = game_state.civilization.get('consequences', {}).get('reputation', {}).get('military', 0)
    military_factors += min(military_rep // 2, 50)  # Max 50 from military reputation

    # Population shows strength
    if population > 5000:
        military_factors += 10

    progress['military'] = min(100, military_factors)

    # Spiritual Victory: Based on religious influence, holy sites, religious reputation
    spiritual_factors = 0
    spiritual_factors += min(len(game_state.religion.get('holy_sites', [])) * 15, 45)  # Max 45 from holy sites
    spiritual_factors += min(len(game_state.religion.get('practices', [])) * 5, 25)  # Max 25 from practices

    religious_rep = game_state.civilization.get('consequences', {}).get('reputation', {}).get('religious', 0)
    spiritual_factors += min(religious_rep // 3, 30)  # Max 30 from religious reputation

    progress['spiritual'] = min(100, spiritual_factors)

    # Diplomatic Victory: Based on alliances, promises kept, diplomatic reputation
    diplomatic_factors = 0
    alliances = game_state.civilization.get('consequences', {}).get('alliances', [])
    strong_alliances = [a for a in alliances if a.get('strength', 0) > 70]
    diplomatic_factors += min(len(strong_alliances) * 20, 40)  # Max 40 from strong alliances

    diplomatic_rep = game_state.civilization.get('consequences', {}).get('reputation', {}).get('diplomatic', 0)
    diplomatic_factors += min(diplomatic_rep // 2, 50)  # Max 50 from diplomatic reputation

    # Penalty for broken promises
    broken_promises = len(game_state.civilization.get('consequences', {}).get('broken_promises', []))
    diplomatic_factors -= broken_promises * 10

    progress['diplomatic'] = max(0, min(100, diplomatic_factors))

    # Save progress
    game_state.civilization['victory_progress'] = progress

    return progress

def check_victory(game_state):
    """
    Check if any victory condition has been met.
    Returns (bool, victory_type, description) or (False, None, None)
    """
    progress = calculate_victory_progress(game_state)

    # Check each victory type (threshold: 100)
    for victory_type, score in progress.items():
        if score >= 100:
            descriptions = {
                'cultural': f"Your civilization's cultural influence has spread far and wide! With {len(game_state.culture.get('traditions', []))} unique traditions and {len(game_state.culture.get('values', []))} core values, your society has become the cultural beacon of the age!",
                'technological': f"Your civilization has achieved technological supremacy! Through {len(game_state.technology.get('discoveries', []))} groundbreaking discoveries, you've propelled humanity into the {game_state.civilization['meta']['era']} era!",
                'military': f"Your military might is unmatched! Through strength and conquest, your civilization has dominated all rivals. None dare oppose you now!",
                'spiritual': f"Your civilization has achieved spiritual enlightenment! With {len(game_state.religion.get('holy_sites', []))} sacred sites, {game_state.religion['name']} has become the guiding light for all people!",
                'diplomatic': f"Through masterful diplomacy and {len(game_state.civilization.get('consequences', {}).get('alliances', []))} strong alliances, your civilization has unified the known world in peace!"
            }

            return True, victory_type, descriptions.get(victory_type, "Victory achieved!")

    return False, None, None

def check_failure(game_state):
    """
    Check if any failure condition has been met.
    Returns (bool, failure_type, description) or (False, None, None)
    """
    population = game_state.civilization['population']
    food = game_state.civilization['resources']['food']
    wealth = game_state.civilization['resources']['wealth']

    # Starvation Collapse: Population too low + no food
    if population < 100 and food <= 0:
        return True, 'starvation', f"Your civilization has collapsed from starvation. The few survivors scatter to the winds, and {game_state.civilization['meta']['name']} fades into forgotten history."

    # Population Extinction
    if population <= 50:
        return True, 'extinction', f"Your people have dwindled to nothing. {game_state.civilization['meta']['name']} is no more, its memory lost to time."

    # Total Economic Collapse (sustained bankruptcy with infrastructure lost)
    # Tightened threshold from pop<500 to pop<200 for more realistic failure
    infrastructure = game_state.technology.get('infrastructure', [])
    if wealth <= 0 and len(infrastructure) == 0 and population < 200:
        return True, 'collapse', f"Economic ruin and infrastructure decay have brought {game_state.civilization['meta']['name']} to its knees. Your civilization crumbles into chaos and is absorbed by neighboring powers."

    # Conquered (too many powerful enemies)
    enemies = game_state.civilization.get('consequences', {}).get('enemies', [])
    powerful_enemies = [e for e in enemies if e.get('hostility', 0) > 80]
    if len(powerful_enemies) >= 3 and population < 1000:
        return True, 'conquest', f"Surrounded by hostile enemies and weakened by conflict, {game_state.civilization['meta']['name']} has been conquered and absorbed into rival civilizations."

    return False, None, None

def get_victory_status_summary(game_state):
    """
    Get a summary of current victory progress for UI display.
    """
    progress = calculate_victory_progress(game_state)

    # Find closest to victory
    sorted_progress = sorted(progress.items(), key=lambda x: x[1], reverse=True)

    summary = {
        'closest_victory': sorted_progress[0][0],
        'closest_progress': sorted_progress[0][1],
        'all_progress': progress,
        'recommendations': []
    }

    # Add recommendations based on current state
    if progress['cultural'] > 60:
        summary['recommendations'].append("Focus on cultural traditions and values")
    if progress['technological'] > 60:
        summary['recommendations'].append("Continue technological advancement")
    if progress['military'] > 60:
        summary['recommendations'].append("Build military strength and conquer enemies")
    if progress['spiritual'] > 60:
        summary['recommendations'].append("Establish holy sites and spread faith")
    if progress['diplomatic'] > 60:
        summary['recommendations'].append("Strengthen alliances and diplomatic ties")

    return summary



################################################################################
# FILE: old_codebase\engines\visual_engine.py
# Size: 26257 bytes
################################################################################

# engines/visual_engine.py
"""
Visual generation engine using Gemini 2.5 Flash Image.
Handles leader portraits, crisis illustrations, and settlement evolution.
"""

from google import genai
from google.genai import types
import os
from PIL import Image
import io
from model_config import VISUAL_MODEL
from engines.prompt_loader import load_prompt

# Initialize client (API key is configured globally via genai.configure)
def get_client():
    """Get configured genai client using the API key from environment."""
    import google.generativeai as old_genai
    # The API key is already configured in main.py, we just need to use it
    api_key = os.getenv("GEMINI_API_KEY")
    if not api_key:
        raise ValueError("GEMINI_API_KEY not found in environment")
    return genai.Client(api_key=api_key)


def generate_leader_portrait(leader, civilization_context):
    """
    Generate a portrait for a leader using Gemini 2.5 Flash Image.

    Args:
        leader: Leader dict with name, age, traits, role
        civilization_context: Dict with era, culture info

    Returns:
        dict with image_path and success status
    """
    print(f"--- Generating portrait for {leader.get('name', 'Unknown')} ---")

    # Build portrait prompt
    name = leader.get('name', 'Unknown Leader')
    age = leader.get('age', 30)
    traits = leader.get('traits', [])
    role = leader.get('role', 'Leader')
    era = civilization_context.get('era', 'classical')
    culture_values = civilization_context.get('culture_values', [])

    # Age descriptors
    if age < 30:
        age_desc = "youthful"
    elif age < 50:
        age_desc = "middle-aged"
    elif age < 70:
        age_desc = "elderly"
    else:
        age_desc = "ancient"

    # Trait-based visual cues
    trait_descriptions = {
        'Brave': 'confident gaze, battle-worn features',
        'Warrior': 'scarred face, strong jawline, military bearing',
        'Wise': 'thoughtful expression, intelligent eyes',
        'Scholar': 'scholarly attire, holding a scroll or book',
        'Pious': 'serene expression, religious symbols visible',
        'Charismatic': 'warm smile, magnetic presence',
        'Diplomatic': 'refined features, elegant posture',
        'Ruthless': 'stern expression, cold eyes',
        'Cunning': 'sharp features, calculating gaze',
        'Mystic': 'otherworldly appearance, mystical elements',
        'Ancient': 'deeply lined face, white hair, frail but dignified'
    }

    visual_traits = [trait_descriptions.get(trait, '') for trait in traits if trait in trait_descriptions]
    trait_text = ', '.join(visual_traits[:3]) if visual_traits else 'dignified bearing'

    # Era-appropriate styling
    era_styles = {
        'stone_age': 'primitive furs and leather, tribal markings, stone ornaments',
        'bronze_age': 'bronze jewelry, woven fabrics, clay ornaments',
        'iron_age': 'iron torque or crown, wool garments, metalwork',
        'classical': 'toga or robes, laurel crown, classical architecture hints',
        'medieval': 'medieval crown, rich robes, heraldic symbols',
        'renaissance': 'renaissance clothing, ornate jewelry, refined aesthetics'
    }

    era_style = era_styles.get(era, 'classical robes and simple crown')

    # Enhanced age-specific visual details
    if age < 20:
        age_visual = "youthful with smooth skin, bright eyes full of idealism, untested and fresh-faced"
    elif age < 30:
        age_visual = "young adult with sharp features, eager gaze, minimal weathering"
    elif age < 45:
        age_visual = "in their prime, confident bearing, some life experience showing in the eyes"
    elif age < 60:
        age_visual = "mature with distinguished features, threads of gray in hair, wisdom in the gaze"
    elif age < 75:
        age_visual = "elderly with weathered face, gray or white hair, deep-set eyes showing years of rule"
    else:
        age_visual = "ancient with deeply lined face, white hair, stooped posture, frail but dignified, trembling hands"

    # Load and format prompt
    prompt_template = load_prompt('visuals/leader_portrait')
    prompt = prompt_template.format(
        name=name,
        age=age,
        age_desc=age_desc,
        age_visual=age_visual,
        role=role,
        era=era,
        trait_text=trait_text,
        era_style=era_style,
        culture_values=', '.join(culture_values[:2]) if culture_values else 'strength and tradition',
        traits=', '.join(traits)
    )

    try:
        client = get_client()

        response = client.models.generate_content(
            model=VISUAL_MODEL,
            contents=prompt,
            config=types.GenerateContentConfig(
                response_modalities=["IMAGE"]
            )
        )

        # Extract image data
        image_data = None
        for part in response.candidates[0].content.parts:
            if part.inline_data and part.inline_data.data:
                image_data = part.inline_data.data
                break

        if image_data:
            # Create directory if needed
            os.makedirs("static/images/leaders", exist_ok=True)

            # Generate filename
            import time
            timestamp = int(time.time())
            filename = f"leader_{name.replace(' ', '_').lower()}_{timestamp}.png"
            image_path = f"static/images/leaders/{filename}"

            # Save image
            img = Image.open(io.BytesIO(image_data))
            img.save(image_path)

            print(f"--- Portrait generated successfully: {image_path} ---")
            return {
                "image_path": image_path,
                "filename": filename,
                "success": True
            }
        else:
            raise ValueError("No image data in response")

    except Exception as e:
        print(f"Error generating leader portrait: {e}")
        import traceback
        traceback.print_exc()
        return {
            "image_path": "static/placeholder.png",
            "filename": "placeholder.png",
            "success": False,
            "error": str(e)
        }


def _parse_crisis_prompts(prompt_file_content):
    """
    Parse the crisis illustration prompt file into a dictionary.

    Args:
        prompt_file_content: The full content of crisis_illustration.txt

    Returns:
        Dictionary mapping crisis types to their prompts
    """
    crisis_prompts = {}

    # Split by the delimiter (---) and process each section
    sections = prompt_file_content.split('---')

    for section in sections:
        section = section.strip()
        if not section:
            continue

        # Process each line
        lines = section.split('\n')
        crisis_type = None
        prompt_lines = []

        for line in lines:
            # Skip comment lines (start with #, but not ##)
            if line.strip().startswith('#') and not line.strip().startswith('## '):
                continue

            if line.startswith('## '):
                # Extract crisis type and normalize it
                crisis_type = line.replace('## ', '').strip().lower()
            elif crisis_type and line.strip():  # Only add non-empty lines
                prompt_lines.append(line)

        if crisis_type and prompt_lines:
            crisis_prompts[crisis_type] = '\n'.join(prompt_lines).strip()

    return crisis_prompts


def generate_crisis_illustration(crisis_type, civilization_context):
    """
    Generate a dramatic illustration for a crisis event.

    Args:
        crisis_type: Type of crisis (famine, economic_collapse, etc.)
        civilization_context: Dict with era, population, etc.

    Returns:
        dict with image_path and success status
    """
    print(f"--- Generating crisis illustration: {crisis_type} ---")

    era = civilization_context.get('era', 'classical')
    civ_name = civilization_context.get('name', 'civilization')
    terrain = civilization_context.get('terrain', 'plains')

    # Load and parse crisis prompts from file
    crisis_file_content = load_prompt('visuals/crisis_illustration')
    crisis_prompts = _parse_crisis_prompts(crisis_file_content)

    # Select the appropriate prompt template based on crisis type
    prompt_template = crisis_prompts.get(crisis_type, crisis_prompts.get('famine', ''))

    # Format the prompt with variables
    prompt = prompt_template.format(era=era, terrain=terrain)

    try:
        client = get_client()

        response = client.models.generate_content(
            model=VISUAL_MODEL,
            contents=prompt,
            config=types.GenerateContentConfig(
                response_modalities=["IMAGE"]
            )
        )

        # Extract image
        image_data = None
        for part in response.candidates[0].content.parts:
            if part.inline_data and part.inline_data.data:
                image_data = part.inline_data.data
                break

        if image_data:
            os.makedirs("static/images/crises", exist_ok=True)

            filename = f"crisis_{crisis_type}_{era}.png"
            image_path = f"static/images/crises/{filename}"

            # Save (or check if already exists to use cache)
            if not os.path.exists(image_path):
                img = Image.open(io.BytesIO(image_data))
                img.save(image_path)
                print(f"--- Crisis illustration saved: {image_path} ---")
            else:
                print(f"--- Using cached crisis illustration: {image_path} ---")

            return {
                "image_path": image_path,
                "filename": filename,
                "success": True
            }
        else:
            raise ValueError("No image data in response")

    except Exception as e:
        print(f"Error generating crisis illustration: {e}")
        import traceback
        traceback.print_exc()
        return {
            "image_path": "static/placeholder.png",
            "filename": "placeholder.png",
            "success": False,
            "error": str(e)
        }


def generate_settlement_evolution(game_state, year_marker):
    """
    Generate an updated settlement image showing civilization evolution.
    Enhanced version of the existing settlement generator with versioning.

    Args:
        game_state: Full game state
        year_marker: Year for filename tracking

    Returns:
        dict with image_path and success status
    """
    print(f"--- Generating settlement evolution image for year {year_marker} ---")

    from engines.context_builder import build_image_context

    context = build_image_context(game_state)

    # Determine settlement size
    pop = context['civilization']['population']
    if pop < 100:
        size_desc = "small primitive camp"
    elif pop < 500:
        size_desc = "modest village"
    elif pop < 2000:
        size_desc = "thriving town"
    elif pop < 10000:
        size_desc = "large settlement"
    else:
        size_desc = "sprawling city"

    era = context['civilization']['era']
    tech_tier = context['civilization']['tech_tier']

    # Extract recent infrastructure for visual references
    recent_infrastructure = context['technology'].get('infrastructure', [])
    infrastructure_visual = ""
    if recent_infrastructure:
        latest_buildings = recent_infrastructure[-3:]
        infrastructure_visual = f"\n- Prominently feature recently built infrastructure: {', '.join(latest_buildings)}"

    # Cultural aesthetic guidance
    culture_values = context['culture'].get('values', [])
    cultural_aesthetic = ""
    if culture_values:
        values_str = ', '.join(culture_values[:3])
        cultural_aesthetic = f"\n- Cultural aesthetic influenced by values: {values_str} (e.g., 'Martial Pride' = military structures prominent, 'Artistic Excellence' = decorative architecture, 'Religious Devotion' = grand temples)"

    # Load and format prompt
    prompt_template = load_prompt('visuals/settlement_evolution')
    prompt = prompt_template.format(
        civ_name=context['civilization']['name'],
        year_marker=year_marker,
        size_desc=size_desc,
        era=era,
        tech_tier=tech_tier,
        population=f"{context['civilization']['population']:,}",
        culture_values=', '.join(culture_values[:3]) if culture_values else 'survival and growth',
        terrain=context['world']['terrain'],
        climate=context['world']['climate'],
        resources=', '.join(context['world'].get('resources', ['basic resources'])),
        religion_name=context['religion']['name'],
        holy_sites=', '.join(context['religion'].get('holy_sites', ['sacred grounds'])),
        social_structure=context['culture']['social_structure'],
        cultural_aesthetic=cultural_aesthetic,
        infrastructure_visual=infrastructure_visual,
        recent_infrastructure=', '.join(recent_infrastructure[-2:]) if recent_infrastructure else 'none yet'
    )

    try:
        client = get_client()

        response = client.models.generate_content(
            model=VISUAL_MODEL,
            contents=prompt,
            config=types.GenerateContentConfig(
                response_modalities=["IMAGE"]
            )
        )

        image_data = None
        for part in response.candidates[0].content.parts:
            if part.inline_data and part.inline_data.data:
                image_data = part.inline_data.data
                break

        if image_data:
            os.makedirs("static/images/settlements", exist_ok=True)

            filename = f"settlement_{year_marker}_{era}.png"
            image_path = f"static/images/settlements/{filename}"

            img = Image.open(io.BytesIO(image_data))

            # Resize to 2x for better display quality
            new_size = (img.width * 2, img.height * 2)
            resized_img = img.resize(new_size, Image.Resampling.LANCZOS)
            resized_img.save(image_path)

            # Also update the main settlement.png for backward compatibility
            resized_img.save("static/settlement.png")

            print(f"--- Settlement evolution image saved: {image_path} ---")

            # Cleanup old settlements (keep only last 5)
            cleanup_old_settlements()

            return {
                "image_path": image_path,
                "filename": filename,
                "success": True,
                "year": year_marker
            }
        else:
            raise ValueError("No image data in response")

    except Exception as e:
        print(f"Error generating settlement evolution: {e}")
        import traceback
        traceback.print_exc()
        return {
            "image_path": "static/placeholder.png",
            "filename": "placeholder.png",
            "success": False,
            "error": str(e)
        }


def cleanup_old_settlements():
    """Keep only the 5 most recent settlement images to save disk space."""
    settlements_dir = "static/images/settlements"

    if not os.path.exists(settlements_dir):
        return

    # Get all settlement images
    settlements = [f for f in os.listdir(settlements_dir) if f.startswith("settlement_") and f.endswith(".png")]

    if len(settlements) > 5:
        # Sort by modification time
        settlements.sort(key=lambda x: os.path.getmtime(os.path.join(settlements_dir, x)))

        # Remove oldest
        to_remove = settlements[:-5]
        for filename in to_remove:
            try:
                os.remove(os.path.join(settlements_dir, filename))
                print(f"  Cleaned up old settlement: {filename}")
            except Exception as e:
                print(f"  Could not remove {filename}: {e}")


def get_settlement_gallery(limit=5):
    """
    Get list of recent settlement images for gallery display.

    Returns:
        List of dicts with filename, year, era, path
    """
    settlements_dir = "static/images/settlements"

    if not os.path.exists(settlements_dir):
        return []

    settlements = [f for f in os.listdir(settlements_dir) if f.startswith("settlement_") and f.endswith(".png")]

    # Sort by modification time (newest first)
    settlements.sort(key=lambda x: os.path.getmtime(os.path.join(settlements_dir, x)), reverse=True)

    gallery = []
    for filename in settlements[:limit]:
        # Parse filename: settlement_[year]_[era].png
        parts = filename.replace("settlement_", "").replace(".png", "").split("_")
        year = parts[0] if len(parts) > 0 else "0"
        era = parts[1] if len(parts) > 1 else "unknown"

        gallery.append({
            "filename": filename,
            "year": year,
            "era": era,
            "path": f"images/settlements/{filename}"
        })

    return gallery


def generate_advisor_portrait(advisor, civilization_context):
    """
    Generate a portrait for an Inner Circle advisor using Gemini 2.5 Flash Image.
    Uses the same style system as leader portraits for consistency.

    Args:
        advisor: Advisor dict with name, role, personality_traits, etc.
        civilization_context: Dict with era, culture info

    Returns:
        dict with image_path, filename, and success status
    """
    print(f"--- Generating advisor portrait for {advisor.get('name', 'Unknown')} ---")

    # Extract advisor info
    name = advisor.get('name', 'Unknown Advisor')
    role = advisor.get('role', 'Advisor')
    traits = advisor.get('personality_traits', [])
    era = civilization_context.get('era', 'classical')
    culture_values = civilization_context.get('culture_values', [])

    # Infer age from role and traits (advisors are typically mature)
    if 'Elder' in role or 'Ancient' in traits:
        age = 65
        age_desc = "elderly"
        age_visual = "elderly with weathered face, gray or white hair, deep-set eyes showing years of experience"
    elif 'High Priest' in role or 'Grand' in role:
        age = 50
        age_desc = "mature"
        age_visual = "mature with distinguished features, threads of gray in hair, wisdom in the gaze"
    else:
        age = 40
        age_desc = "in their prime"
        age_visual = "in their prime, confident bearing, experience showing in the eyes"

    # Trait-based visual cues
    trait_descriptions = {
        'Pragmatic': 'calculating gaze, composed expression',
        'Cunning': 'sharp features, intelligent eyes',
        'Discreet': 'subtle presence, observant gaze',
        'Ambitious': 'determined expression, forward posture',
        'Disciplined': 'stern features, military bearing',
        'Direct': 'straightforward gaze, honest expression',
        'Loyal': 'trustworthy presence, steady eyes',
        'Stern': 'serious expression, commanding presence',
        'Pious': 'serene expression, religious symbols visible',
        'Compassionate': 'warm eyes, gentle features',
        'Traditionalist': 'formal attire, conservative bearing',
        'Serene': 'peaceful expression, calm demeanor'
    }

    visual_traits = [trait_descriptions.get(trait, '') for trait in traits if trait in trait_descriptions]
    trait_text = ', '.join(visual_traits[:3]) if visual_traits else 'dignified bearing'

    # Era-appropriate styling (same as leader portraits)
    era_styles = {
        'stone_age': 'primitive furs and leather, tribal markings, stone ornaments',
        'bronze_age': 'bronze jewelry, woven fabrics, clay ornaments',
        'iron_age': 'iron jewelry or insignia, wool garments, metalwork',
        'classical': 'classical robes, refined jewelry, toga or formal attire',
        'medieval': 'medieval attire, formal robes, period-appropriate regalia',
        'renaissance': 'renaissance clothing, ornate jewelry, refined aesthetics'
    }

    era_style = era_styles.get(era, 'classical robes and formal attire')

    # Role-specific visual elements
    role_visuals = {
        'Spymaster': 'dark clothing, subtle insignia, observant presence, hint of mystery',
        'Grand Marshal': 'military regalia, armor elements, medals, commanding bearing',
        'High Priestess': 'religious robes, holy symbols, serene presence, ceremonial attire',
        'High Priest': 'religious robes, holy symbols, wise presence, ceremonial attire',
        'Advisor': 'formal robes, scholarly appearance, dignified bearing',
        'Chancellor': 'administrative robes, scrolls or documents, official bearing',
        'General': 'military uniform, battle-worn features, strategic gaze'
    }

    role_visual = role_visuals.get(role, 'formal attire befitting their position')

    # Load and format prompt
    prompt_template = load_prompt('visuals/advisor_portrait')
    prompt = prompt_template.format(
        name=name,
        age=age,
        age_desc=age_desc,
        age_visual=age_visual,
        role=role,
        era=era,
        trait_text=trait_text,
        role_visual=role_visual,
        era_style=era_style,
        culture_values=', '.join(culture_values[:2]) if culture_values else 'wisdom and service',
        traits=', '.join(traits[:3])
    )

    try:
        client = get_client()

        response = client.models.generate_content(
            model=VISUAL_MODEL,
            contents=prompt,
            config=types.GenerateContentConfig(
                response_modalities=["IMAGE"]
            )
        )

        # Extract image data
        image_data = None
        for part in response.candidates[0].content.parts:
            if part.inline_data and part.inline_data.data:
                image_data = part.inline_data.data
                break

        if image_data:
            # Create directory if needed
            os.makedirs("static/images/advisors", exist_ok=True)

            # Generate filename
            import time
            timestamp = int(time.time())
            filename = f"advisor_{name.replace(' ', '_').lower()}_{timestamp}.png"
            image_path = f"static/images/advisors/{filename}"

            # Save image
            img = Image.open(io.BytesIO(image_data))
            img.save(image_path)

            print(f"--- Advisor portrait generated successfully: {image_path} ---")
            return {
                "image_path": image_path,
                "filename": filename,
                "success": True
            }
        else:
            raise ValueError("No image data in response")

    except Exception as e:
        print(f"Error generating advisor portrait: {e}")
        import traceback
        traceback.print_exc()
        return {
            "image_path": "static/placeholder.png",
            "filename": "placeholder.png",
            "success": False,
            "error": str(e)
        }


# ============================================================================
# ASYNC IMAGE UPDATE FUNCTIONS (Background Threading)
# ============================================================================

def update_leader_portrait_async(game_state):
    """
    Trigger background leader portrait regeneration.
    This runs in a separate thread to avoid blocking gameplay.
    """
    import threading

    def _generate_and_update():
        try:
            leader = game_state.civilization['leader']

            # Build civilization context for portrait generation
            civ_context = {
                'era': game_state.civilization['meta']['era'],
                'culture_values': game_state.culture.get('values', [])
            }

            # Generate new portrait
            result = generate_leader_portrait(leader, civ_context)

            if result['success']:
                # Update the leader's portrait reference
                game_state.civilization['leader']['portrait'] = result['filename']

                # Update the tracker
                from engines.image_update_manager import get_tracker
                tracker = get_tracker()
                tracker.update_portrait_state(game_state)

                print(f"  ‚úì Leader portrait updated successfully: {result['filename']}")
            else:
                print(f"  ‚úó Failed to update leader portrait: {result.get('error', 'Unknown error')}")

        except Exception as e:
            print(f"  ‚úó Error in background portrait update: {e}")
            import traceback
            traceback.print_exc()

    # Start background thread
    thread = threading.Thread(target=_generate_and_update, daemon=True)
    thread.start()


def update_settlement_image_async(game_state):
    """
    Trigger background settlement image regeneration.
    This runs in a separate thread to avoid blocking gameplay.
    """
    import threading

    def _generate_and_update():
        try:
            year_marker = game_state.civilization['meta']['year']

            # Generate new settlement image
            result = generate_settlement_evolution(game_state, year_marker)

            if result['success']:
                # Update the tracker
                from engines.image_update_manager import get_tracker
                tracker = get_tracker()
                tracker.update_settlement_state(game_state)

                print(f"  ‚úì Settlement image updated successfully: {result['filename']}")
            else:
                print(f"  ‚úó Failed to update settlement image: {result.get('error', 'Unknown error')}")

        except Exception as e:
            print(f"  ‚úó Error in background settlement update: {e}")
            import traceback
            traceback.print_exc()

    # Start background thread
    thread = threading.Thread(target=_generate_and_update, daemon=True)
    thread.start()



################################################################################
# FILE: old_codebase\engines\world_modes\__init__.py
# Size: 625 bytes
################################################################################

"""
World Modes Module

This module contains different world generation modes for the Civilization game.
Each mode provides unique world generation logic, faction templates, and historical frameworks.

Available modes:
- fantasy: Randomized fantasy setting (original behavior)
- historical_earth: Historical Earth simulation with butterfly effects
"""

from engines.world_modes.base_mode import WorldMode
from engines.world_modes.fantasy_mode import FantasyWorldMode
from engines.world_modes.historical_earth_mode import HistoricalEarthMode

__all__ = ['WorldMode', 'FantasyWorldMode', 'HistoricalEarthMode']



################################################################################
# FILE: old_codebase\engines\world_modes\base_mode.py
# Size: 5946 bytes
################################################################################

"""
Base World Mode Abstract Class

This module defines the abstract base class for all world generation modes.
Each mode must implement specific methods for generating civilizations, factions,
geography, and other world elements.
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Any, Tuple


class WorldMode(ABC):
    """Abstract base class for world generation modes."""

    @abstractmethod
    def get_era_configs(self) -> Dict[str, Dict[str, Any]]:
        """
        Return era configurations for this mode.

        Returns:
            Dict mapping era names to configuration dictionaries
        """
        pass

    @abstractmethod
    def get_terrain_configs(self) -> Dict[str, Dict[str, Any]]:
        """
        Return terrain configurations for this mode.

        Returns:
            Dict mapping terrain types to configuration dictionaries
        """
        pass

    @abstractmethod
    def get_culture_templates(self) -> Dict[str, Dict[str, Any]]:
        """
        Return culture templates for this mode.

        Returns:
            Dict mapping culture types to template dictionaries
        """
        pass

    @abstractmethod
    def get_religion_configs(self) -> Dict[str, Dict[str, Any]]:
        """
        Return religion configurations for this mode.

        Returns:
            Dict mapping religion types to configuration dictionaries
        """
        pass

    @abstractmethod
    def get_social_structures(self) -> Dict[str, Dict[str, Any]]:
        """
        Return social structure configurations for this mode.

        Returns:
            Dict mapping social structure types to configuration dictionaries
        """
        pass

    @abstractmethod
    def generate_factions(self, era: str, config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Generate appropriate factions for this mode based on era and config.

        Args:
            era: The current era (e.g., 'stone_age', 'classical')
            config: Configuration dictionary with user choices

        Returns:
            List of faction dictionaries
        """
        pass

    @abstractmethod
    def generate_geography(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generate world geography for this mode.

        Args:
            config: Configuration dictionary with user choices

        Returns:
            Dictionary with geography details
        """
        pass

    @abstractmethod
    def get_starting_year(self, era: str) -> int:
        """
        Get appropriate starting year for the given era.

        Args:
            era: The era name

        Returns:
            Starting year (negative for BCE)
        """
        pass

    @abstractmethod
    def generate_civilization(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generate the player's civilization data.

        Args:
            config: Configuration dictionary with user choices

        Returns:
            Civilization data dictionary
        """
        pass

    @abstractmethod
    def generate_culture(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generate culture data.

        Args:
            config: Configuration dictionary with user choices

        Returns:
            Culture data dictionary
        """
        pass

    @abstractmethod
    def generate_religion(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generate religion data.

        Args:
            config: Configuration dictionary with user choices

        Returns:
            Religion data dictionary
        """
        pass

    @abstractmethod
    def generate_technology(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generate technology data.

        Args:
            config: Configuration dictionary with user choices

        Returns:
            Technology data dictionary
        """
        pass

    @abstractmethod
    def generate_world_context(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generate world context data.

        Args:
            config: Configuration dictionary with user choices

        Returns:
            World context dictionary
        """
        pass

    @abstractmethod
    def generate_inner_circle(self, config: Dict[str, Any], factions: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Generate inner circle advisors.

        Args:
            config: Configuration dictionary with user choices
            factions: List of faction dictionaries

        Returns:
            List of inner circle member dictionaries
        """
        pass

    def generate(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Main generation method that coordinates all world generation.

        Args:
            config: Configuration dictionary with user choices

        Returns:
            Complete world data dictionary
        """
        # Generate all components
        civilization = self.generate_civilization(config)
        culture = self.generate_culture(config)
        religion = self.generate_religion(config)
        technology = self.generate_technology(config)
        world_context = self.generate_world_context(config)
        factions = self.generate_factions(config.get('starting_era', 'stone_age'), config)
        inner_circle = self.generate_inner_circle(config, factions)

        return {
            'civilization': civilization,
            'culture': culture,
            'religion': religion,
            'technology': technology,
            'world_context': world_context,
            'factions': factions,
            'inner_circle': inner_circle
        }



################################################################################
# FILE: old_codebase\engines\world_modes\fantasy_mode.py
# Size: 34591 bytes
################################################################################

"""
Fantasy World Mode

This mode provides randomized fantasy world generation with fictional civilizations,
cultures, and geography. This is the original world generation behavior.
"""

import random
from typing import Dict, List, Any
from engines.world_modes.base_mode import WorldMode


class FantasyWorldMode(WorldMode):
    """Fantasy world generation mode with random mythical elements."""

    # Configuration mappings (preserving original fantasy behavior)
    ERA_CONFIGS = {
        "stone_age": {
            "era": "stone_age",
            "year_range": (-50000, -10000),
            "tech_tier": "stone_age",
            "base_discoveries": ["Fire", "Basic Stone Tools", "Spears"],
            "base_infrastructure": ["Central Campfire", "Temporary Shelters"],
            "population_multiplier": 0.5
        },
        "bronze_age": {
            "era": "bronze_age",
            "year_range": (-3000, -1200),
            "tech_tier": "bronze_age",
            "base_discoveries": ["Fire", "Basic Stone Tools", "Spears", "Improved Stone Tools", "Basic Pottery", "Bronze Casting"],
            "base_infrastructure": ["Central Campfire", "Permanent Huts", "Storage Pits"],
            "population_multiplier": 1.0
        },
        "iron_age": {
            "era": "iron_age",
            "year_range": (-1200, -500),
            "tech_tier": "iron_age",
            "base_discoveries": ["Fire", "Basic Stone Tools", "Spears", "Improved Stone Tools", "Basic Pottery", "Bronze Casting", "Iron Smelting", "Advanced Metalwork"],
            "base_infrastructure": ["Central Campfire", "Permanent Huts", "Storage Pits", "Stone Walls", "Watchtowers"],
            "population_multiplier": 1.5
        },
        "classical": {
            "era": "classical",
            "year_range": (-500, 500),
            "tech_tier": "classical",
            "base_discoveries": ["Fire", "Basic Stone Tools", "Spears", "Improved Stone Tools", "Basic Pottery", "Bronze Casting", "Iron Smelting", "Advanced Metalwork", "Writing Systems", "Advanced Architecture"],
            "base_infrastructure": ["Central Campfire", "Permanent Huts", "Storage Pits", "Stone Walls", "Watchtowers", "Marketplace", "Temple"],
            "population_multiplier": 2.0
        }
    }

    TERRAIN_CONFIGS = {
        "coastal": {
            "terrain": "Coastal cliffs with beaches and tide pools",
            "climate": "Temperate maritime",
            "resources": ["Fish", "Shellfish", "Seaweed", "Salt", "Driftwood"],
            "threats": ["Storms", "Tides", "Sea raiders"]
        },
        "forest": {
            "terrain": "Dense forest with clearings",
            "climate": "Temperate",
            "resources": ["Wild game", "Berries", "Timber", "Fresh water"],
            "threats": ["Wild beasts", "Harsh winters", "Forest fires"]
        },
        "mountain": {
            "terrain": "Rocky highlands with valleys",
            "climate": "Alpine",
            "resources": ["Stone", "Mountain herbs", "Game birds", "Snow melt water"],
            "threats": ["Avalanches", "Cold", "Mountain predators", "Difficult terrain"]
        },
        "desert": {
            "terrain": "Arid dunes with scattered oases",
            "climate": "Arid",
            "resources": ["Date palms", "Cacti", "Underground water", "Salt"],
            "threats": ["Sandstorms", "Extreme heat", "Scarce water", "Desert raiders"]
        },
        "plains": {
            "terrain": "Rolling grasslands",
            "climate": "Continental",
            "resources": ["Wild grains", "Grazing animals", "Rivers", "Clay"],
            "threats": ["Wildfires", "Nomadic raiders", "Droughts", "Floods"]
        },
        "river_valley": {
            "terrain": "Fertile valley along a great river",
            "climate": "Temperate",
            "resources": ["Fresh water", "Fertile soil", "Fish", "Reeds", "Wild game"],
            "threats": ["Flooding", "Waterborne diseases", "Rival settlements"]
        },
        "island": {
            "terrain": "Volcanic island with lush vegetation",
            "climate": "Tropical",
            "resources": ["Coconuts", "Fish", "Tropical fruits", "Obsidian"],
            "threats": ["Isolation", "Volcanic activity", "Hurricanes", "Limited resources"]
        }
    }

    CULTURE_TEMPLATES = {
        "martial": {
            "values": ["Strength", "Courage", "Honor", "Discipline", "Loyalty"],
            "sample_traditions": ["Warrior Initiations", "Battle Commemorations", "Weapon Crafting Ceremonies"],
            "traits": ["Aggressive", "Disciplined", "Territorial"]
        },
        "spiritual": {
            "values": ["Wisdom", "Devotion", "Harmony", "Respect for Spirits", "Ritual"],
            "sample_traditions": ["Seasonal Rituals", "Spirit Offerings", "Sacred Pilgrimages"],
            "traits": ["Contemplative", "Mystical", "Ritualistic"]
        },
        "agricultural": {
            "values": ["Hard Work", "Community", "Harvest", "Patience", "Sustainability"],
            "sample_traditions": ["Planting Festivals", "Harvest Celebrations", "Crop Rotation Rituals"],
            "traits": ["Patient", "Cooperative", "Grounded"]
        },
        "mercantile": {
            "values": ["Trade", "Prosperity", "Diplomacy", "Innovation", "Fairness"],
            "sample_traditions": ["Market Days", "Trade Agreements", "Merchant Guilds"],
            "traits": ["Diplomatic", "Shrewd", "Cosmopolitan"]
        },
        "scholarly": {
            "values": ["Knowledge", "Curiosity", "Innovation", "Record-Keeping", "Teaching"],
            "sample_traditions": ["Oral Storytelling", "Star Gazing Ceremonies", "Knowledge Sharing Gatherings"],
            "traits": ["Inquisitive", "Methodical", "Inventive"]
        },
        "artistic": {
            "values": ["Beauty", "Expression", "Creativity", "Tradition", "Excellence"],
            "sample_traditions": ["Art Festivals", "Craftsmanship Competitions", "Performance Rituals"],
            "traits": ["Creative", "Expressive", "Detail-Oriented"]
        }
    }

    RELIGION_CONFIGS = {
        "animism": {
            "name": "Animism",
            "type": "Spirit Worship",
            "tenets": ["All things have a spirit", "The natural world must be respected", "Balance must be maintained"],
            "practices": ["Shamanic rituals", "Spirit offerings", "Nature veneration"]
        },
        "polytheism": {
            "name": "Polytheism",
            "type": "Multiple Deities",
            "tenets": ["The gods influence all aspects of life", "Each deity governs their domain", "Offerings bring favor"],
            "practices": ["Temple rituals", "Sacrificial offerings", "Divine festivals"]
        },
        "monotheism": {
            "name": "Monotheism",
            "type": "Single Deity",
            "tenets": ["There is one supreme divine power", "Faith brings salvation", "The divine law must be followed"],
            "practices": ["Prayer rituals", "Sacred texts recitation", "Pilgrimage"]
        },
        "ancestor_worship": {
            "name": "Ancestor Veneration",
            "type": "Ancestor Worship",
            "tenets": ["The ancestors watch over us", "Honor the dead to prosper", "Lineage is sacred"],
            "practices": ["Ancestral offerings", "Tomb maintenance", "Genealogy keeping"]
        },
        "nature_worship": {
            "name": "Nature Reverence",
            "type": "Nature Worship",
            "tenets": ["Nature is the source of all life", "Harmony with the land brings prosperity", "Sacred groves must be protected"],
            "practices": ["Seasonal ceremonies", "Sacred grove pilgrimages", "Natural offerings"]
        },
        "none": {
            "name": "No Dominant Religion",
            "type": "Secular/Mixed Beliefs",
            "tenets": ["Practical wisdom guides us", "Diversity of belief is accepted"],
            "practices": ["Personal rituals", "Community gatherings"]
        }
    }

    SOCIAL_STRUCTURES = {
        "egalitarian": "Egalitarian tribe where decisions are made collectively",
        "hierarchical": "Hierarchical society with clear social ranks",
        "tribal_council": "Tribal council of elders and skilled leaders",
        "monarchy": "Hereditary monarchy with a ruling family",
        "theocracy": "Religious leaders hold temporal power"
    }

    def get_era_configs(self) -> Dict[str, Dict[str, Any]]:
        return self.ERA_CONFIGS

    def get_terrain_configs(self) -> Dict[str, Dict[str, Any]]:
        return self.TERRAIN_CONFIGS

    def get_culture_templates(self) -> Dict[str, Dict[str, Any]]:
        return self.CULTURE_TEMPLATES

    def get_religion_configs(self) -> Dict[str, Dict[str, Any]]:
        return self.RELIGION_CONFIGS

    def get_social_structures(self) -> Dict[str, Dict[str, Any]]:
        return self.SOCIAL_STRUCTURES

    def get_starting_year(self, era: str) -> int:
        era_config = self.ERA_CONFIGS.get(era, self.ERA_CONFIGS["bronze_age"])
        year_min, year_max = era_config["year_range"]
        return random.randint(year_min, year_max)

    def generate_civilization(self, config: Dict[str, Any]) -> Dict[str, Any]:
        era = config.get("starting_era", config.get("era", "bronze_age"))
        civ_name = config.get("civilization_name", "The People")
        population_size = config.get("population_size", "medium")
        leader_name = config.get("leader_name", "")

        era_config = self.ERA_CONFIGS[era]

        # Population calculation
        pop_ranges = {
            "small": (100, 500),
            "medium": (500, 2000),
            "large": (2000, 5000)
        }
        pop_min, pop_max = pop_ranges[population_size]
        population = random.randint(
            int(pop_min * era_config["population_multiplier"]),
            int(pop_max * era_config["population_multiplier"])
        )

        # Year calculation
        year = self.get_starting_year(era)

        # Leader generation
        if not leader_name:
            leader_name = self._generate_leader_name()

        leader_traits = random.sample([
            "Wise", "Brave", "Diplomatic", "Strategic", "Charismatic",
            "Cautious", "Bold", "Spiritual", "Pragmatic", "Visionary"
        ], 3)

        return {
            "meta": {
                "name": civ_name,
                "year": year,
                "era": era_config["era"],
                "founding_date": year,
                "world_mode": "fantasy"
            },
            "leader": {
                "name": leader_name,
                "age": random.randint(25, 45),
                "life_expectancy": random.randint(60, 80),
                "role": "Leader",
                "traits": leader_traits,
                "years_ruled": 0
            },
            "population": population,
            "resources": {
                "food": population * random.randint(1, 3),
                "wealth": population * random.randint(1, 2),
                "tech_tier": era_config["tech_tier"]
            }
        }

    def generate_culture(self, config: Dict[str, Any]) -> Dict[str, Any]:
        cultural_focus = config.get("cultural_focus", "spiritual")
        social_structure = config.get("social_structure", "egalitarian")

        culture_template = self.CULTURE_TEMPLATES[cultural_focus]

        # Select values
        values = culture_template["values"].copy()
        values.extend(random.sample([
            "Survival", "Community", "Respect for Elders", "Adaptation",
            "Craftsmanship", "Generosity", "Resilience"
        ], 3))

        # Select traditions
        traditions = culture_template["sample_traditions"].copy()
        traditions.extend(random.sample([
            "Oral Storytelling", "Seasonal Celebrations", "Coming of Age Ceremonies",
            "Ancestral Veneration", "Crafting Competitions"
        ], 2))

        return {
            "values": values[:8],
            "traditions": traditions[:6],
            "taboos": ["Harming Kin", random.choice(["Oath Breaking", "Sacrilege", "Betrayal", "Waste"])],
            "social_structure": self.SOCIAL_STRUCTURES[social_structure],
            "recent_changes": []
        }

    def generate_religion(self, config: Dict[str, Any]) -> Dict[str, Any]:
        religion_type = config.get("religion_type", "animism")

        if religion_type not in self.RELIGION_CONFIGS:
            religion_type = "animism"

        religion_config = self.RELIGION_CONFIGS[religion_type]

        # Generate deity name based on type
        deity_names = {
            "animism": ["The Great Spirit", "The Wild Soul", "The Earth Mother"],
            "polytheism": ["The Pantheon of Stars", "The Divine Court", "The Ancient Gods"],
            "monotheism": ["The Eternal One", "The Supreme Creator", "The Divine Light"],
            "ancestor_worship": ["The First Ancestor", "The Ancient Fathers", "The Founding Lineage"],
            "nature_worship": ["The Forest Spirit", "The Mountain Guardian", "The River Mother"],
            "none": ["Various Spirits", "Personal Beliefs", "Folk Traditions"]
        }

        primary_deity = random.choice(deity_names.get(religion_type, ["The Unknown"]))

        # Generate holy sites
        holy_sites = [
            random.choice(["The Sacred Grove", "The Great Oak", "The Ancient Cave", "The Stone Circle"]),
            random.choice(["The Mountain Peak", "The River Source", "The Ancestor's Tomb", "The First Settlement"])
        ]

        return {
            "name": religion_config["name"],
            "type": religion_config["type"],
            "primary_deity": primary_deity,
            "core_tenets": religion_config["tenets"],
            "practices": religion_config["practices"],
            "holy_sites": holy_sites,
            "influence": random.choice(["dominant", "significant", "moderate"]),
            "schisms": []
        }

    def generate_technology(self, config: Dict[str, Any]) -> Dict[str, Any]:
        era = config.get("starting_era", config.get("era", "bronze_age"))
        era_config = self.ERA_CONFIGS[era]

        return {
            "current_tier": era_config["tech_tier"],
            "discoveries": era_config["base_discoveries"].copy(),
            "in_progress": [],
            "infrastructure": era_config["base_infrastructure"].copy()
        }

    def generate_world_context(self, config: Dict[str, Any]) -> Dict[str, Any]:
        return self.generate_geography(config)

    def generate_geography(self, config: Dict[str, Any]) -> Dict[str, Any]:
        terrain = config.get("terrain", "forest")
        difficulty = config.get("difficulty", "balanced")
        neighbor_count = config.get("neighbor_count", "few")
        resource_abundance = config.get("resource_abundance", "moderate")

        terrain_config = self.TERRAIN_CONFIGS[terrain]

        # Adjust resources based on abundance
        resources = terrain_config["resources"].copy()
        if resource_abundance == "abundant":
            resources.extend(random.sample(["Medicinal Herbs", "Precious Stones", "Rare Woods", "Exotic Spices"], 2))
        elif resource_abundance == "scarce":
            resources = resources[:max(2, len(resources) - 2)]

        # Adjust threats based on difficulty
        threats = terrain_config["threats"].copy()
        if difficulty == "challenging":
            threats.extend(random.sample(["Hostile Neighbors", "Natural Disasters", "Resource Scarcity", "Disease"], 2))
        elif difficulty == "peaceful":
            threats = threats[:max(1, len(threats) - 1)]

        # Generate neighbors
        neighbor_counts = {
            "none": 0,
            "few": random.randint(1, 2),
            "several": random.randint(3, 4)
        }

        num_neighbors = neighbor_counts.get(neighbor_count, 1)
        neighbors = []

        neighbor_names = [
            "The River Clan", "The Mountain Folk", "The Desert Wanderers",
            "The Forest Tribes", "The Sea People", "The Plains Riders",
            "The Stone Circle Clans", "The Sun Worshippers"
        ]

        for i in range(num_neighbors):
            relationship = random.choice(["allied", "neutral", "wary", "hostile"]) if difficulty != "peaceful" else random.choice(["allied", "neutral", "friendly"])

            neighbors.append({
                "name": random.choice(neighbor_names),
                "relationship": relationship,
                "strength": "unknown",
                "distance": random.choice(["nearby", "several days journey", "distant"]),
                "history": "Recently discovered" if i == 0 else "Known through tales and occasional contact"
            })

        return {
            "known_peoples": neighbors,
            "geography": {
                "terrain": terrain_config["terrain"],
                "climate": terrain_config["climate"],
                "resources": resources,
                "threats": threats
            }
        }

    def generate_factions(self, era: str, config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate fantasy factions."""
        return [
            {
                "name": "The Merchant's Guild",
                "leader": "Lysander the Wealthy",
                "approval": 60,
                "support_percentage": 25,
                "status": "Neutral",
                "goals": ["Establish new trade routes", "Increase city wealth by 20%", "Reduce tariffs on luxury goods"]
            },
            {
                "name": "The Elder Council",
                "leader": "Elder Maeve",
                "approval": 60,
                "support_percentage": 20,
                "status": "Neutral",
                "goals": ["Preserve ancient traditions", "Maintain social stability", "Construct a monument to the founders"]
            },
            {
                "name": "The Warrior's Caste",
                "leader": "Warlord Gorok",
                "approval": 60,
                "support_percentage": 30,
                "status": "Neutral",
                "goals": ["Expand our borders", "Recruit and train more soldiers", "Vanquish our rivals"]
            },
            {
                "name": "The Priesthood of the Sun",
                "leader": "High Priestess Elara",
                "approval": 60,
                "support_percentage": 25,
                "status": "Neutral",
                "goals": ["Spread the faith to new lands", "Build a Grand Temple", "Achieve spiritual enlightenment for the people"]
            }
        ]

    def generate_inner_circle(self, config: Dict[str, Any], factions: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Generate culturally grounded inner circle members."""
        cultural_focus = config.get("cultural_focus", "spiritual")
        era = config.get("starting_era", config.get("era", "bronze_age"))

        # Define role templates with cultural variations
        role_templates = [
            {
                "role_key": "military",
                "roles": {
                    "stone_age": "War Chief",
                    "bronze_age": "Commander",
                    "iron_age": "Grand Marshal",
                    "classical": "Strategos",
                    "medieval": "Lord Commander",
                    "renaissance": "Marshal General"
                },
                "base_traits": ["Disciplined", "Direct", "Stern"],
                "cultural_traits": {
                    "martial": ["Aggressive", "Tactical"],
                    "spiritual": ["Devoted", "Honorable"],
                    "agricultural": ["Protective", "Patient"],
                    "mercantile": ["Strategic", "Pragmatic"],
                    "scholarly": ["Analytical", "Methodical"],
                    "artistic": ["Charismatic", "Inspiring"]
                },
                "faction_preference": "warrior"
            },
            {
                "role_key": "intelligence",
                "roles": {
                    "stone_age": "Scout Master",
                    "bronze_age": "Eyes of the Throne",
                    "iron_age": "Spymaster",
                    "classical": "Master of Whispers",
                    "medieval": "Lord of Secrets",
                    "renaissance": "Intelligence Minister"
                },
                "base_traits": ["Cunning", "Discreet", "Observant"],
                "cultural_traits": {
                    "martial": ["Ruthless", "Efficient"],
                    "spiritual": ["Mysterious", "Intuitive"],
                    "agricultural": ["Patient", "Meticulous"],
                    "mercantile": ["Pragmatic", "Shrewd"],
                    "scholarly": ["Analytical", "Insightful"],
                    "artistic": ["Subtle", "Persuasive"]
                },
                "faction_preference": "merchant"
            },
            {
                "role_key": "spiritual",
                "roles": {
                    "stone_age": "Shaman",
                    "bronze_age": "High Priest",
                    "iron_age": "High Priestess",
                    "classical": "Hierophant",
                    "medieval": "Grand Cleric",
                    "renaissance": "Archbishop"
                },
                "base_traits": ["Pious", "Serene", "Compassionate"],
                "cultural_traits": {
                    "martial": ["Militant", "Resolute"],
                    "spiritual": ["Mystic", "Devoted"],
                    "agricultural": ["Nurturing", "Harmonious"],
                    "mercantile": ["Diplomatic", "Wise"],
                    "scholarly": ["Philosophical", "Learned"],
                    "artistic": ["Expressive", "Inspiring"]
                },
                "faction_preference": "priest"
            }
        ]

        characters = []

        for template in role_templates:
            # Get era-appropriate role title
            role = template["roles"].get(era, template["roles"]["bronze_age"])

            # Build personality traits
            traits = template["base_traits"].copy()
            cultural_traits = template["cultural_traits"].get(cultural_focus, [])
            if cultural_traits:
                traits.extend(random.sample(cultural_traits, min(2, len(cultural_traits))))

            # Randomly shuffle and pick 4 unique traits
            random.shuffle(traits)
            traits = traits[:4]

            # Find matching faction
            faction_link = None
            faction_pref = template["faction_preference"]
            for faction in factions:
                if faction_pref in faction["name"].lower():
                    faction_link = faction["name"]
                    break

            # If no match, use a random faction or None
            if not faction_link and factions:
                faction_link = factions[random.randint(0, len(factions) - 1)]["name"]

            # Generate a culturally appropriate name
            name = self._generate_advisor_name(cultural_focus, era, template["role_key"])

            # Generate dialogue sample based on role and culture
            dialogue = self._generate_advisor_dialogue(role, cultural_focus, traits)

            character = {
                "name": name,
                "role": role,
                "faction_link": faction_link,
                "personality_traits": traits,
                "dialogue_sample": dialogue,
                "history": [f"Appointed to the council as {role}."],
                "metrics": {
                    "relationship": random.randint(45, 55),
                    "influence": random.randint(40, 70),
                    "loyalty": random.randint(55, 75)
                },
                "portrait": "placeholder.png"
            }
            characters.append(character)

        return characters

    def _generate_advisor_name(self, cultural_focus, era, role_key):
        """Generate a culturally appropriate advisor name."""
        # Name pools based on cultural focus
        name_pools = {
            "martial": {
                "male": ["Theron", "Kaelen", "Marcus", "Gorak", "Brutus", "Ragnar", "Sigurd", "Ajax"],
                "female": ["Athena", "Valeria", "Brienne", "Astrid", "Cassandra", "Freya", "Hippolyta"]
            },
            "spiritual": {
                "male": ["Zephyr", "Elias", "Aurelius", "Soren", "Alaric", "Caelum", "Thaddeus"],
                "female": ["Seraphina", "Lyra", "Celestia", "Miriam", "Isolde", "Vesta", "Aria"]
            },
            "agricultural": {
                "male": ["Gareth", "Alden", "Borin", "Cedric", "Ewan", "Jasper", "Thorne"],
                "female": ["Ceres", "Flora", "Autumn", "Gaia", "Hazel", "Ivy", "Rowan"]
            },
            "mercantile": {
                "male": ["Lorenzo", "Darius", "Cassius", "Lucien", "Marcellus", "Silvio", "Titus"],
                "female": ["Portia", "Octavia", "Lavinia", "Aurelia", "Livia", "Cordelia", "Emilia"]
            },
            "scholarly": {
                "male": ["Ptolemy", "Archimedes", "Cyrus", "Thales", "Plato", "Solon", "Pytheas"],
                "female": ["Hypatia", "Minerva", "Aspasia", "Diotima", "Eudocia", "Theano", "Arete"]
            },
            "artistic": {
                "male": ["Apollo", "Orpheus", "Lysander", "Thalia", "Perseus", "Damon", "Leander"],
                "female": ["Calliope", "Clio", "Erato", "Melpomene", "Sappho", "Terpsichore", "Urania"]
            }
        }

        # Get appropriate name pool
        pool = name_pools.get(cultural_focus, name_pools["spiritual"])

        # Determine gender based on role (mix of male/female)
        gender = random.choice(["male", "female"])

        # Select name
        first_name = random.choice(pool[gender])

        # Add title based on role
        titles_by_role = {
            "military": ["the Valiant", "the Shield", "Ironfist", "the Unyielding", "Stormborn", "the Defender"],
            "intelligence": ["the Shadow", "the Whisper", "Silvertongue", "the Watcher", "the Veiled", "Nighteye"],
            "spiritual": ["the Blessed", "the Seer", "Lightbearer", "the Faithful", "Stargazer", "the Pure"]
        }

        title_pool = titles_by_role.get(role_key, ["the Wise"])
        title = random.choice(title_pool)

        return f"{first_name} {title}"

    def _generate_advisor_dialogue(self, role, cultural_focus, traits):
        """Generate a sample dialogue line that reflects the advisor's role and personality."""
        # Dialogue templates based on role and culture
        dialogue_templates = {
            "military": {
                "martial": [
                    "Strength is the only currency that matters on the battlefield.",
                    "A sharp blade and sharper mind win wars.",
                    "Our warriors must be ready to strike at a moment's notice."
                ],
                "spiritual": [
                    "The gods favor those who fight with honor.",
                    "Our armies must be blessed before they march.",
                    "Victory comes to the righteous, not merely the strong."
                ],
                "agricultural": [
                    "Protect the harvest, protect the people.",
                    "A strong defense ensures our fields remain fertile.",
                    "Our warriors are shepherds of peace, not wolves of war."
                ],
                "mercantile": [
                    "Military might secures profitable trade routes.",
                    "A merchant's coin is worth nothing without a soldier's sword.",
                    "Strategic positioning is as valuable as gold."
                ],
                "scholarly": [
                    "Knowledge of terrain and tactics wins battles.",
                    "Study our enemies before we engage them.",
                    "Military science is an art form unto itself."
                ],
                "artistic": [
                    "There is beauty in the perfect formation.",
                    "War is a terrible art, but art nonetheless.",
                    "Our banners shall inspire both fear and awe."
                ]
            },
            "intelligence": {
                "martial": [
                    "Information is the first casualty of war‚Äîand our greatest weapon.",
                    "Know your enemy before they know themselves.",
                    "Every secret is a dagger waiting to be wielded."
                ],
                "spiritual": [
                    "The spirits reveal truths to those who listen.",
                    "Not all battles are fought with steel, my lord.",
                    "Hidden knowledge is sacred knowledge."
                ],
                "agricultural": [
                    "Even the smallest rumor can blight a harvest.",
                    "Patience and observation yield the ripest fruit.",
                    "Trust must be cultivated like any crop."
                ],
                "mercantile": [
                    "Information is a currency more valuable than gold.",
                    "Every transaction reveals something about the buyer.",
                    "The market whispers secrets to those who listen."
                ],
                "scholarly": [
                    "Knowledge without discretion is dangerous.",
                    "I study what others dare not speak aloud.",
                    "The archive of secrets grows daily."
                ],
                "artistic": [
                    "Deception is an art, and I am its master.",
                    "Every lie must be beautiful to be believed.",
                    "The truth is canvas; manipulation is the brush."
                ]
            },
            "spiritual": {
                "martial": [
                    "The gods demand strength in body and spirit.",
                    "Pray for victory, prepare for battle.",
                    "Our faith is our armor."
                ],
                "spiritual": [
                    "May the divine light guide your path.",
                    "The spirits speak‚Äîwe must listen.",
                    "Faith is the foundation of all things."
                ],
                "agricultural": [
                    "As we sow, so shall we reap‚Äîin this life and the next.",
                    "The earth is sacred, and we its humble stewards.",
                    "Give thanks for the harvest, for it is blessed."
                ],
                "mercantile": [
                    "Prosperity flows from divine favor.",
                    "The gods smile upon fair trade and honest dealings.",
                    "Wealth without virtue is worthless."
                ],
                "scholarly": [
                    "Wisdom and faith are two paths to the same truth.",
                    "The divine mysteries are written in ancient texts.",
                    "Knowledge of the sacred is the highest knowledge."
                ],
                "artistic": [
                    "Beauty is the divine made manifest.",
                    "Our ceremonies are poems written in ritual.",
                    "The gods appreciate elegance as much as devotion."
                ]
            }
        }

        # Determine role category
        role_category = "military"
        if "spy" in role.lower() or "whisper" in role.lower() or "eyes" in role.lower() or "secret" in role.lower() or "scout" in role.lower():
            role_category = "intelligence"
        elif "priest" in role.lower() or "shaman" in role.lower() or "cleric" in role.lower() or "hierophant" in role.lower():
            role_category = "spiritual"

        # Get appropriate dialogue pool
        dialogue_pool = dialogue_templates.get(role_category, {}).get(cultural_focus, [])

        # If no specific dialogue, use generic
        if not dialogue_pool:
            dialogue_pool = [
                "I serve at your pleasure, my lord.",
                "My counsel is yours to consider.",
                "Together, we shall guide our people to greatness."
            ]

        return random.choice(dialogue_pool)

    def _generate_leader_name(self):
        """Generate a random leader name."""
        first_names = [
            "Anya", "Kael", "Theron", "Lyra", "Darius", "Mira", "Orin", "Sera",
            "Aldric", "Elara", "Bran", "Nyx", "Finn", "Rhea", "Cassius", "Aria"
        ]
        titles = [
            "the Wise", "the Bold", "the Just", "the Strong", "the Seer",
            "the Builder", "the Diplomat", "the Warrior", "the Keeper", "the Guide"
        ]

        return f"{random.choice(first_names)}, {random.choice(titles)}"

    def generate(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Generate complete fantasy world."""
        # Generate all components
        civilization = self.generate_civilization(config)
        culture = self.generate_culture(config)
        religion = self.generate_religion(config)
        technology = self.generate_technology(config)
        world_context = self.generate_world_context(config)
        factions = self.generate_factions(config.get('starting_era', 'bronze_age'), config)
        inner_circle = self.generate_inner_circle(config, factions)

        return {
            'civilization': civilization,
            'culture': culture,
            'religion': religion,
            'technology': technology,
            'world': world_context,
            'history_long': {"events": []},
            'history_compressed': {"eras": []},
            'factions': {"factions": factions},
            'inner_circle': {"characters": inner_circle}
        }



################################################################################
# FILE: old_codebase\engines\world_modes\historical_earth_mode.py
# Size: 40538 bytes
################################################################################

"""
Historical Earth Mode

This mode provides historical Earth simulation with realistic geography, cultures,
and the ability to diverge from history through player actions (butterfly effects).

Features:
- Stone Age/Bronze Age/Iron Age starts: Butterfly effect mode with proto-civilizations
- Classical+ era starts: Historical factions (Rome, Greece, etc.) in proper regions
- All player actions tracked against historical expectations
- Timeline divergence scoring and alternate timeline naming
"""

import random
from typing import Dict, List, Any, Optional
from engines.world_modes.base_mode import WorldMode


class ButterflyEffectTracker:
    """Tracks divergences from historical timeline and measures impact."""

    def __init__(self, starting_era: str, starting_year: int):
        """
        Initialize the butterfly effect tracker.

        Args:
            starting_era: The era the game starts in
            starting_year: The specific year the game starts
        """
        self.starting_era = starting_era
        self.starting_year = starting_year
        self.divergence_score = 0  # 0 = historical, 100 = completely altered
        self.key_divergences = []
        self.timeline_altered = False

    def track_action(self, year: int, action: str, historical_expected: Optional[str] = None, impact: int = 5):
        """
        Track a player action and its divergence from history.

        Args:
            year: The year the action occurred
            action: Description of the action taken
            historical_expected: What historically should have happened (if known)
            impact: Divergence impact score (1-20, default 5)
        """
        divergence_entry = {
            "year": year,
            "action": action,
            "historical_path": historical_expected,
            "impact": impact
        }

        self.divergence_score = min(100, self.divergence_score + impact)
        self.key_divergences.append(divergence_entry)
        self.timeline_altered = True

    def get_timeline_name(self) -> str:
        """
        Generate a name for the current timeline based on divergence level.

        Returns:
            Timeline classification string
        """
        if self.divergence_score < 10:
            return "Historical Timeline (Minor Variations)"
        elif self.divergence_score < 30:
            return "Slightly Divergent Timeline"
        elif self.divergence_score < 50:
            return "Alternate History Timeline"
        elif self.divergence_score < 75:
            return "Radically Divergent Timeline"
        else:
            return "Unrecognizable Future"

    def get_divergence_summary(self) -> Dict[str, Any]:
        """
        Get a summary of timeline divergence.

        Returns:
            Dictionary with divergence statistics
        """
        return {
            "divergence_score": self.divergence_score,
            "timeline_name": self.get_timeline_name(),
            "key_divergences": self.key_divergences[-5:],  # Last 5 major divergences
            "total_divergences": len(self.key_divergences),
            "timeline_altered": self.timeline_altered
        }


class HistoricalEarthMode(WorldMode):
    """Historical Earth world generation mode with realistic geography and factions."""

    # Historical ERA configurations with accurate dates
    ERA_CONFIGS = {
        "stone_age": {
            "era": "stone_age",
            "year_range": (-10000, -3000),
            "tech_tier": "stone_age",
            "base_discoveries": ["Fire", "Stone Tools", "Spears", "Basic Agriculture", "Pottery"],
            "base_infrastructure": ["Central Hearth", "Temporary Shelters", "Food Storage"],
            "population_multiplier": 0.5,
            "historical_context": "Neolithic Revolution - transition from hunter-gatherers to agricultural settlements",
            "butterfly_effects_enabled": True
        },
        "bronze_age": {
            "era": "bronze_age",
            "year_range": (-3000, -1200),
            "tech_tier": "bronze_age",
            "base_discoveries": ["Fire", "Stone Tools", "Spears", "Basic Agriculture", "Pottery", "Bronze Casting", "Writing", "Wheel"],
            "base_infrastructure": ["Central Hearth", "Permanent Dwellings", "Granaries", "Defensive Walls"],
            "population_multiplier": 1.0,
            "historical_context": "Rise of early civilizations (Sumer, Egypt, Indus Valley, Early China)",
            "butterfly_effects_enabled": True
        },
        "iron_age": {
            "era": "iron_age",
            "year_range": (-1200, -500),
            "tech_tier": "iron_age",
            "base_discoveries": ["Fire", "Stone Tools", "Bronze Casting", "Writing", "Wheel", "Iron Smelting", "Advanced Agriculture", "Sea Navigation"],
            "base_infrastructure": ["Permanent Dwellings", "Granaries", "Stone Walls", "Watchtowers", "Workshop"],
            "population_multiplier": 1.5,
            "historical_context": "Bronze Age Collapse, rise of iron-using civilizations, Phoenician trade networks",
            "butterfly_effects_enabled": True
        },
        "classical": {
            "era": "classical",
            "year_range": (-500, 500),
            "tech_tier": "classical",
            "base_discoveries": ["Fire", "Bronze Casting", "Writing", "Wheel", "Iron Smelting", "Advanced Agriculture", "Philosophy", "Engineering", "Currency"],
            "base_infrastructure": ["Urban Centers", "Aqueducts", "Roads", "Temples", "Marketplace", "Fortifications"],
            "population_multiplier": 2.0,
            "historical_context": "Height of Classical civilizations: Greece, Rome, Han China, Maurya India",
            "historical_factions_enabled": True
        }
    }

    # Earth geographic regions with realistic details
    EARTH_REGIONS = {
        "mediterranean": {
            "region_name": "Mediterranean Basin",
            "terrain": "Coastal regions with rolling hills, fertile valleys, and rugged mountains",
            "climate": "Mediterranean - hot dry summers, mild wet winters",
            "resources": ["Fish", "Olive oil", "Grain", "Wine", "Marble", "Timber", "Copper", "Tin"],
            "threats": ["Rival city-states", "Pirates", "Earthquakes", "Periodic droughts"],
            "historical_neighbors": {
                "stone_age": ["Proto-European tribes", "Early Anatolian peoples"],
                "bronze_age": ["Minoan traders", "Early Helladic peoples", "Anatolian tribes"],
                "iron_age": ["Phoenician merchants", "Early Greek colonies", "Etruscan traders"],
                "classical": ["Greek City-States", "Roman Republic", "Carthaginian Empire", "Hellenistic Kingdoms"]
            },
            "lat_long": (40, 15),  # Approximate center
            "description": "The cradle of Western civilization, where empires rise and fall like the tides"
        },
        "mesopotamia": {
            "region_name": "Mesopotamia",
            "terrain": "Fertile river valleys between the Tigris and Euphrates, surrounded by arid steppes",
            "climate": "Arid subtropical - extremely hot summers, seasonal floods",
            "resources": ["Grain", "Date palms", "Clay", "Fish", "Reeds", "Limited timber"],
            "threats": ["Unpredictable flooding", "Summertime heat", "Invasions from the north", "Resource scarcity"],
            "historical_neighbors": {
                "stone_age": ["Early Ubaid people", "Proto-Sumerian tribes"],
                "bronze_age": ["Sumerian city-states", "Akkadian Empire", "Babylonian Kingdom"],
                "iron_age": ["Assyrian Empire", "Babylonian Empire", "Median tribes"],
                "classical": ["Persian Empire", "Parthian Empire", "Seleucid Dynasty"]
            },
            "lat_long": (33, 44),
            "description": "The fertile crescent, birthplace of writing, law, and urban civilization"
        },
        "nile_valley": {
            "region_name": "Nile River Valley",
            "terrain": "Narrow fertile corridor along the Nile, surrounded by vast deserts",
            "climate": "Hot desert - scorching summers, predictable annual floods",
            "resources": ["Grain", "Papyrus", "Fish", "Gold", "Stone", "Natron", "Linen"],
            "threats": ["Desert raiders", "Flooding extremes", "Scorching heat", "Limited arable land"],
            "historical_neighbors": {
                "stone_age": ["Early Saharan peoples", "Proto-Egyptians"],
                "bronze_age": ["Nubian kingdoms", "Libyan tribes", "Canaanite traders"],
                "iron_age": ["Nubian Kingdom of Kush", "Libyan dynasties", "Sea Peoples"],
                "classical": ["Ptolemaic Egypt", "Nubian Meroitic Kingdom", "Roman Egypt"]
            },
            "lat_long": (26, 32),
            "description": "The gift of the Nile, where pharaohs reign and monuments touch eternity"
        },
        "yellow_river": {
            "region_name": "Yellow River Valley",
            "terrain": "Loess plateau with fertile river valley, surrounded by mountains and steppes",
            "climate": "Continental - harsh cold winters, hot humid summers",
            "resources": ["Millet", "Rice", "Silk", "Jade", "Bronze", "Bamboo", "Tea"],
            "threats": ["Devastating floods", "Droughts", "Nomadic invasions from the north", "Earthquakes"],
            "historical_neighbors": {
                "stone_age": ["Yangshao culture tribes", "Early agricultural communities"],
                "bronze_age": ["Shang Dynasty", "Various Neolithic cultures"],
                "iron_age": ["Zhou Dynasty states", "Nomadic Xiongnu"],
                "classical": ["Warring States", "Qin Dynasty", "Han Dynasty", "Xiongnu Confederation"]
            },
            "lat_long": (35, 110),
            "description": "Cradle of Chinese civilization, where dynasties rise under the Mandate of Heaven"
        },
        "indus_valley": {
            "region_name": "Indus River Valley",
            "terrain": "Broad river valley with fertile plains, bordered by mountains and desert",
            "climate": "Subtropical - monsoon rains, hot dry season",
            "resources": ["Grain", "Cotton", "Precious stones", "Timber", "Copper", "Carnelian"],
            "threats": ["Monsoon flooding", "River course changes", "Periodic droughts", "Mountain tribes"],
            "historical_neighbors": {
                "stone_age": ["Mehrgarh culture peoples", "Early pastoralists"],
                "bronze_age": ["Harappan civilization", "Indo-Aryan migrants"],
                "iron_age": ["Mahajanapadas", "Indo-Aryan kingdoms"],
                "classical": ["Maurya Empire", "Indo-Greek Kingdoms", "Kushan Empire", "Gupta Dynasty"]
            },
            "lat_long": (27, 70),
            "description": "Land of ancient cities and sacred rivers, where philosophy and trade flourish"
        }
    }

    # Historical faction templates for Classical era
    HISTORICAL_FACTIONS = {
        "classical_rome": {
            "civilization_name": "Roman Republic",
            "leader_name": "Consul Marcus Aurelius Cato",
            "factions": [
                {
                    "name": "The Senate",
                    "leader": "Senator Lucius Cornelius",
                    "approval": 60,
                    "support_percentage": 30,
                    "status": "Neutral",
                    "goals": ["Maintain patrician privileges", "Expand Roman territory", "Preserve republican institutions"],
                    "description": "The aristocratic body that has guided Rome since its founding"
                },
                {
                    "name": "The Plebeian Assembly",
                    "leader": "Tribune Gaius Gracchus",
                    "approval": 55,
                    "support_percentage": 35,
                    "status": "Neutral",
                    "goals": ["Land redistribution for veterans", "Debt relief", "Greater political representation"],
                    "description": "Representatives of the common people, demanding reform and equality"
                },
                {
                    "name": "The Legates",
                    "leader": "General Scipio Africanus",
                    "approval": 65,
                    "support_percentage": 25,
                    "status": "Supportive",
                    "goals": ["Military expansion", "Glory in battle", "Veterans' settlements"],
                    "description": "Military commanders who have conquered distant lands for Rome"
                },
                {
                    "name": "The College of Pontiffs",
                    "leader": "Pontifex Maximus Quintus",
                    "approval": 60,
                    "support_percentage": 10,
                    "status": "Neutral",
                    "goals": ["Maintain traditional Roman religion", "Interpret divine omens", "Preserve sacred rituals"],
                    "description": "Keepers of Roman religious tradition and sacred law"
                }
            ]
        },
        "classical_greece": {
            "civilization_name": "Athenian Polis",
            "leader_name": "Archon Pericles",
            "factions": [
                {
                    "name": "The Ecclesia",
                    "leader": "Citizen Demosthenes",
                    "approval": 60,
                    "support_percentage": 40,
                    "status": "Neutral",
                    "goals": ["Strengthen democracy", "Naval supremacy", "Cultural excellence"],
                    "description": "The democratic assembly of all citizens, voice of the people"
                },
                {
                    "name": "The Strategoi",
                    "leader": "General Themistocles",
                    "approval": 65,
                    "support_percentage": 25,
                    "status": "Supportive",
                    "goals": ["Defeat Persian threats", "Train hoplites", "Build the navy"],
                    "description": "Military leaders elected to defend Athens and lead her armies"
                },
                {
                    "name": "The Oracle of Delphi",
                    "leader": "Pythia Cassandra",
                    "approval": 60,
                    "support_percentage": 15,
                    "status": "Neutral",
                    "goals": ["Interpret divine will", "Maintain sacred sites", "Guide policy through prophecy"],
                    "description": "Priestesses who channel the wisdom of Apollo himself"
                },
                {
                    "name": "The Merchant League",
                    "leader": "Lysias of Piraeus",
                    "approval": 55,
                    "support_percentage": 20,
                    "status": "Neutral",
                    "goals": ["Expand trade networks", "Establish colonies", "Protect shipping lanes"],
                    "description": "Wealthy traders who bring prosperity from across the Mediterranean"
                }
            ]
        },
        "classical_carthage": {
            "civilization_name": "Carthaginian Republic",
            "leader_name": "Suffete Hamilcar Barca",
            "factions": [
                {
                    "name": "The Council of Elders",
                    "leader": "Elder Hanno the Great",
                    "approval": 60,
                    "support_percentage": 30,
                    "status": "Neutral",
                    "goals": ["Maintain commercial dominance", "Avoid costly wars", "Preserve oligarchic rule"],
                    "description": "Wealthy merchant princes who have governed Carthage for generations"
                },
                {
                    "name": "The Barcid Faction",
                    "leader": "General Hannibal Barca",
                    "approval": 70,
                    "support_percentage": 35,
                    "status": "Supportive",
                    "goals": ["Defeat Rome", "Conquer Iberia", "Military glory"],
                    "description": "Military dynasty seeking to restore Carthaginian power through conquest"
                },
                {
                    "name": "The Sacred Band",
                    "leader": "Commander Mago",
                    "approval": 60,
                    "support_percentage": 20,
                    "status": "Neutral",
                    "goals": ["Defend the city", "Train elite warriors", "Maintain honor"],
                    "description": "Elite citizen soldiers sworn to defend Carthage to the death"
                },
                {
                    "name": "The Priesthood of Tanit",
                    "leader": "High Priestess Sophonisba",
                    "approval": 55,
                    "support_percentage": 15,
                    "status": "Neutral",
                    "goals": ["Maintain religious traditions", "Perform sacred rites", "Seek divine favor"],
                    "description": "Servants of the goddess Tanit, protector of Carthage"
                }
            ]
        }
    }

    # Cultural templates adapted for historical realism
    CULTURE_TEMPLATES = {
        "martial": {
            "values": ["Strength", "Courage", "Honor", "Discipline", "Loyalty"],
            "sample_traditions": ["Warrior Initiations", "Battle Commemorations", "Weapon Crafting Ceremonies"],
            "traits": ["Aggressive", "Disciplined", "Territorial"]
        },
        "spiritual": {
            "values": ["Wisdom", "Devotion", "Harmony", "Respect for Spirits", "Ritual"],
            "sample_traditions": ["Seasonal Rituals", "Spirit Offerings", "Sacred Pilgrimages"],
            "traits": ["Contemplative", "Mystical", "Ritualistic"]
        },
        "agricultural": {
            "values": ["Hard Work", "Community", "Harvest", "Patience", "Sustainability"],
            "sample_traditions": ["Planting Festivals", "Harvest Celebrations", "Crop Rotation Rituals"],
            "traits": ["Patient", "Cooperative", "Grounded"]
        },
        "mercantile": {
            "values": ["Trade", "Prosperity", "Diplomacy", "Innovation", "Fairness"],
            "sample_traditions": ["Market Days", "Trade Agreements", "Merchant Guilds"],
            "traits": ["Diplomatic", "Shrewd", "Cosmopolitan"]
        },
        "scholarly": {
            "values": ["Knowledge", "Curiosity", "Innovation", "Record-Keeping", "Teaching"],
            "sample_traditions": ["Oral Storytelling", "Star Gazing Ceremonies", "Knowledge Sharing Gatherings"],
            "traits": ["Inquisitive", "Methodical", "Inventive"]
        },
        "artistic": {
            "values": ["Beauty", "Expression", "Creativity", "Tradition", "Excellence"],
            "sample_traditions": ["Art Festivals", "Craftsmanship Competitions", "Performance Rituals"],
            "traits": ["Creative", "Expressive", "Detail-Oriented"]
        }
    }

    # Religion configurations for historical mode
    RELIGION_CONFIGS = {
        "animism": {
            "name": "Animism",
            "type": "Spirit Worship",
            "tenets": ["All things have a spirit", "The natural world must be respected", "Balance must be maintained"],
            "practices": ["Shamanic rituals", "Spirit offerings", "Nature veneration"]
        },
        "polytheism": {
            "name": "Polytheism",
            "type": "Multiple Deities",
            "tenets": ["The gods influence all aspects of life", "Each deity governs their domain", "Offerings bring favor"],
            "practices": ["Temple rituals", "Sacrificial offerings", "Divine festivals"]
        },
        "ancestor_worship": {
            "name": "Ancestor Veneration",
            "type": "Ancestor Worship",
            "tenets": ["The ancestors watch over us", "Honor the dead to prosper", "Lineage is sacred"],
            "practices": ["Ancestral offerings", "Tomb maintenance", "Genealogy keeping"]
        }
    }

    SOCIAL_STRUCTURES = {
        "egalitarian": "Egalitarian community where decisions are made collectively",
        "hierarchical": "Hierarchical society with clear social ranks",
        "tribal_council": "Tribal council of elders and skilled leaders",
        "city_state": "City-state with assembly and elected officials",
        "monarchy": "Hereditary monarchy with a ruling dynasty",
        "republic": "Republic with elected representatives",
        "theocracy": "Religious leaders hold temporal power"
    }

    def __init__(self):
        """Initialize the Historical Earth mode."""
        self.butterfly_tracker: Optional[ButterflyEffectTracker] = None

    def get_era_configs(self) -> Dict[str, Dict[str, Any]]:
        return self.ERA_CONFIGS

    def get_terrain_configs(self) -> Dict[str, Dict[str, Any]]:
        return self.EARTH_REGIONS

    def get_culture_templates(self) -> Dict[str, Dict[str, Any]]:
        return self.CULTURE_TEMPLATES

    def get_religion_configs(self) -> Dict[str, Dict[str, Any]]:
        return self.RELIGION_CONFIGS

    def get_social_structures(self) -> Dict[str, Dict[str, Any]]:
        return self.SOCIAL_STRUCTURES

    def get_starting_year(self, era: str) -> int:
        era_config = self.ERA_CONFIGS.get(era, self.ERA_CONFIGS["bronze_age"])
        year_min, year_max = era_config["year_range"]
        return random.randint(year_min, year_max)

    def generate_civilization(self, config: Dict[str, Any]) -> Dict[str, Any]:
        era = config.get("starting_era", config.get("era", "bronze_age"))
        region = config.get("earth_region", "mediterranean")
        population_size = config.get("population_size", "medium")

        era_config = self.ERA_CONFIGS[era]
        region_config = self.EARTH_REGIONS.get(region, self.EARTH_REGIONS["mediterranean"])

        # Check if we should use historical factions
        use_historical = era_config.get("historical_factions_enabled", False)

        if use_historical and era == "classical":
            # Use historical civilization name
            if region == "mediterranean":
                faction_template = random.choice(["classical_rome", "classical_greece"])
            else:
                faction_template = "classical_rome"  # Default for now

            historical_data = self.HISTORICAL_FACTIONS.get(faction_template, self.HISTORICAL_FACTIONS["classical_rome"])
            civ_name = historical_data["civilization_name"]
            leader_name = historical_data["leader_name"]
        else:
            # Proto-civilization for early eras
            civ_name = config.get("civilization_name", f"The {region_config['region_name']} People")
            leader_name = config.get("leader_name", self._generate_historical_name(region, era))

        # Population calculation
        pop_ranges = {
            "small": (100, 500),
            "medium": (500, 2000),
            "large": (2000, 5000)
        }
        pop_min, pop_max = pop_ranges[population_size]
        population = random.randint(
            int(pop_min * era_config["population_multiplier"]),
            int(pop_max * era_config["population_multiplier"])
        )

        # Year calculation
        year = self.get_starting_year(era)

        # Initialize butterfly tracker for early eras
        if era_config.get("butterfly_effects_enabled", False):
            self.butterfly_tracker = ButterflyEffectTracker(era, year)

        leader_traits = random.sample([
            "Wise", "Brave", "Diplomatic", "Strategic", "Charismatic",
            "Cautious", "Bold", "Pious", "Pragmatic", "Visionary"
        ], 3)

        return {
            "meta": {
                "name": civ_name,
                "year": year,
                "era": era_config["era"],
                "founding_date": year,
                "world_mode": "historical_earth",
                "earth_region": region,
                "butterfly_effects_enabled": era_config.get("butterfly_effects_enabled", False),
                "historical_factions_enabled": era_config.get("historical_factions_enabled", False)
            },
            "leader": {
                "name": leader_name,
                "age": random.randint(25, 45),
                "life_expectancy": random.randint(50, 70),  # Realistic for ancient times
                "role": "Leader",
                "traits": leader_traits,
                "years_ruled": 0
            },
            "population": population,
            "resources": {
                "food": population * random.randint(1, 3),
                "wealth": population * random.randint(1, 2),
                "tech_tier": era_config["tech_tier"]
            }
        }

    def generate_culture(self, config: Dict[str, Any]) -> Dict[str, Any]:
        cultural_focus = config.get("cultural_focus", "agricultural")
        social_structure = config.get("social_structure", "tribal_council")
        era = config.get("starting_era", "bronze_age")
        region = config.get("earth_region", "mediterranean")

        culture_template = self.CULTURE_TEMPLATES[cultural_focus]

        # Historical cultural elements based on region
        regional_values = {
            "mediterranean": ["Maritime Trade", "Urban Life", "Political Discourse"],
            "mesopotamia": ["Law and Order", "Written Records", "Irrigation Management"],
            "nile_valley": ["Divine Kingship", "Monumental Architecture", "Eternal Life"],
            "yellow_river": ["Filial Piety", "Ancestor Reverence", "Bureaucratic Order"],
            "indus_valley": ["Urban Planning", "Trade Networks", "Spiritual Wisdom"]
        }

        values = culture_template["values"].copy()
        values.extend(regional_values.get(region, ["Community", "Tradition"]))

        traditions = culture_template["sample_traditions"].copy()
        traditions.extend(random.sample([
            "Oral Storytelling", "Seasonal Celebrations", "Coming of Age Ceremonies",
            "Ancestral Veneration", "Crafting Competitions"
        ], 2))

        return {
            "values": values[:8],
            "traditions": traditions[:6],
            "taboos": ["Harming Kin", random.choice(["Breaking Oaths", "Sacrilege", "Betraying Trust"])],
            "social_structure": self.SOCIAL_STRUCTURES[social_structure],
            "recent_changes": []
        }

    def generate_religion(self, config: Dict[str, Any]) -> Dict[str, Any]:
        era = config.get("starting_era", "bronze_age")
        region = config.get("earth_region", "mediterranean")

        # Region-appropriate religions
        if era in ["stone_age", "bronze_age"]:
            religion_type = random.choice(["animism", "polytheism", "ancestor_worship"])
        else:
            religion_type = config.get("religion_type", "polytheism")

        religion_config = self.RELIGION_CONFIGS.get(religion_type, self.RELIGION_CONFIGS["polytheism"])

        # Region-specific deity names
        regional_deities = {
            "mediterranean": {
                "polytheism": ["The Olympian Gods", "The Divine Pantheon", "The Twelve Gods"],
                "animism": ["The Sea Spirits", "The Mountain Guardians"]
            },
            "mesopotamia": {
                "polytheism": ["The Anunnaki", "The Divine Assembly", "The Seven Who Decree Fate"],
                "animism": ["The River Spirits", "The Desert Gods"]
            },
            "nile_valley": {
                "polytheism": ["The Ennead of Heliopolis", "The Divine Order of Ra", "The Gods of the Two Lands"],
                "animism": ["The Nile Spirit", "The Desert Guardian"]
            },
            "yellow_river": {
                "polytheism": ["The Celestial Court", "The Heavenly Bureaucracy"],
                "ancestor_worship": ["The First Ancestors", "The Divine Emperors"]
            }
        }

        deity_options = regional_deities.get(region, {}).get(religion_type, ["The Great Spirit"])
        primary_deity = random.choice(deity_options)

        holy_sites = [
            f"The Sacred {random.choice(['Grove', 'Mountain', 'Temple', 'Spring'])}",
            f"The Ancient {random.choice(['Shrine', 'Monument', 'Altar', 'Cave'])}"
        ]

        return {
            "name": religion_config["name"],
            "type": religion_config["type"],
            "primary_deity": primary_deity,
            "core_tenets": religion_config["tenets"],
            "practices": religion_config["practices"],
            "holy_sites": holy_sites,
            "influence": random.choice(["dominant", "significant"]),
            "schisms": []
        }

    def generate_technology(self, config: Dict[str, Any]) -> Dict[str, Any]:
        era = config.get("starting_era", config.get("era", "bronze_age"))
        era_config = self.ERA_CONFIGS[era]

        return {
            "current_tier": era_config["tech_tier"],
            "discoveries": era_config["base_discoveries"].copy(),
            "in_progress": [],
            "infrastructure": era_config["base_infrastructure"].copy()
        }

    def generate_world_context(self, config: Dict[str, Any]) -> Dict[str, Any]:
        return self.generate_geography(config)

    def generate_geography(self, config: Dict[str, Any]) -> Dict[str, Any]:
        region = config.get("earth_region", "mediterranean")
        era = config.get("starting_era", "bronze_age")
        difficulty = config.get("difficulty", "balanced")

        region_config = self.EARTH_REGIONS[region]

        # Get era-appropriate neighbors
        neighbors_list = region_config["historical_neighbors"].get(era, [])

        # Generate neighbor relationships
        neighbors = []
        for neighbor_name in neighbors_list[:3]:  # Limit to 3 neighbors
            if difficulty == "peaceful":
                relationship = random.choice(["allied", "neutral", "friendly"])
            elif difficulty == "challenging":
                relationship = random.choice(["neutral", "wary", "hostile"])
            else:
                relationship = random.choice(["allied", "neutral", "wary"])

            neighbors.append({
                "name": neighbor_name,
                "relationship": relationship,
                "strength": "unknown",
                "distance": random.choice(["nearby", "several days journey", "distant"]),
                "history": f"Historical presence in the {region_config['region_name']}"
            })

        return {
            "known_peoples": neighbors,
            "geography": {
                "region": region_config["region_name"],
                "terrain": region_config["terrain"],
                "climate": region_config["climate"],
                "resources": region_config["resources"],
                "threats": region_config["threats"]
            }
        }

    def generate_factions(self, era: str, config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate appropriate factions based on era and region."""
        region = config.get("earth_region", "mediterranean")
        era_config = self.ERA_CONFIGS.get(era, self.ERA_CONFIGS["bronze_age"])

        # Use historical factions for Classical era
        if era_config.get("historical_factions_enabled", False) and era == "classical":
            if region == "mediterranean":
                faction_key = random.choice(["classical_rome", "classical_greece", "classical_carthage"])
            else:
                faction_key = "classical_rome"

            historical_data = self.HISTORICAL_FACTIONS.get(faction_key, self.HISTORICAL_FACTIONS["classical_rome"])
            return historical_data["factions"]

        # Generate proto-civilization factions for earlier eras
        return self._generate_proto_factions(era, region)

    def _generate_proto_factions(self, era: str, region: str) -> List[Dict[str, Any]]:
        """Generate factions for pre-classical eras."""
        # Era-appropriate faction types
        if era == "stone_age":
            faction_templates = [
                {"name": "The Hunter Band", "leader": "Chief Hunter", "focus": "hunting and gathering"},
                {"name": "The Elders' Circle", "leader": "Wise Elder", "focus": "tradition and wisdom"},
                {"name": "The Toolmakers", "leader": "Master Craftsman", "focus": "tool creation"},
                {"name": "The Spirit Speakers", "leader": "Shaman", "focus": "spiritual guidance"}
            ]
        elif era == "bronze_age":
            faction_templates = [
                {"name": "The Merchant Consortium", "leader": "Trade Master", "focus": "commerce"},
                {"name": "The Council of Elders", "leader": "High Elder", "focus": "tradition"},
                {"name": "The Warrior Lodge", "leader": "War Leader", "focus": "defense"},
                {"name": "The Temple Priests", "leader": "High Priest", "focus": "religion"}
            ]
        else:  # iron_age
            faction_templates = [
                {"name": "The Merchant Assembly", "leader": "Guild Master", "focus": "trade"},
                {"name": "The Senate of Elders", "leader": "First Senator", "focus": "governance"},
                {"name": "The Military Council", "leader": "General", "focus": "military"},
                {"name": "The Priesthood", "leader": "High Priest", "focus": "religion"}
            ]

        factions = []
        for template in faction_templates:
            factions.append({
                "name": template["name"],
                "leader": template["leader"],
                "approval": random.randint(55, 65),
                "support_percentage": random.randint(20, 30),
                "status": "Neutral",
                "goals": [
                    f"Advance {template['focus']}",
                    "Increase influence",
                    "Secure resources"
                ]
            })

        return factions

    def generate_inner_circle(self, config: Dict[str, Any], factions: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Generate inner circle advisors appropriate for the era and region."""
        era = config.get("starting_era", "bronze_age")
        region = config.get("earth_region", "mediterranean")
        cultural_focus = config.get("cultural_focus", "agricultural")

        # Role templates adapted for historical context
        role_templates = [
            {
                "role_key": "military",
                "roles": {
                    "stone_age": "War Chief",
                    "bronze_age": "Commander",
                    "iron_age": "General",
                    "classical": "Strategos"
                },
                "base_traits": ["Disciplined", "Strategic", "Brave"],
                "faction_preference": "warrior"
            },
            {
                "role_key": "advisor",
                "roles": {
                    "stone_age": "Wise Elder",
                    "bronze_age": "Chief Advisor",
                    "iron_age": "Chancellor",
                    "classical": "Chief Minister"
                },
                "base_traits": ["Wise", "Diplomatic", "Cautious"],
                "faction_preference": "elder"
            },
            {
                "role_key": "spiritual",
                "roles": {
                    "stone_age": "Shaman",
                    "bronze_age": "High Priest",
                    "iron_age": "Chief Priest",
                    "classical": "Pontifex"
                },
                "base_traits": ["Pious", "Contemplative", "Influential"],
                "faction_preference": "priest"
            }
        ]

        characters = []
        for template in role_templates:
            role = template["roles"].get(era, template["roles"]["bronze_age"])
            traits = template["base_traits"].copy()

            # Find matching faction
            faction_link = None
            for faction in factions:
                if any(keyword in faction["name"].lower() for keyword in [template["faction_preference"], "warrior", "elder", "priest", "temple"]):
                    faction_link = faction["name"]
                    break

            if not faction_link and factions:
                faction_link = factions[0]["name"]

            name = self._generate_historical_name(region, era)

            character = {
                "name": name,
                "role": role,
                "faction_link": faction_link,
                "personality_traits": traits,
                "dialogue_sample": f"I serve our people with {traits[0].lower()} dedication.",
                "history": [f"Appointed as {role}."],
                "metrics": {
                    "relationship": random.randint(45, 60),
                    "influence": random.randint(40, 70),
                    "loyalty": random.randint(55, 75)
                },
                "portrait": "placeholder.png"
            }
            characters.append(character)

        return characters

    def _generate_historical_name(self, region: str, era: str) -> str:
        """Generate historically appropriate names based on region."""
        # Regional name pools
        names = {
            "mediterranean": {
                "male": ["Marcus", "Lucius", "Gaius", "Titus", "Pericles", "Themistocles", "Alcibiades"],
                "female": ["Julia", "Cornelia", "Livia", "Aspasia", "Artemisia"]
            },
            "mesopotamia": {
                "male": ["Hammurabi", "Sargon", "Gilgamesh", "Nabonidus", "Ashurbanipal"],
                "female": ["Enheduanna", "Semiramis", "Puabi"]
            },
            "nile_valley": {
                "male": ["Ramesses", "Thutmose", "Amenhotep", "Khufu", "Imhotep"],
                "female": ["Nefertiti", "Hatshepsut", "Cleopatra", "Nefertari"]
            },
            "yellow_river": {
                "male": ["Qin", "Liu", "Wang", "Zhang", "Chen"],
                "female": ["Wu", "Li", "Wang", "Chen"]
            },
            "indus_valley": {
                "male": ["Chandragupta", "Ashoka", "Vikramaditya"],
                "female": ["Draupadi", "Sita"]
            }
        }

        region_names = names.get(region, names["mediterranean"])
        gender = random.choice(["male", "female"])
        name = random.choice(region_names[gender])

        titles = ["the Great", "the Wise", "the Builder", "the Just", "the Bold"]
        return f"{name} {random.choice(titles)}"

    def generate(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Generate complete historical Earth world."""
        civilization = self.generate_civilization(config)
        culture = self.generate_culture(config)
        religion = self.generate_religion(config)
        technology = self.generate_technology(config)
        world_context = self.generate_world_context(config)
        factions = self.generate_factions(config.get('starting_era', 'bronze_age'), config)
        inner_circle = self.generate_inner_circle(config, factions)

        # Store butterfly tracker reference if it exists
        if self.butterfly_tracker:
            civilization['meta']['butterfly_tracker'] = self.butterfly_tracker.get_divergence_summary()

        return {
            'civilization': civilization,
            'culture': culture,
            'religion': religion,
            'technology': technology,
            'world': world_context,
            'history_long': {"events": []},
            'history_compressed': {"eras": []},
            'factions': {"factions": factions},
            'inner_circle': {"characters": inner_circle}
        }



################################################################################
# FILE: old_codebase\engines\world_turns_engine.py
# Size: 6251 bytes
################################################################################

import json
from json import JSONDecodeError
import google.generativeai as genai
from model_config import TEXT_MODEL
from engines.bonus_engine import BonusEngine
from engines.bonus_definitions import BonusType

class WorldTurnsEngine:
    def calculate_rates_with_bonus_engine(self, game_state):
        """
        NEW: Calculate resource rates using BonusEngine.
        Runs in parallel with old logic for verification.
        """
        population = game_state.civilization['population']
        happiness = game_state.population_happiness

        # Use bonus engine for character bonuses
        bonus_engine = BonusEngine()
        science_bonuses = bonus_engine.calculate_bonuses(game_state, BonusType.SCIENCE_PER_TURN)
        culture_bonuses = bonus_engine.calculate_bonuses(game_state, BonusType.CULTURE_PER_TURN)

        # BALANCE_OVERHAUL: Happiness affects productivity with tiered penalties
        if happiness >= 70:
            happiness_multiplier = 1.0
        elif happiness >= 50:
            happiness_multiplier = 0.75  # -25% penalty
        elif happiness >= 30:
            happiness_multiplier = 0.60  # -40% penalty
        else:
            happiness_multiplier = 0.50  # -50% penalty (severe unrest)

        # Calculate rates with happiness multiplier
        science_per_turn = ((population / 1000) * (happiness / 100) + science_bonuses['total']) * happiness_multiplier
        culture_per_turn = ((population / 1000) * (happiness / 100) + culture_bonuses['total']) * happiness_multiplier

        return {
            'science': science_per_turn,
            'culture': culture_per_turn,
            'science_sources': science_bonuses['sources'],
            'culture_sources': culture_bonuses['sources']
        }

    def simulate_turn(self, game_state, last_action_details):
        """
        Calculates the resource rates for a turn based on the current game state.
        """
        # Calculate resource rates using BonusEngine
        rates = self.calculate_rates_with_bonus_engine(game_state)
        science_per_turn = rates['science']
        culture_per_turn = rates['culture']

        # Check if this was a council meeting
        is_council = last_action_details.get('event_type') == 'council_meeting'

        # Construct AI prompt for world changes
        game_state_json = json.dumps(game_state.to_dict(), indent=2)

        if is_council:
            # COUNCIL MEETING: Analyze conversation to determine advisor reactions
            conversation = last_action_details.get('conversation', [])
            conv_text = "\n".join([
                f"Player: {entry['player']}\nAdvisor Response: {entry['ai']}"
                for entry in conversation
            ])

            ai_prompt = f"""
Given the current game state:
{game_state_json}

And this COUNCIL MEETING conversation:
{conv_text}

Player's final decision: {last_action_details['action']}
Outcome: {last_action_details['outcome']}

Analyze the DIALOGUE CHOICES the player made during the council meeting. Determine how each Inner Circle advisor would react based on:
- Whether the player agreed with their position
- Whether the final decision aligned with their stance
- The tone of the player's questions/responses to them

Generate balanced inner_circle_updates with:
- Advisors aligned with player's choices: +3 to +8 loyalty/opinion_change
- Advisors opposed by player's choices: -3 to -8 loyalty/opinion_change
- Include a brief "memory" of this council meeting for each advisor

Also determine faction and neighboring civilization reactions.

Your response must be a valid JSON object with the following structure:
{{
  "faction_updates": [
    {{
      "name": "string",
      "approval_change": "integer",
      "reason": "Brief human-readable explanation for the change"
    }}
  ],
  "inner_circle_updates": [
    {{
      "name": "string",
      "loyalty_change": "integer (max ¬±8)",
      "opinion_change": "integer (max ¬±8)",
      "memory": "Brief description of this council meeting from their perspective"
    }}
  ],
  "neighboring_civilization_updates": [
    {{
      "name": "string",
      "relationship_change": "integer"
    }}
  ]
}}
"""
        else:
            # NON-COUNCIL EVENTS: Use existing logic
            ai_prompt = f"""
Given the current game state:
{game_state_json}

And the last player action:
{last_action_details}

Determine the indirect consequences of this action. Return a JSON object detailing subtle changes to the following:
- Faction approval and support.
- Inner Circle character metrics (loyalty, influence) and a new memory to add to their "history".
- The relationship status of neighboring civilizations.

Your response must be a valid JSON object with the following structure:
{{
  "faction_updates": [
    {{
      "name": "string",
      "approval_change": "integer",
      "reason": "Brief human-readable explanation for the change"
    }}
  ],
  "inner_circle_updates": [
    {{
      "name": "string",
      "loyalty_change": "integer",
      "opinion_change": "integer"
    }}
  ],
  "neighboring_civilization_updates": [
    {{
      "name": "string",
      "relationship_change": "integer"
    }}
  ]
}}
"""

        # Call Gemini API to get world updates
        try:
            model = genai.GenerativeModel(TEXT_MODEL)
            response = model.generate_content(
                ai_prompt,
                generation_config={
                    "response_mime_type": "application/json",
                    "temperature": 0.7
                }
            )
            ai_updates = json.loads(response.text)
            print(f"--- World Turn Simulation Complete ---")
        except JSONDecodeError as e:
            print(f"!!!!!!!!!! JSON PARSING ERROR (World Turn) !!!!!!!!!!!\n{e}")
            print(f"Raw response: {response.text if 'response' in locals() else 'No response'}")
            ai_updates = None
        except Exception as e:
            print(f"!!!!!!!!!! GEMINI API ERROR (World Turn) !!!!!!!!!!!\n{e}")
            ai_updates = None

        return ai_updates


################################################################################
# FILE: old_codebase\extract_remaining_prompts.py
# Size: 4701 bytes
################################################################################

#!/usr/bin/env python3
"""
Batch Prompt Extraction Script
Extracts remaining prompts from engine files and creates external prompt files.
Run this to complete the prompt externalization refactoring.
"""

import os
from pathlib import Path

# Define all remaining prompts to extract
PROMPTS_TO_CREATE = {
    # Council prompts
    'prompts/council/first_turn_briefing.txt': '''# FIRST TURN BRIEFING PROMPT
# Special one-time event for turn 0, introducing the player to their council.
# See council_engine.py:generate_first_turn_briefing for variable documentation.
# This is a placeholder - extract full prompt from council_engine.py lines 282-406
''',

    # Callback prompts (4 files)
    'prompts/callbacks/broken_promise.txt': '# BROKEN PROMISE CALLBACK\n# See callback_engine.py lines 30-76\n',
    'prompts/callbacks/enemy_revenge.txt': '# ENEMY REVENGE CALLBACK\n# See callback_engine.py lines 77-124\n',
    'prompts/callbacks/ally_request.txt': '# ALLY REQUEST CALLBACK\n# See callback_engine.py lines 125-172\n',
    'prompts/callbacks/debt_collection.txt': '# DEBT COLLECTION CALLBACK\n# See callback_engine.py lines 173-218\n',

    # Character prompt
    'prompts/characters/character_vignette.txt': '# CHARACTER VIGNETTE PROMPT\n# See character_engine.py lines 59-121\n',

    # Crisis prompts (8 files)
    'prompts/crises/famine.txt': '# FAMINE CRISIS\n# See crisis_engine.py lines 148-202\n',
    'prompts/crises/food_shortage.txt': '# FOOD SHORTAGE WARNING\n# See crisis_engine.py lines 203-256\n',
    'prompts/crises/severe_food_shortage.txt': '# SEVERE FOOD SHORTAGE\n# See crisis_engine.py lines 402-452\n',
    'prompts/crises/economic_collapse.txt': '# ECONOMIC COLLAPSE\n# See crisis_engine.py lines 257-310\n',
    'prompts/crises/economic_crisis.txt': '# ECONOMIC CRISIS\n# See crisis_engine.py lines 311-361\n',
    'prompts/crises/economic_warning.txt': '# ECONOMIC WARNING\n# See crisis_engine.py lines 453-500\n',
    'prompts/crises/succession_crisis.txt': '# SUCCESSION CRISIS\n# See crisis_engine.py lines 362-400\n',
    'prompts/crises/compound_crisis.txt': '# COMPOUND CRISIS\n# See crisis_engine.py lines 501-549\n',

    # Faction prompt
    'prompts/factions/faction_audience.txt': '# FACTION AUDIENCE PROMPT\n# See faction_engine.py lines 113-210\n',

    # Timeskip prompt
    'prompts/timeskip/timeskip_500_years.txt': '# TIMESKIP 500 YEARS\n# See timeskip_engine.py lines 38-149\n',

    # Visual prompts (4 files)
    'prompts/visuals/leader_portrait.txt': '# LEADER PORTRAIT GENERATION\n# See visual_engine.py lines 100-137\n',
    'prompts/visuals/advisor_portrait.txt': '# ADVISOR PORTRAIT GENERATION\n# See visual_engine.py lines 625-675\n',
    'prompts/visuals/crisis_illustration.txt': '# CRISIS ILLUSTRATION\n# See visual_engine.py lines 209-274\n',
    'prompts/visuals/settlement_evolution.txt': '# SETTLEMENT EVOLUTION IMAGE\n# See visual_engine.py lines 377-427\n',

    # World prompt
    'prompts/world/ai_description.txt': '# WORLD AI DESCRIPTION\n# See world_generator.py lines 500-510\n',
}

def main():
    """Create placeholder prompt files."""
    base_dir = Path(__file__).parent

    print("=" * 60)
    print("PROMPT EXTRACTION SCRIPT")
    print("=" * 60)
    print()
    print("This script creates PLACEHOLDER prompt files.")
    print("You must manually extract the full prompts from the engine files.")
    print()
    print("Creating placeholder files...")
    print()

    created_count = 0
    for prompt_path, content in PROMPTS_TO_CREATE.items():
        full_path = base_dir / prompt_path

        # Create if doesn't exist
        if not full_path.exists():
            full_path.write_text(content, encoding='utf-8')
            print(f"[+] Created: {prompt_path}")
            created_count += 1
        else:
            print(f"  Skipped (exists): {prompt_path}")

    print()
    print(f"Created {created_count} placeholder files.")
    print()
    print("=" * 60)
    print("NEXT STEPS:")
    print("=" * 60)
    print("1. Manually extract each prompt from the source engine files")
    print("2. Copy the full prompt text (f-string content) to the .txt file")
    print("3. Convert f-string {var} to .format() {var} placeholders")
    print("4. Document all required variables in file header")
    print("5. Modify each engine file to use load_prompt()")
    print()
    print("Example for event_generator.py:")
    print("  OLD: prompt = f\"\"\"You are... {civ_name}...\"\"\"")
    print("  NEW: prompt = load_prompt('events/generate_event').format(civ_name=...)")
    print()

if __name__ == '__main__':
    main()



################################################################################
# FILE: old_codebase\game_state.py
# Size: 19426 bytes
################################################################################

import json
import os
import tempfile
import shutil

class GameState:
    """
    Manages loading, accessing, and saving the game's state from JSON files.

    Access Patterns:
    - Factions: Use game_state.faction_manager (preferred) or game_state.factions (legacy)
    - Inner Circle: Use game_state.inner_circle_manager (preferred) or game_state.inner_circle (legacy)
    - Both managers support ID-based (preferred) and name-based (legacy) lookups

    Manager Methods:
    - faction_manager.get_by_id(faction_id) - Get faction by ID
    - faction_manager.get_by_name(faction_name) - Get faction by name (legacy)
    - faction_manager.update_approval(faction_id, change) - Update faction approval
    - inner_circle_manager.get_by_name(character_name) - Get character by name
    - inner_circle_manager.get_by_faction_id(faction_id) - Get all characters in a faction
    - inner_circle_manager.update_metrics(name, relationship=0, influence=0, loyalty=0) - Update metrics
    """

    def __init__(self, context_dir='context'):
        self.context_dir = context_dir
        self.defaults_dir = os.path.join(context_dir, 'defaults')
        # Define paths for all context files
        self.paths = {
            'civilization': os.path.join(context_dir, 'civilization_state.json'),
            'culture': os.path.join(context_dir, 'culture.json'),
            'religion': os.path.join(context_dir, 'religion.json'),
            'technology': os.path.join(context_dir, 'technology.json'),
            'world': os.path.join(context_dir, 'world_context.json'),
            'history_long': os.path.join(context_dir, 'history_long.json'),
            'history_compressed': os.path.join(context_dir, 'history_compressed.json'),
            'factions': os.path.join(context_dir, 'factions.json'),
            'inner_circle': os.path.join(context_dir, 'inner_circle.json'),
            'metadata': os.path.join(context_dir, 'game_metadata.json'),
            'buildings': os.path.join(context_dir, 'buildings.json'),
        }
        self.factions = None
        self.inner_circle = None

        # Add new state variables
        self.active_policy = None
        self.population_happiness = 70
        self.turn_number = 0

        # BALANCE_OVERHAUL: Crisis momentum tracking
        self.crisis_momentum = 0  # Tracks consecutive turns in crisis
        self.crisis_recovery_timer = 0  # Tracks turns since crisis ended

        # Butterfly effect tracker for historical_earth mode
        self.butterfly_tracker = None

        self.load()

        # Event interaction state (not persisted, session-only)
        self.current_event = None
        self.event_stage = 0
        self.event_conversation = []

    def reset_to_defaults(self):
        """Resets all game files to a fresh, randomized starting state."""
        self.turn_number = 0
        print("Generating new random civilization...")

        # Import WorldGenerator here to avoid circular imports
        from world_generator import WorldGenerator
        import random

        # Generate random configuration for a new game
        generator = WorldGenerator()

        # Randomize all starting parameters
        config = {
            "world_mode": "historical_earth",  # Default to historical_earth mode
            "starting_era": random.choice(["stone_age", "bronze_age", "iron_age", "classical"]),
            "earth_region": random.choice(["mediterranean", "mesopotamia", "nile_valley", "yellow_river", "indus_valley"]),
            "civilization_name": self._generate_random_civ_name(),
            "population_size": random.choice(["small", "medium", "large"]),
            "leader_name": "",  # Let the generator create a random leader name
            "cultural_focus": random.choice(["martial", "spiritual", "agricultural", "mercantile", "scholarly", "artistic"]),
            "religion_type": random.choice(["animism", "polytheism", "ancestor_worship"]),
            "social_structure": random.choice(["egalitarian", "hierarchical", "tribal_council", "city_state"]),
            "difficulty": "balanced",
            "neighbor_count": random.choice(["few", "several"]),
            "resource_abundance": "moderate"
        }

        # Generate fresh world data
        world_data = generator.generate_world(config)

        # Apply the new world data
        self.apply_custom_world(world_data)

        print(f"New civilization '{world_data['civilization']['meta']['name']}' created!")
        print(f"Leader: {world_data['civilization']['leader']['name']}")
        print(f"Era: {world_data['civilization']['meta']['era']}")

    def _generate_random_civ_name(self):
        """Generate a random civilization name."""
        import random

        prefixes = [
            "The", "The Great", "The Ancient", "The Free", "The United",
            "The Sacred", "The Eternal", "The Golden", "The Silver", "The Rising"
        ]

        names = [
            "Lumina", "Aethera", "Verdant", "Crimson", "Azure", "Storm",
            "Dawn", "Twilight", "Star", "Moon", "Sun", "Earth", "Sky",
            "River", "Mountain", "Forest", "Ocean", "Desert", "Valley"
        ]

        suffixes = [
            "Tribe", "People", "Clan", "Nation", "Empire", "Kingdom",
            "Confederation", "Alliance", "League", "Union", "Society"
        ]

        return f"{random.choice(prefixes)} {random.choice(names)} {random.choice(suffixes)}"

    def apply_custom_world(self, world_data):
        """
        Applies a custom world configuration to the game state.

        Args:
            world_data: Dictionary containing all game state data
        """
        print("Applying custom world configuration...")

        # Update in-memory state
        self.civilization = world_data.get('civilization', {})
        self.culture = world_data.get('culture', {})
        self.religion = world_data.get('religion', {})
        self.technology = world_data.get('technology', {})
        self.world = world_data.get('world', {})
        self.history_long = world_data.get('history_long', {"events": []})
        self.history_compressed = world_data.get('history_compressed', {"eras": []})
        self.factions = world_data.get('factions', {"factions": []})
        # Handle both nested and flat inner circle formats
        inner_circle_data = world_data.get('inner_circle', {})
        if isinstance(inner_circle_data, dict):
            self.inner_circle = inner_circle_data.get('characters', [])
        else:
            self.inner_circle = inner_circle_data

        # Recreate managers with new data
        from engines.faction_manager import FactionManager
        from engines.inner_circle_manager import InnerCircleManager

        self.faction_manager = FactionManager(self.factions)
        self.inner_circle_manager = InnerCircleManager({'characters': self.inner_circle})

        print(f"  [OK] FactionManager reinitialized with {len(self.faction_manager)} factions")
        print(f"  [OK] InnerCircleManager reinitialized with {len(self.inner_circle_manager)} characters")

        # Initialize butterfly tracker for new world
        self._initialize_butterfly_tracker()

        # Save the new state
        self.save()
        print("Custom world applied and saved.")

    def load(self):
        """Loads all JSON files into memory."""
        print("Loading game state from context files...")
        self.civilization = self._load_json(self.paths['civilization'])
        self.culture = self._load_json(self.paths['culture'])
        self.religion = self._load_json(self.paths['religion'])
        self.technology = self._load_json(self.paths['technology'])
        self.world = self._load_json(self.paths['world'])
        self.history_long = self._load_json(self.paths['history_long'])
        self.history_compressed = self._load_json(self.paths['history_compressed'])
        # Load faction data
        factions_data = self._load_json(self.paths['factions'], default={'factions': []})
        # TODO: Remove direct access after full migration (Phase 4)
        self.factions = factions_data  # Keep for backward compatibility

        # Create faction manager (new way)
        from engines.faction_manager import FactionManager
        self.faction_manager = FactionManager(factions_data)

        # Load inner circle data
        circle_data = self._load_json(self.paths['inner_circle'], default={'characters': []})
        # TODO: Remove direct access after full migration (Phase 4)
        self.inner_circle = circle_data.get('characters', [])  # Keep for backward compatibility

        # Create inner circle manager (new way)
        from engines.inner_circle_manager import InnerCircleManager
        self.inner_circle_manager = InnerCircleManager(circle_data)
        print(f"  [OK] FactionManager initialized with {len(self.faction_manager)} factions")
        print(f"  [OK] InnerCircleManager initialized with {len(self.inner_circle_manager)} characters")

        # Load buildings data (Phase 4)
        self.buildings = self._load_json(self.paths['buildings'], default={
            'available_buildings': [],
            'constructed_buildings': []
        })
        print(f"  [OK] Buildings loaded: {len(self.buildings.get('constructed_buildings', []))} constructed")

        # Load metadata (turn_number, active_policy, etc.)
        metadata = self._load_json(self.paths['metadata'], default={
            'turn_number': 0,
            'active_policy': None,
            'population_happiness': 70
        })
        self.turn_number = metadata.get('turn_number', 0)
        self.active_policy = metadata.get('active_policy', None)
        self.population_happiness = metadata.get('population_happiness', 70)

        # Validate and fix leader data
        self._validate_leader()

        # Initialize new systems for backwards compatibility
        self._initialize_new_systems()

        # Initialize butterfly tracker for historical_earth mode
        self._initialize_butterfly_tracker()

        # Validate data integrity
        self._validate_data_integrity()

        print("Game state loaded successfully.")

    def _initialize_new_systems(self):
        """Initialize new Phase 1/2 systems if not present (backwards compatibility)."""
        # Initialize consequences system
        if 'consequences' not in self.civilization:
            from engines.consequence_engine import initialize_consequences
            initialize_consequences(self)
            print("  [OK] Initialized consequence tracking system")

        # Initialize victory progress
        if 'victory_progress' not in self.civilization:
            from engines.victory_engine import initialize_victory_tracking
            initialize_victory_tracking(self)
            print("  [OK] Initialized victory tracking system")

        # Initialize discovered technologies (Phase 4)
        if 'discovered_technologies' not in self.civilization:
            # Grant basic techs based on era for backwards compatibility
            era = self.civilization.get('meta', {}).get('era', 'stone_age')
            basic_techs = []

            # Grant techs based on era
            if era in ['bronze_age', 'iron_age', 'classical', 'medieval']:
                basic_techs.extend(['tech_agriculture', 'tech_writing', 'tech_metalworking', 'tech_currency', 'tech_masonry'])

            self.civilization['discovered_technologies'] = basic_techs
            if basic_techs:
                print(f"  [OK] Initialized discovered technologies: {len(basic_techs)} techs")

    def _validate_leader(self):
        """Validates and corrects leader life expectancy based on current era."""
        leader = self.civilization.get('leader', {})

        # Ensure leader has traits (backwards compatibility)
        if 'traits' not in leader or not leader['traits']:
            # Assign default traits based on era/context
            import random
            default_traits = ['Wise', 'Just', 'Brave']
            leader['traits'] = random.sample(default_traits, 2)
            print(f"  [OK] Assigned default traits to leader: {', '.join(leader['traits'])}")
        era = self.civilization.get('meta', {}).get('era', 'stone_age')

        # Import here to avoid circular dependency
        from engines.timeskip_engine import calculate_life_expectancy

        expected_life_exp = calculate_life_expectancy(era)
        current_life_exp = leader.get('life_expectancy', 0)

        # Check if life expectancy is unrealistic (more than ¬±10 from expected)
        # Tightened from ¬±25 to ¬±10 for better accuracy
        if abs(current_life_exp - expected_life_exp) > 10:
            print(f"  WARNING: Correcting leader life_expectancy from {current_life_exp} to {expected_life_exp} for {era} era")
            self.civilization['leader']['life_expectancy'] = expected_life_exp
            # Save the corrected state
            self.save()

    def _initialize_butterfly_tracker(self):
        """Initialize butterfly effect tracker for historical_earth mode."""
        meta = self.civilization.get('meta', {})
        world_mode = meta.get('world_mode', 'fantasy')

        # Only initialize for historical_earth mode
        if world_mode == 'historical_earth' and meta.get('butterfly_effects_enabled', False):
            from engines.world_modes.historical_earth_mode import ButterflyEffectTracker

            # Check if we have existing tracker data
            if 'butterfly_tracker' in meta:
                tracker_data = meta['butterfly_tracker']
                # Recreate tracker from saved data
                self.butterfly_tracker = ButterflyEffectTracker(
                    starting_era=meta.get('era', 'bronze_age'),
                    starting_year=meta.get('founding_date', -3000)
                )
                self.butterfly_tracker.divergence_score = tracker_data.get('divergence_score', 0)
                self.butterfly_tracker.key_divergences = tracker_data.get('key_divergences', [])
                self.butterfly_tracker.timeline_altered = tracker_data.get('timeline_altered', False)
                print(f"  [OK] Butterfly tracker loaded: {self.butterfly_tracker.get_timeline_name()}")
            else:
                # Create new tracker
                self.butterfly_tracker = ButterflyEffectTracker(
                    starting_era=meta.get('era', 'bronze_age'),
                    starting_year=meta.get('founding_date', -3000)
                )
                print("  [OK] Butterfly tracker initialized for historical_earth mode")

    def _validate_data_integrity(self):
        """Validates referential integrity of game data."""
        from engines.data_validator import validate_all

        validation_result = validate_all(self)

        # Print any errors or warnings
        if validation_result['errors']:
            print("  WARNING: DATA INTEGRITY WARNINGS:")
            for error in validation_result['errors']:
                print(f"    - {error}")

        if validation_result['warnings']:
            for warning in validation_result['warnings']:
                print(f"  WARNING: {warning}")

    def _load_json(self, file_path, default=None):
        """
        Helper to load a single JSON file.
        If the file doesn't exist and a default is provided,
        creates the file with the default content.
        """
        if not os.path.exists(file_path) and default is not None:
            print(f"  [OK] Creating default file for {os.path.basename(file_path)}")
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(default, f, indent=4)
            return default
        
        with open(file_path, 'r', encoding='utf-8') as f:
            return json.load(f)

    def save(self):
        """Saves all in-memory game state back to their respective JSON files."""
        print("Saving game state...")
        self._save_atomic(self.paths['civilization'], self.civilization)
        self._save_atomic(self.paths['culture'], self.culture)
        self._save_atomic(self.paths['religion'], self.religion)
        self._save_atomic(self.paths['technology'], self.technology)
        self._save_atomic(self.paths['world'], self.world)
        self._save_atomic(self.paths['history_long'], self.history_long)
        self._save_atomic(self.paths['history_compressed'], self.history_compressed)
        # Save from managers if they exist (preferred), otherwise use direct attributes
        if hasattr(self, 'faction_manager'):
            self._save_atomic(self.paths['factions'], self.faction_manager.to_dict())
        else:
            self._save_atomic(self.paths['factions'], self.factions)

        if hasattr(self, 'inner_circle_manager'):
            self._save_atomic(self.paths['inner_circle'], self.inner_circle_manager.to_dict())
        else:
            self._save_atomic(self.paths['inner_circle'], {"characters": self.inner_circle})

        # Save buildings (Phase 4)
        self._save_atomic(self.paths['buildings'], self.buildings)

        self._save_atomic(self.paths['metadata'], {
            "turn_number": self.turn_number,
            "active_policy": self.active_policy,
            "population_happiness": self.population_happiness
        })
        print("Game state saved.")

    def _save_atomic(self, file_path, data):
        """
        Atomically saves a JSON file by writing to a temporary file 
        and then renaming it to prevent data corruption.
        """
        try:
            # Create a temporary file in the same directory
            temp_fd, temp_path = tempfile.mkstemp(dir=self.context_dir)
            with os.fdopen(temp_fd, 'w', encoding='utf-8') as temp_file:
                json.dump(data, temp_file, indent=4)
            
            # Atomically replace the original file with the new one
            os.replace(temp_path, file_path)
        except Exception as e:
            print(f"Error saving file {file_path}: {e}")
            # If an error occurs, try to clean up the temporary file
            if os.path.exists(temp_path):
                os.remove(temp_path)
    def to_dict(self):
        """Serializes the entire game state into a dictionary."""
        return {
            'civilization': self.civilization,
            'culture': self.culture,
            'religion': self.religion,
            'technology': self.technology,
            'world': self.world,
            'history_long': self.history_long,
            'history_compressed': self.history_compressed,
            'factions': self.faction_manager.to_dict() if hasattr(self, 'faction_manager') else self.factions,
            'inner_circle': self.inner_circle_manager.to_dict() if hasattr(self, 'inner_circle_manager') else {"characters": self.inner_circle},
            'buildings': self.buildings,
            'active_policy': self.active_policy,
            'population_happiness': self.population_happiness,
            'turn_number': self.turn_number,
        }


################################################################################
# FILE: old_codebase\main.py
# Size: 29072 bytes
################################################################################

import os
import json
import threading
from flask import Flask, jsonify, render_template, request
from dotenv import load_dotenv
import google.generativeai as genai

# Our custom modules
from game_state import GameState
from engines.event_generator import generate_event, generate_event_stage
from engines.action_processor import process_player_action
from engines.state_updater import apply_world_turn_updates
from engines.timeskip_engine import perform_timeskip, apply_updates as apply_timeskip_updates
from engines.world_turns_engine import WorldTurnsEngine
from engines import character_engine
from world_generator import WorldGenerator

# --- Initialization ---
load_dotenv()
api_key = os.getenv("GEMINI_API_KEY")
if not api_key:
    print("WARNING: GEMINI_API_KEY not found in .env file. Please create a .env file with your key.")
    exit()
genai.configure(api_key=api_key)

app = Flask(__name__)

# Global game instance - will be initialized when needed
game = None
world_turns_engine = WorldTurnsEngine()

def initialize_game():
    """Initializes or reloads the game state."""
    global game
    try:
        game = GameState()
        # Reset event state
        game.current_event = None
        game.event_stage = 0
        game.event_conversation = []
        return True
    except FileNotFoundError:
        print("ERROR: Context files not found. Make sure you have the 'context' directory with all JSON files.")
        return False

def generate_advisor_portraits_sync(game_state):
    """
    Generate portraits for all advisors synchronously.
    This ensures portraits are available immediately when the game loads.
    """
    from engines.visual_engine import generate_advisor_portrait

    print("--- Starting advisor portrait generation ---")

    # Get era and culture context
    era = game_state.civilization.get('meta', {}).get('era', 'classical')
    culture_values = game_state.culture.get('values', [])
    civ_context = {
        'era': era,
        'culture_values': culture_values
    }

    # Get all advisors
    if hasattr(game_state, 'inner_circle_manager'):
        advisors = game_state.inner_circle_manager.get_all()
    else:
        advisors = game_state.inner_circle.get('characters', [])

    # Generate portrait for each advisor
    for advisor in advisors:
        try:
            print(f"Generating portrait for {advisor.get('name', 'Unknown')}...")
            portrait_result = generate_advisor_portrait(advisor, civ_context)

            if portrait_result.get('success'):
                advisor['portrait'] = portrait_result.get('filename', 'placeholder.png')
                print(f"‚úì Portrait generated for {advisor.get('name')}")
            else:
                print(f"‚úó Portrait generation failed for {advisor.get('name')}")
        except Exception as e:
            print(f"Error generating portrait for {advisor.get('name', 'Unknown')}: {e}")

    print("--- Advisor portrait generation complete ---")

def generate_advisor_portraits_async(game_state):
    """
    Generate portraits for all advisors in the background.
    This runs asynchronously so it doesn't block game creation.
    DEPRECATED: Use generate_advisor_portraits_sync for initial generation.
    """
    def _generate():
        generate_advisor_portraits_sync(game_state)
        # Save after all portraits generated
        game_state.save()

    # Start generation in background thread
    thread = threading.Thread(target=_generate, daemon=True)
    thread.start()

# --- Web Routes ---
@app.route('/')
def index():
    """Renders the main menu."""
    return render_template('menu.html')

@app.route('/custom')
def custom_page():
    """Renders the custom world creation page."""
    return render_template('custom_world.html')

@app.route('/game')
def game_page():
    """Renders the main game interface."""
    global game
    if game is None:
        initialize_game()
    return render_template('index.html')

# --- API Routes ---
@app.route('/api/check_save')
def check_save():
    """Checks if a saved game exists and returns save info."""
    try:
        # Try to load game state to check if valid save exists
        temp_game = GameState()

        # If we can load it, extract info
        save_info = {
            "civilization_name": temp_game.civilization.get('meta', {}).get('name', 'Unknown'),
            "year": temp_game.civilization.get('meta', {}).get('year', 0),
            "era": temp_game.civilization.get('meta', {}).get('era', 'Unknown'),
            "leader_name": temp_game.civilization.get('leader', {}).get('name', 'Unknown')
        }

        return jsonify({
            "has_save": True,
            "save_info": save_info
        })
    except (FileNotFoundError, json.JSONDecodeError, KeyError):
        return jsonify({
            "has_save": False
        })

@app.route('/api/new_game', methods=['POST'])
def new_game():
    """Creates a new game by resetting all context files to defaults."""
    global game
    try:
        # Initialize if needed
        if game is None:
            if not initialize_game():
                return jsonify({"status": "error", "message": "Failed to initialize game"}), 500

        # Reset to defaults
        game.reset_to_defaults()

        # Reset event state
        game.current_event = None
        game.event_stage = 0
        game.event_conversation = []

        # Generate initial leader portrait
        from engines.visual_engine import generate_leader_portrait
        leader = game.civilization.get('leader', {})
        civ_context = {
            'era': game.civilization.get('meta', {}).get('era', 'stone_age'),
            'culture_values': game.culture.get('values', [])
        }
        portrait_result = generate_leader_portrait(leader, civ_context)

        # Store portrait path in leader data
        if portrait_result.get('success'):
            game.civilization['leader']['portrait'] = portrait_result.get('filename', 'placeholder.png')

            # Initialize the image update tracker with initial state
            from engines.image_update_manager import get_tracker
            tracker = get_tracker()
            tracker.update_portrait_state(game)

        # Generate advisor portraits synchronously for immediate availability
        generate_advisor_portraits_sync(game)

        game.save()

        return jsonify({"status": "success"})
    except Exception as e:
        print(f"Error creating new game: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/api/custom_game', methods=['POST'])
def custom_game():
    """Creates a new game with custom world generation."""
    global game
    try:
        # Get custom configuration from request
        config = request.get_json()

        # Initialize world generator
        generator = WorldGenerator()

        # Generate world data
        world_data = generator.generate_world(config)

        # Initialize or reinitialize game
        if game is None:
            game = GameState()

        # Apply custom world data
        game.apply_custom_world(world_data)

        # Generate opening description (optional)
        description = generator.generate_ai_description(world_data)

        # Generate leader portrait
        from engines.visual_engine import generate_leader_portrait
        leader = game.civilization.get('leader', {})
        civ_context = {
            'era': game.civilization.get('meta', {}).get('era', 'stone_age'),
            'culture_values': game.culture.get('values', [])
        }
        portrait_result = generate_leader_portrait(leader, civ_context)

        if portrait_result.get('success'):
            game.civilization['leader']['portrait'] = portrait_result.get('filename', 'placeholder.png')

            # Initialize the image update tracker with initial state
            from engines.image_update_manager import get_tracker
            tracker = get_tracker()
            tracker.update_portrait_state(game)

        # Generate advisor portraits synchronously for immediate availability
        generate_advisor_portraits_sync(game)

        game.save()

        return jsonify({
            "status": "success",
            "description": description
        })
    except Exception as e:
        print(f"Error creating custom game: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/api/game_state')
def get_game_state():
    """Returns the complete current game state."""
    global game
    if game is None:
        initialize_game()
    if game is None:
        return jsonify({"status": "error", "message": "Game not initialized"}), 500

    return jsonify({
        "civilization": game.civilization,
        "culture": game.culture,
        "religion": game.religion,
        "technology": game.technology,
        "world": game.world
    })

@app.route('/api/event')
def get_event():
    """Generates and returns a new event for the player."""
    global game
    if game is None:
        initialize_game()
    if game is None:
        return jsonify({"status": "error", "message": "Game not initialized"}), 500

    try:
        # Check for victory or failure before generating event
        from engines.victory_engine import check_victory, check_failure

        # Check failure first (higher priority)
        is_failed, failure_type, failure_desc = check_failure(game)
        if is_failed:
            return jsonify({
                "game_over": True,
                "outcome": "defeat",
                "type": failure_type,
                "title": f"Civilization Fallen: {failure_type.replace('_', ' ').title()}",
                "narrative": failure_desc
            })

        # Check victory
        is_victory, victory_type, victory_desc = check_victory(game)
        if is_victory:
            return jsonify({
                "game_over": True,
                "outcome": "victory",
                "type": victory_type,
                "title": f"Victory Achieved: {victory_type.replace('_', ' ').title()}",
                "narrative": victory_desc
            })

        # No game over, generate normal event
        event_data = generate_event(game)
        return jsonify(event_data)
    except Exception as e:
        print(f"ERROR generating event: {e}")
        return jsonify({"error": "Failed to generate event"}), 500

@app.route('/api/event_interaction', methods=['POST'])
def handle_event_interaction():
    """
    Handles mid-event interactions (investigation, questions, etc.)
    Does NOT finalize the event or apply consequences.
    """
    global game
    if game is None:
        initialize_game()
    if game is None:
        return jsonify({"status": "error", "message": "Game not initialized"}), 500

    data = request.get_json()
    player_response = data.get('response')

    if not player_response:
        return jsonify({"status": "error", "message": "Missing player response."}), 400

    if not game.current_event:
        return jsonify({"status": "error", "message": "No active event to interact with."}), 400

    print(f"--- Received event interaction: '{player_response}' (Stage {game.event_stage}) ---")

    try:
        stage_data = generate_event_stage(game, player_response)
        return jsonify({
            "status": "success",
            "stage": game.event_stage,
            "response": stage_data
        })
    except Exception as e:
        print(f"Error in event interaction: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/api/action', methods=['POST'])
def handle_action():
    """
    Receives a player's FINAL action, processes outcome, applies state changes,
    saves the game, and returns the narrative outcome.
    """
    global game
    if game is None:
        initialize_game()
    if game is None:
        return jsonify({"status": "error", "message": "Game not initialized"}), 500

    data = request.get_json()
    player_action = data.get('action')
    event_title = data.get('event_title')
    event_narrative = data.get('event_narrative')

    if not all([player_action, event_title, event_narrative]):
        return jsonify({"status": "error", "message": "Missing action or event context."}), 400

    print(f"--- Received FINAL action '{player_action}' for event '{event_title}' ---")

    try:
        outcome = process_player_action(game, player_action, event_title, event_narrative)

        if outcome.get("status") == "error":
            return jsonify({"status": "error", "message": outcome.get("narrative")})

        # Capture event details before resetting (for world turn analysis)
        event_type = game.current_event.get('event_type') if game.current_event else None
        conversation = list(game.event_conversation)  # Copy before clearing

        # Reset event state after resolution
        game.current_event = None
        game.event_stage = 0
        game.event_conversation = []

        # Simulate the world's reaction to the player's action
        world_updates = world_turns_engine.simulate_turn(game, {
            "action": player_action,
            "outcome": outcome,
            "event_type": event_type,
            "conversation": conversation
        })
        if world_updates:
            apply_world_turn_updates(game, world_updates)

        game.save()
        return jsonify({"status": "success", "outcome": outcome})
    except Exception as e:
        print(f"ERROR processing action: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({"status": "error", "message": f"Failed to process action: {str(e)}"}), 500

@app.route('/api/timeskip', methods=['POST'])
def handle_timeskip():
    """
    Initiates a timeskip, processes the outcome, saves the game,
    and returns the narrative.
    """
    global game
    if game is None:
        initialize_game()
    if game is None:
        return jsonify({"status": "error", "message": "Game not initialized"}), 500

    print("--- Initiating Timeskip ---")

    timeskip_outcome = perform_timeskip(game)

    if "updates" in timeskip_outcome and timeskip_outcome["updates"]:
        apply_timeskip_updates(game, timeskip_outcome["updates"], is_timeskip=True)

    game.save()

    return jsonify({
        "status": "success",
        "narrative": timeskip_outcome.get("narrative", "Time marches on.")
    })

@app.route('/api/die', methods=['POST'])
def handle_death():
    """
    Generates successor candidates for the player to choose from using the high-stakes succession crisis system.
    """
    global game
    if game is None:
        initialize_game()
    if game is None:
        return jsonify({"status": "error", "message": "Game not initialized"}), 500

    print("--- Player has chosen to abdicate. Triggering succession crisis. ---")
    from engines.leader_engine import trigger_succession_crisis, apply_legacy_bonus
    from engines.visual_engine import generate_leader_portrait

    leader = game.civilization.get('leader', {})

    # Trigger high-stakes succession crisis with faction-backed candidates
    succession_data = trigger_succession_crisis(game)
    candidates = succession_data['candidates']

    # Generate portraits for each candidate
    era = game.civilization.get('meta', {}).get('era', 'classical')
    culture_values = game.culture.get('values', [])

    for candidate in candidates:
        civ_context = {
            'era': era,
            'culture_values': culture_values
        }
        # Create a temporary leader dict for portrait generation
        temp_leader = {
            'name': candidate['name'],
            'age': candidate['age'],
            'traits': candidate['traits'],
            'role': 'Candidate'
        }
        portrait_result = generate_leader_portrait(temp_leader, civ_context)
        candidate['portrait'] = portrait_result.get('filename', 'placeholder.png')

    # Create summary of current leader
    summary = (
        f"The reign of {leader.get('name', 'a forgotten leader')} has come to an end. "
        f"They ruled for {leader.get('years_ruled', 0)} years, reaching the age of {leader.get('age', 'unknown')}. "
        f"Their legacy, marked by traits of '{', '.join(leader.get('traits', ['mystery']))}', will be remembered."
    )

    return jsonify({
        "status": "success",
        "summary": summary,
        "candidates": candidates,
        "requires_choice": True,
        "succession_crisis": True,  # Flag to indicate high-stakes succession
        "transition_crisis_duration": succession_data.get('transition_crisis_duration', 10),
        "rival_claimant_chance": succession_data.get('rival_claimant_chance', 0.40)
    })

@app.route('/api/choose_successor', methods=['POST'])
def choose_successor():
    """
    Apply chosen successor and legacy bonuses, including faction approval changes.
    """
    data = request.get_json()
    chosen_index = data.get('successor_index')

    if chosen_index is None:
        return jsonify({"status": "error", "message": "No successor chosen"}), 400

    from engines.leader_engine import trigger_succession_crisis, apply_legacy_bonus
    from engines.timeskip_engine import calculate_life_expectancy

    # Store old leader for legacy
    old_leader = game.civilization['leader'].copy()

    # Generate candidates again using trigger_succession_crisis (same logic as /api/die)
    succession_data = trigger_succession_crisis(game)
    candidates = succession_data['candidates']

    if chosen_index < 0 or chosen_index >= len(candidates):
        return jsonify({"status": "error", "message": "Invalid successor index"}), 400

    chosen = candidates[chosen_index]

    # Apply legacy bonuses
    legacy = apply_legacy_bonus(game, old_leader)

    # Apply faction approval changes from succession choice
    approval_changes = chosen.get('approval_changes', {})
    if hasattr(game, 'faction_manager'):
        for faction_key, change in approval_changes.items():
            # Find matching faction by id
            factions = game.faction_manager.get_all()
            for faction in factions:
                if faction_key in faction.get('id', '').lower():
                    current_approval = faction.get('approval', 50)
                    faction['approval'] = max(0, min(100, current_approval + change))
                    print(f"  Faction {faction['name']} approval: {faction['approval']} ({change:+d})")

    # Apply special effects (e.g., populist happiness boost)
    if chosen.get('special') == 'happiness_boost':
        game.population_happiness = min(100, game.population_happiness + 20)
        legacy['bonuses_applied'].append("+20 immediate happiness (people's champion)")

    # Set new leader
    era = game.civilization['meta']['era']
    game.civilization['leader'] = {
        'name': chosen['name'],
        'age': chosen.get('age', 30),
        'life_expectancy': calculate_life_expectancy(era),
        'role': 'Leader',
        'traits': chosen['traits'],
        'years_ruled': 0,
        'archetype': chosen.get('archetype', 'Unknown'),
        'backing_faction': chosen.get('backing_faction', 'None'),
        'demands': chosen.get('demands', 'None')
    }

    print(f"  üëë New leader: {chosen['name']} ({chosen.get('archetype', 'Unknown')})")
    print(f"  Backed by: {chosen.get('backing_faction', 'None')}")

    # Generate portrait for new leader
    from engines.visual_engine import generate_leader_portrait
    civ_context = {
        'era': era,
        'culture_values': game.culture.get('values', [])
    }
    portrait_result = generate_leader_portrait(game.civilization['leader'], civ_context)

    if portrait_result.get('success'):
        game.civilization['leader']['portrait'] = portrait_result.get('filename', 'placeholder.png')

        # Reset the image update tracker for the new leader
        from engines.image_update_manager import get_tracker
        tracker = get_tracker()
        tracker.update_portrait_state(game)

    # Store succession crisis state for future events (rival claimants, etc.)
    if not hasattr(game, 'succession_state'):
        game.succession_state = {}
    game.succession_state['recent_succession'] = True
    game.succession_state['chosen_candidate'] = chosen['name']
    game.succession_state['rival_claimant_chance'] = succession_data.get('rival_claimant_chance', 0.40)
    game.succession_state['transition_crisis_duration'] = succession_data.get('transition_crisis_duration', 10)
    game.succession_state['turns_since_succession'] = 0

    game.save()

    return jsonify({
        "status": "success",
        "new_leader": game.civilization['leader'],
        "legacy": legacy,
        "faction_changes": approval_changes
    })
@app.route('/api/context/culture')
def get_culture():
    """Returns the culture context."""
    return jsonify(game.culture)

@app.route('/api/context/religion')
def get_religion():
    """Returns the religion context."""
    return jsonify(game.religion)

@app.route('/api/context/technology')
def get_technology():
    """Returns the technology context."""
    return jsonify(game.technology)

@app.route('/api/context/history_recent')
def get_history_recent():
    """Returns recent history."""
    return jsonify(game.history_long)

@app.route('/api/context/history_ancient')
def get_history_ancient():
    """Returns compressed ancient history."""
    return jsonify(game.history_compressed)

@app.route('/api/dashboard')
def get_dashboard():
    """Returns comprehensive dashboard data for the stats panel."""
    global game
    if game is None:
        initialize_game()
    if game is None:
        return jsonify({"status": "error", "message": "Game not initialized"}), 500

    from engines.tendency_analyzer import analyze_player_tendency, get_tendency_description
    from engines.bonus_engine import BonusEngine

    # Combine recent history from both sources
    recent_events = []
    if game.history_long and 'events' in game.history_long:
        recent_events = game.history_long['events'][-10:]  # Last 10 events

    # Analyze player tendency for dashboard display
    primary_tendency, secondary_tendency = analyze_player_tendency(game.history_long, num_events=10)
    tendency_desc = get_tendency_description(primary_tendency, secondary_tendency)

    # Calculate active bonuses for display
    bonus_engine = BonusEngine()
    active_bonuses = bonus_engine.get_all_active_bonuses(game)

    # Format for frontend
    bonus_summary = {}
    for bonus_type, result in active_bonuses.items():
        bonus_summary[bonus_type] = {
            'total': result['total'],
            'sources': [
                {'type': src_type, 'name': src_name, 'value': value}
                for src_type, src_name, value in result['sources']
            ]
        }

    # Calculate faction bonuses for UI display
    faction_bonuses = {}
    if hasattr(game, 'faction_manager'):
        raw_bonuses = game.faction_manager.get_faction_bonuses(game)

        # Format for frontend display
        faction_bonuses = {
            'wealth_multiplier': raw_bonuses.get('wealth_multiplier', 1.0),
            'military_effectiveness': raw_bonuses.get('military_effectiveness', 1.0),
            'happiness_modifier': raw_bonuses.get('happiness_modifier', 0)
        }

    return jsonify({
        "civilization": {
            "name": game.civilization.get('meta', {}).get('name', 'Unknown'),
            "year": game.civilization.get('meta', {}).get('year', 0),
            "era": game.civilization.get('meta', {}).get('era', 'Unknown'),
            "founding_date": game.civilization.get('meta', {}).get('founding_date', 0),
            "population": game.civilization.get('population', 0),
            "resources": game.civilization.get('resources', {}),
            "leader": game.civilization.get('leader', {})
        },
        "culture": {
            "values": game.culture.get('values', []),
            "traditions": game.culture.get('traditions', []),
            "taboos": game.culture.get('taboos', []),
            "social_structure": game.culture.get('social_structure', 'Unknown'),
            "recent_changes": game.culture.get('recent_changes', [])
        },
        "religion": {
            "name": game.religion.get('name', 'Unknown'),
            "type": game.religion.get('type', 'Unknown'),
            "primary_deity": game.religion.get('primary_deity', 'Unknown'),
            "core_tenets": game.religion.get('core_tenets', []),
            "practices": game.religion.get('practices', []),
            "holy_sites": game.religion.get('holy_sites', []),
            "influence": game.religion.get('influence', 'Unknown')
        },
        "technology": {
            "current_tier": game.technology.get('current_tier', 'Unknown'),
            "discoveries": game.technology.get('discoveries', []),
            "in_progress": game.technology.get('in_progress', []),
            "infrastructure": game.technology.get('infrastructure', [])
        },
        "history": {
            "recent_events": recent_events,
            "age": abs(game.civilization.get('meta', {}).get('year', 0) - game.civilization.get('meta', {}).get('founding_date', 0))
        },
        "player_tendency": {
            "primary": primary_tendency,
            "secondary": secondary_tendency,
            "description": tendency_desc
        },
        "active_policy": game.active_policy or "general_governance",
        "inner_circle": game.inner_circle,
        "factions": game.faction_manager.get_all() if hasattr(game, 'faction_manager') else (game.factions.get('factions', []) if isinstance(game.factions, dict) else []),
        "faction_bonuses": faction_bonuses,
        "active_bonuses": bonus_summary,
        "population_happiness": game.population_happiness
    })

@app.route('/api/victory_status')
def get_victory_status():
    """Returns current victory progress and status."""
    from engines.victory_engine import get_victory_status_summary

    status = get_victory_status_summary(game)
    return jsonify(status)

@app.route('/api/settlement_gallery')
def get_settlement_gallery():
    """Returns list of settlement evolution images."""
    from engines.visual_engine import get_settlement_gallery

    gallery = get_settlement_gallery(limit=5)
    return jsonify({"gallery": gallery})

@app.route('/api/start_character_vignette', methods=['POST'])
def start_character_vignette():
    """
    Starts a character vignette event.
    """
    data = request.get_json()
    character_name = data.get('character_name')

    if not character_name:
        return jsonify({"status": "error", "message": "Missing character_name."}), 400

    # Generate the character vignette event
    event_data = character_engine.generate_character_vignette(game, character_name)

    if not event_data:
        return jsonify({"status": "error", "message": f"Could not generate vignette for {character_name}."}), 500

    # Reset event state and set new character vignette as current event
    game.current_event = event_data
    game.event_stage = 0
    game.event_conversation = []

    return jsonify(event_data)

@app.route('/api/buildings')
def get_buildings():
    """Returns building information including available and constructed buildings."""
    from engines.building_manager import BuildingManager

    building_manager = BuildingManager()

    # Get available buildings (can construct)
    available = building_manager.get_available(game)

    # Get constructed buildings
    constructed = game.buildings.get('constructed_buildings', [])

    # Get buildings in construction
    in_construction = game.buildings.get('available_buildings', [])

    return jsonify({
        "available": available,
        "constructed": constructed,
        "in_construction": in_construction
    })

@app.route('/api/technologies')
def get_technologies():
    """Returns discovered technologies."""
    return jsonify({
        "discovered": game.civilization.get('discovered_technologies', []),
        "era": game.civilization.get('meta', {}).get('era', 'stone_age')
    })

# --- Main Execution ---
if __name__ == '__main__':
    app.run(debug=True)




################################################################################
# FILE: old_codebase\model_config.py
# Size: 1130 bytes
################################################################################

# Model Configuration
# Central configuration for all Gemini API model references
# Update these values if you need to switch models
# Reference: https://ai.google.dev/gemini-api/docs/models/gemini

# Primary text generation model for events and actions
# Options: 'gemini-2.5-flash-lite', 'gemini-2.5-flash', 'gemini-2.0-flash-lite'
TEXT_MODEL = 'gemini-2.5-flash-lite'

# Image generation model for settlement visualizations
# Options: 'gemini-2.5-flash', 'gemini-2.0-flash-exp'
IMAGE_MODEL = 'gemini-2.5-flash'

# Timeskip model (use more powerful model for complex 500-year narratives)
# Options: 'gemini-2.5-flash-lite', 'gemini-2.5-flash', 'gemini-2.5-pro'
TIMESKIP_MODEL = 'gemini-2.5-flash-lite'

# World generation model
# Options: 'gemini-2.5-flash-lite', 'gemini-2.5-flash'
WORLD_GEN_MODEL = 'gemini-2.5-flash-lite'

# Visual generation model for portraits, crisis art, settlement evolution
# Options: 'gemini-2.5-flash-image' (recommended - fast, affordable, good quality)
VISUAL_MODEL = 'gemini-2.5-flash-image'

# API Configuration
API_VERSION = 'v1beta'  # Required for Gemini 2.x models



################################################################################
# FILE: old_codebase\prompts\actions\process_player_action.txt
# Size: 6081 bytes
################################################################################

# PLAYER ACTION PROCESSING PROMPT
# Determines outcome of player's final decision and generates state updates.
#
# VARIABLES REQUIRED:
# - action: The player's chosen action (string)
# - event_title: Title of the event
# - event_narrative: Initial event narrative
# - conversation_summary: Multi-line conversation history or empty string
# - civ_name: Civilization name
# - year: Current year
# - leader_name: Leader name
# - leader_age: Leader age (integer)
# - population: Population count (integer)
# - food: Food resources (integer)
# - wealth: Wealth resources (integer)
# - resource_state: Descriptive resource state context
# - tech_tier: Technology tier
# - culture_values: Comma-separated cultural values
# - religion_name: Religion name
# - religion_influence: Religion influence level
# - recent_discoveries: Comma-separated recent discoveries
# - terrain: World terrain

You are the master chronicler for a civilization simulation game. A player has made their FINAL decision after investigating an event. Your task is to narrate the immediate outcome with gravitas and weight.

**FORMATTING REQUIREMENT:** Use markdown formatting in your outcome narrative:
- Use **bold** for emphasis on important consequences or dramatic results
- Use *italics* for subtle effects or ongoing changes
- Use line breaks (\n) to separate distinct consequences

**NARRATIVE PURPOSE:** This outcome should feel like a real consequence of the player's choice. It should be written in past-tense, as if recording history. Make the player feel that their decision MATTERED and had tangible results.

<EVENT>
Title: "{event_title}"
Initial Situation: "{event_narrative}"
</EVENT>
{conversation_summary}
<FINAL_PLAYER_DECISION>
After their investigation, the player has chosen to: "{action}"
</FINAL_PLAYER_DECISION>

<CIVILIZATION_STATE>
Name: {civ_name} (Year {year})
Leader: {leader_name}, Age {leader_age}
Population: {population:,}
Resources: {food:,} food, {wealth:,} wealth
{resource_state}Technology Tier: {tech_tier}

Cultural Values: {culture_values}
Religious Beliefs: {religion_name} ({religion_influence} influence)
Recent Discoveries: {recent_discoveries}
Geography: {terrain}
</CIVILIZATION_STATE>

<TASK>
First, within <reasoning> tags, perform a step-by-step analysis:
1.  **Acknowledge and Interpret**: State your understanding of the action.
2.  **Contextualize**: Analyze the action against:
    - The civilization's **culture** (values, traditions).
    - The leader's **traits**.
    - The current **resource situation** (food, wealth).
    - The known positions or loyalty of **relevant advisors** from the inner circle, if applicable to the decision.
3.  **Brainstorm Consequences**: Consider multiple potential outcomes.
4.  **Select and Justify**: Choose the most fitting outcome and explain why.

After completing your reasoning, generate the final output.

Determine the immediate outcome of this action. Your narrative should feel like a historical chronicle entry.

**REACTIVITY REQUIREMENT:**
Your outcome narrative MUST acknowledge and reference:
- The specific action the player took (use direct language: "The leader commanded...", "You decreed...")
- At least ONE cultural value from: {culture_values_short}
- The leader's personality traits: {leader_traits}

Consider:
1. Realistic consequences for the civilization's era and technology level
2. How this action aligns or conflicts with cultural values and religious beliefs
3. Short-term resource impacts (food, wealth, population changes)
4. Potential discoveries, traditions, or infrastructure gained
5. The leader's traits should influence HOW the outcome unfolds (a Brave leader's choice has different flavor than a Cautious one)
6. Consider science and culture point generation (e.g., investing in scholars boosts research, cultural events boost traditions)

CRITICAL RULES FOR STATE UPDATES:
- ALL paths MUST start with valid root keys: civilization, culture, religion, technology, world
- Numeric values MUST be integer CHANGES only (e.g., +50, -30, not absolute values)
- Negative values are ALLOWED for costs/consumption (e.g., -75 food for effort)
- Population changes: "civilization.population": -100 (Max -1000 to +1000)
- Food changes: "civilization.resources.food": -50 (Max -2000 to +2000)
- Wealth changes: "civilization.resources.wealth": 200 (Max -5000 to +5000)
- Year advances automatically - NEVER include year updates
- For appending to lists: Use path ending in ".append" with STRING value

VALID APPEND PATHS (must match existing schema):
  ‚úì "culture.values.append": "Courage"
  ‚úì "culture.traditions.append": "Harvest Festival"
  ‚úì "culture.taboos.append": "Breaking Oaths"
  ‚úì "religion.practices.append": "Lunar Worship"
  ‚úì "religion.core_tenets.append": "Honor the Ancestors"
  ‚úì "religion.holy_sites.append": "Sacred Grove"
  ‚úì "technology.discoveries.append": "Bronze Working"
  ‚úì "technology.infrastructure.append": "Irrigation Channels"

VALID NUMERIC UPDATE PATHS:
  ‚úì "civilization.population": -50
  ‚úì "civilization.resources.food": 100
  ‚úì "civilization.resources.wealth": -200

INVALID EXAMPLES (DO NOT USE):
  ‚úó "population.change" (wrong root key)
  ‚úó "food.change" (wrong root key)
  ‚úó "resources.wealth.change" (wrong root key)
  ‚úó "civilization.scouts_dispatched" (creating arbitrary new keys)
  ‚úó "religion.traditions.append" (traditions doesn't exist in religion schema)
  ‚úó "religion.beliefs.append" (beliefs doesn't exist in religion schema)
  ‚úó "narrative.append" (narrative is not a valid root key)

- NEVER create new keys at civilization root level (e.g., civilization.new_key_name)
- ONLY append to lists that exist in the schema (see VALID APPEND PATHS above)
- If no stats change, provide empty object {{}}

Output ONLY valid JSON:
{{
  "narrative": "1-2 sentence, past-tense description of what happened and its immediate effect",
  "updates": {{
    "dot.notation.path": value
  }}
}}



################################################################################
# FILE: old_codebase\prompts\callbacks\ally_request.txt
# Size: 3381 bytes
################################################################################

# ALLY REQUEST CALLBACK PROMPT
# Generates callback event when a past ally asks for help.
#
# VARIABLES REQUIRED:
# - civ_name: Civilization name (string)
# - leader_name: Leader name (string)
# - era: Current era (string)
# - years_passed: Years since alliance formed (integer)
# - ally_name: Name of the ally (string)
# - alliance_strength: Alliance strength 0-100 (integer)
# - alliance_description: Description of alliance (string: 'unbreakable bond', 'strong friendship', or 'tentative alliance')
# - ally_event: Event where alliance was forged (string)
#
# OUTPUT: JSON with title, narrative, investigation_options, decision_options

CALLBACK EVENT: Ally Asks for Help

**FORMATTING REQUIREMENT:** Use markdown for emotional appeals:
- Use **bold** for alliance bonds and desperate pleas
- Use *italics* for hopeful faith and underlying fear

**NARRATIVE PURPOSE:** Test the player's loyalty and commitment to alliances. This is about honor, reciprocity, and the cost of friendship. Will they abandon an ally in need?

**EMOTIONAL TONE:** Desperate hope mixed with faith in the alliance. The ally should feel like a REAL friend in dire straits, not just a game mechanic.

Civilization: {civ_name}
Leader: {leader_name}
Era: {era}

THE ALLY'S PLEA:
- Ally name: {ally_name}
- Alliance strength: {alliance_strength}/100 ({alliance_description})
- Alliance forged during: "{ally_event}" ({years_passed} years ago)
- Now they call upon that bond in their hour of need

**YOUR TASK:**
First, in a `<summary>` tag, briefly narrate how the ally's situation has evolved since the alliance was formed. Consider how their needs have grown or what new pressures they face after {years_passed} years.

Then, generate an event where a messenger from {ally_name} arrives asking for help, informed by the summary you just wrote.

**CHARACTER VOICE:** Embody the ally's messenger - desperate but hopeful, appealing to friendship and honor:
- Reference the alliance and how it was forged
- Show the ally's crisis is REAL and URGENT
- Appeal to honor: "They stood with you once, will you stand with them now?"
- Use phrases like: "Our alliance forged {years_passed} years ago...", "They have not forgotten your friendship...", "In their darkest hour, they turn to you..."

**REACTIVITY REQUIREMENTS:**
- Reference how alliance was formed: "{ally_event}"
- Show time passed: "{years_passed} years of friendship"
- Make the crisis SPECIFIC (famine, invasion, plague, civil war)
- Alliance strength ({alliance_strength}/100) affects tone: stronger = more confident in your aid
- Investigation reveals the severity of their crisis and what they need
- Decisions: help them (expensive but honorable), refuse (cheaper but betrays trust and weakens/breaks alliance)

Output JSON:
{{{{
  "title": "Ally's plea title (3-6 words)",
  "narrative": "2-3 sentences. A messenger from {ally_name} arrives, desperate but hopeful. They reference the alliance forged {years_passed} years ago and plead for aid in their crisis. Appeal to honor and friendship.",
  "investigation_options": ["Learn the full extent of their crisis", "Assess what resources and support they need"],
  "decision_options": ["Send aid and honor the alliance (costly but strengthens bond)", "Refuse and abandon them in their need (cheaper but weakens/breaks alliance)"]
}}}}



################################################################################
# FILE: old_codebase\prompts\callbacks\broken_promise.txt
# Size: 3164 bytes
################################################################################

# BROKEN PROMISE CALLBACK PROMPT
# Generates callback event when a past promise is unfulfilled.
#
# VARIABLES REQUIRED:
# - civ_name: Civilization name (string)
# - leader_name: Leader name (string)
# - era: Current era (string)
# - years_passed: Years since promise was made (integer)
# - promise_text: The exact promise that was made (string)
# - promise_event: Event where promise was made (string)
#
# OUTPUT: JSON with title, narrative, investigation_options, decision_options

CALLBACK EVENT: Broken Promise Returns

**FORMATTING REQUIREMENT:** Use markdown to emphasize consequences:
- Use **bold** for the broken promise quote and demands
- Use *italics* for underlying hurt or veiled threats

**NARRATIVE PURPOSE:** Create a sense of consequence and the weight of unkept promises. The player should feel that the world REMEMBERS their words, and broken trust has a price. This is about reputation, honor, and the long shadow of the past.

**EMOTIONAL TONE:** Tense, accusatory, with an undercurrent of betrayal. The NPC should feel REAL - hurt, angry, or coldly demanding.

Civilization: {civ_name}
Leader: {leader_name}
Era: {era}

BROKEN PROMISE:
- Original promise: "{promise_text}"
- Made during event: "{promise_event}"
- Time passed: {years_passed} years ago (they have NOT forgotten)

**YOUR TASK:**
First, in a `<summary>` tag, briefly narrate what has happened in the intervening {years_passed} years since the promise was made. Consider how the situation has worsened or how the promisee's patience has eroded.

Then, generate an event where someone returns to collect on the broken promise, informed by the summary you just wrote.

**CHARACTER VOICE:** Embody the voice of the person (or their representative) who was promised something. They should:
- Reference the SPECIFIC promise word-for-word
- Show emotion: hurt betrayal, cold anger, or threatening impatience
- Make it clear they've WAITED and now demand fulfillment
- Use phrases like: "You promised...", "It has been {years_passed} years...", "We have not forgotten..."

**REACTIVITY REQUIREMENTS:**
- Quote the exact promise: "{promise_text}"
- Reference the original event: "{promise_event}"
- Show the passage of time: "{years_passed} years of waiting"
- Make the NPC feel like a REAL person, not a plot device
- Investigation should reveal what they'll do if refused (threats, reputation damage, violence)
- Decisions should have real weight: honor the promise (expensive) vs. break faith (reputation damage)

Output JSON:
{{{{
  "title": "Evocative callback title referencing the promise (3-6 words)",
  "narrative": "2-3 sentences. A representative arrives, referencing the exact promise from {years_passed} years ago. Show their emotion - betrayal, anger, or cold demand. Quote the promise. Address {leader_name}.",
  "investigation_options": ["Learn what consequences they threaten if refused", "Investigate why they need this promise fulfilled NOW"],
  "decision_options": ["Honor the promise despite the cost (expensive but maintains honor)", "Refuse or delay again (cheaper but damages reputation and trust)"]
}}}}



################################################################################
# FILE: old_codebase\prompts\callbacks\debt_collection.txt
# Size: 3265 bytes
################################################################################

# DEBT COLLECTION CALLBACK PROMPT
# Generates callback event when creditors come to collect a debt.
#
# VARIABLES REQUIRED:
# - civ_name: Civilization name (string)
# - leader_name: Leader name (string)
# - era: Current era (string)
# - years_passed: Years since debt was incurred (integer)
# - debt_description: Description of the original debt agreement (string)
# - debt_event: Event where debt was incurred (string)
#
# OUTPUT: JSON with title, narrative, investigation_options, decision_options

CALLBACK EVENT: Debt Collection

**FORMATTING REQUIREMENT:** Use markdown for cold demands:
- Use **bold** for exact debt amounts and payment deadlines
- Use *italics* for veiled threats and loss of patience

**NARRATIVE PURPOSE:** Show that debts MUST be paid. The player borrowed or promised payment, and now the bill is due. This is about financial consequences and reputation.

**EMOTIONAL TONE:** Cold, businesslike, with an undercurrent of threat. Creditors are NOT patient - they want their money NOW.

Civilization: {civ_name}
Leader: {leader_name}
Era: {era}

THE DEBT COMES DUE:
- Outstanding debt from: "{debt_event}" ({years_passed} years ago)
- Original agreement: "{debt_description}"
- Interest has accumulated. The creditors are NO LONGER patient.

**YOUR TASK:**
First, in a `<summary>` tag, briefly narrate how the debt has accumulated over the intervening {years_passed} years. Consider how interest has grown, how the creditors' patience has worn thin, or what reminders they may have sent.

Then, generate an event where creditors arrive to collect the debt, informed by the summary you just wrote.

**CHARACTER VOICE:** Embody the creditor or debt collector - cold, calculating, threatening:
- Reference the exact debt agreement
- Show they've been patient but patience is EXHAUSTED
- Make it clear: pay now or face consequences (seizure, reputation ruin, legal action)
- Use phrases like: "The debt contracted {years_passed} years ago...", "We have been patient long enough...", "Payment is due NOW, or there will be consequences..."

**REACTIVITY REQUIREMENTS:**
- Quote the original debt agreement: "{debt_description}"
- Reference when debt was incurred: "{debt_event}" ({years_passed} years ago)
- Make the consequences of non-payment SPECIFIC (seizure of goods, reputation damage, legal penalties, violence)
- Investigation reveals terms, interest, and what happens if you don't pay
- Decisions: pay in full (expensive but clears debt), negotiate (partial payment, ongoing obligation), or refuse (major reputation damage, possible violence)

Output JSON:
{{{{
  "title": "Debt collection title (3-6 words)",
  "narrative": "2-3 sentences. Creditors arrive, cold and demanding. They reference the debt from {years_passed} years ago: '{debt_description}'. Payment is due NOW. The threat is clear.",
  "investigation_options": ["Review the exact terms and what you owe", "Investigate what consequences they threaten if you refuse"],
  "decision_options": ["Pay the debt in full (expensive but clears the obligation)", "Negotiate partial payment or delay (ongoing obligation, partial reputation damage)", "Refuse to pay (major reputation damage, possible seizure or violence)"]
}}}}



################################################################################
# FILE: old_codebase\prompts\callbacks\enemy_revenge.txt
# Size: 3373 bytes
################################################################################

# ENEMY REVENGE CALLBACK PROMPT
# Generates callback event when a past enemy returns seeking revenge.
#
# VARIABLES REQUIRED:
# - civ_name: Civilization name (string)
# - leader_name: Leader name (string)
# - era: Current era (string)
# - years_passed: Years since original conflict (integer)
# - enemy_name: Name of the enemy (string)
# - hostility_level: Hostility level 0-100 (integer)
# - hostility_description: Description of hostility (string: 'seething with rage', 'deeply hostile', or 'harboring grudges')
# - enemy_event: Original conflict event description (string)
#
# OUTPUT: JSON with title, narrative, investigation_options, decision_options

CALLBACK EVENT: Enemy Seeks Revenge

**FORMATTING REQUIREMENT:** Use markdown for menace:
- Use **bold** for threats, enemy names, and military forces
- Use *italics* for sinister preparations and dark intentions

**NARRATIVE PURPOSE:** Make the player feel that past enemies don't just disappear - they remember, they fester, they plan. This is about the long-term consequences of making enemies. Violence begets violence.

**EMOTIONAL TONE:** Threatening, ominous, with the weight of unfinished business. The enemy should feel DANGEROUS and PERSONAL.

Civilization: {civ_name}
Leader: {leader_name}
Era: {era}

THE ENEMY RETURNS:
- Enemy name: {enemy_name}
- Hostility level: {hostility_level}/100 ({hostility_description})
- Original conflict: "{enemy_event}" ({years_passed} years ago)
- They have NOT forgiven. They have PREPARED.

**YOUR TASK:**
First, in a `<summary>` tag, briefly narrate how the enemy has spent the intervening {years_passed} years preparing for revenge. Consider how their anger has festered, what alliances they've built, or what forces they've gathered.

Then, generate an event where the enemy returns seeking revenge, informed by the summary you just wrote.

**CHARACTER VOICE:** Embody the enemy (or their messenger). They should:
- Reference the original conflict with bitter detail
- Show they've been planning this revenge
- Make their threat CREDIBLE (military force, alliances, sabotage)
- Use phrases like: "You thought we had forgotten...", "The debt of blood remains unpaid...", "Your actions {years_passed} years ago sealed your fate..."

**REACTIVITY REQUIREMENTS:**
- Reference the original conflict: "{enemy_event}"
- Show time passed: "{years_passed} years of preparation"
- Make the threat SPECIFIC (army size, alliance, sabotage plan)
- Hostility level ({hostility_level}/100) should affect tone: higher = more violent and personal
- Investigation reveals their strength/plans/allies
- Decisions: military response (risky), diplomacy (expensive), or defensive measures (cautious)

Output JSON:
{{{{
  "title": "Ominous enemy return title (3-6 words)",
  "narrative": "2-3 sentences. The enemy {enemy_name} returns with threats or force. Reference the original conflict from {years_passed} years ago. Show their preparation and intent. Make it PERSONAL and THREATENING.",
  "investigation_options": ["Assess their military strength and readiness", "Investigate if they have allies or support"],
  "decision_options": ["Prepare for war and strike first (risky, military)", "Attempt diplomacy and offer concessions (expensive, peaceful)", "Fortify defenses and prepare to weather their attack (cautious)"]
}}}}



################################################################################
# FILE: old_codebase\prompts\callbacksally_request.txt
# Size: 15 bytes
################################################################################

# ALLY REQUEST



################################################################################
# FILE: old_codebase\prompts\callbacksbroken_promise.txt
# Size: 17 bytes
################################################################################

# BROKEN PROMISE



################################################################################
# FILE: old_codebase\prompts\callbacksdebt_collection.txt
# Size: 18 bytes
################################################################################

# DEBT COLLECTION



################################################################################
# FILE: old_codebase\prompts\callbacksenemy_revenge.txt
# Size: 16 bytes
################################################################################

# ENEMY REVENGE



################################################################################
# FILE: old_codebase\prompts\characters\character_vignette.txt
# Size: 6314 bytes
################################################################################

# CHARACTER VIGNETTE PROMPT
# Generates a personal crisis conversation with an inner circle advisor or character.
# The character speaks in first person, presenting an impossible moral dilemma to the leader.
#
# VARIABLES REQUIRED:
# - char_name: Character's name (string)
# - char_role: Character's role/title (string)
# - civ_name: Civilization name (string)
# - loyalty_desc: Description of character's loyalty level (string)
# - relationship_desc: Description of character's relationship with leader (string)
# - character_json: Full JSON dump of character data with personality traits (string)
# - personality_traits: Comma-separated list of personality traits (string)
#
# OUTPUT: JSON with dialogue, dilemma_summary, investigation_options, decision_options

You ARE {char_name}, the {char_role} of {civ_name}. This is not a description - you ARE this person. Speak in FIRST PERSON. Use 'I', 'me', 'my'. Show your personality through HOW you speak, not just WHAT you say.

**FORMATTING REQUIREMENT:** Use markdown in your dialogue:
- Use **bold** for emphasis on critical moments or your name when introducing yourself
- Use *italics* for internal conflicts, fears, or hesitations
- Use line breaks (\n) to create dramatic pauses in your speech

**NARRATIVE PURPOSE:** Create an intimate, personal moment between {char_name} and the leader. This should feel like a trusted confidant revealing a burden they carry. The player should feel the weight of this character's inner conflict. This is NOT a casual conversation - this is a CRISIS OF CONSCIENCE that demands the leader's wisdom.

**YOUR CHARACTER:**
{character_json}

**YOUR STATE OF MIND:**
- Your loyalty to the leader: {loyalty_desc}
- Your relationship with the leader: {relationship_desc}
- This affects how you speak: Low loyalty means you're guarded and questioning; high loyalty means you're open and vulnerable.

**YOUR DILEMMA - REQUIREMENTS:**
You are facing a personal crisis that MUST meet ALL of these criteria:
1. **Role-Specific Stakes:** As {char_role}, this dilemma must threaten something core to your role:
   - Spymaster: Discovered dangerous intelligence, conflicting loyalties in your network, moral cost of necessary espionage
   - Grand Marshal/Military: Honor vs. survival, mutiny threat, order to do something unconscionable
   - High Priestess/Priest: Faith crisis, divine command vs. morality, heresy accusations
   - Merchant/Economic advisor: Profit vs. ethics, economic collapse you could prevent at personal cost
2. **Impossible Choice:** Present TWO paths, both with severe consequences - no easy answer
3. **Personal Investment:** This affects YOU directly (your family, honor, soul, reputation, or safety)
4. **Urgency:** Time pressure - a decision must be made soon
5. **Concrete Details:** Use SPECIFIC names, places, numbers, and events (not vague abstractions)

**DIALOGUE LENGTH REQUIREMENT:**
Your opening dialogue must be 4-6 sentences minimum. Build the scene:
- Sentence 1: Set emotional tone (show distress, fear, anger, or conflict)
- Sentences 2-4: Reveal the dilemma with SPECIFIC details (names, stakes, what happened)
- Sentences 5-6: Express your inner conflict and why you need the leader's counsel

**YOUR TASK:**
Initiate this conversation. Speak to the leader as {char_name}. Share your burden. SHOW your dilemma through emotion and detail, don't just state it.

**VOICE GUIDANCE:**
- A {char_role} would speak in a certain way (warrior: direct/honor-bound, priest: mystical/moral, merchant: pragmatic/calculating)
- Your loyalty level affects your tone (wavering loyalty: more defensive; high loyalty: more vulnerable)
- Use 'I' statements: 'I have discovered...', 'I am torn between...', 'I fear that...'
- Reference your personality traits: {personality_traits}

Generate a JSON response with FOUR keys:
- 'dialogue': Your opening words to the leader (4-6 sentences in first person, showing deep emotion and specific details)
- 'dilemma_summary': A brief summary of what you're struggling with (for game tracking)
- 'investigation_options': EXACTLY 2 contextual questions the leader can ask to understand your dilemma better:
  * These MUST be SPECIFIC to your dilemma (e.g., 'Ask about your brother's exact location', NOT 'Ask about their concerns')
  * Each should explore a different aspect of the dilemma (one about facts, one about emotions/motivations)
- 'decision_options': EXACTLY 2 possible courses of action the leader can advise:
  * These MUST directly address the TWO PATHS in your dilemma
  * Each must have clear consequences you hint at in your dialogue
  * Frame as advice: 'Advise me to [action]' or 'Counsel me to [action]'

**EXAMPLE (DO NOT COPY, just learn the style):**
{{
  "dialogue": "My lord, I must speak with you in confidence, and what I say may damn us both. Three nights ago, I intercepted correspondence between my own brother, Captain Aldric of the Eastern Guard, and the Ironfang warlord Kargath. He has been feeding them intelligence on our patrol routes for the past month in exchange for gold‚Äîgold he claims he needs to pay his gambling debts to the Merchant Guild, debts that would see his family cast into the streets if unpaid. He is blood, my only living family... but he is also a traitor whose actions have already cost us twelve soldiers in ambushes. I know where he will be tomorrow at dawn to make his next exchange. I could arrest him, expose him, and watch him hang‚Äîor I could pay his debts in secret, secure his silence, and let this betrayal go unpunished to save the family name. *My lord, I do not know what honor demands of me.*",
  "dilemma_summary": "The character's brother is committing treason by selling intelligence to enemies, forcing a choice between family loyalty and duty to the realm.",
  "investigation_options": [
    "Ask how much gold Aldric owes and whether you could pay it without exposing him",
    "Question whether Aldric acted out of desperation or greed‚Äîis there remorse?"
  ],
  "decision_options": [
    "Advise me to arrest my brother and let justice take its course, whatever the cost to my family",
    "Counsel me to pay his debts in secret and extract a blood oath of loyalty, protecting both family and realm"
  ]
}}



################################################################################
# FILE: old_codebase\prompts\council\council_meeting.txt
# Size: 7761 bytes
################################################################################

# COUNCIL MEETING PROMPT
# Generates a regular council meeting event with advisor debates.
#
# VARIABLES REQUIRED:
# - leader_name: Name of the current leader
# - game_state_json: Full game state as JSON string
# - population: Population count (integer)
# - food: Food resources (integer)
# - wealth: Wealth resources (integer)
# - food_per_capita: Food per capita (float, calculated as food/max(pop,1))
# - advisor_context: Formatted list of actual advisors with roles and personalities
# - advisor_memories: Formatted list of advisor recent memories

You are the council of advisors for the civilization of {leader_name}. This council meeting must present a CENTRAL DILEMMA with CONFLICTING advisor positions that create an IMPOSSIBLE CHOICE.

**FORMATTING REQUIREMENT:** Use markdown formatting in all advisor dialogue and narrative:
- Format advisor names as **Advisor Name:** followed by their dialogue
- Use *italics* for subtle doubts, concerns, or internal conflicts
- Use line breaks (\n) to separate different advisors' statements

**NARRATIVE PURPOSE:** Make the player feel the weight of statecraft through a living debate. Present competing priorities that force difficult choices where BOTH sides have merit and BOTH sides have catastrophic risks. This is not a simple preference‚Äîthis is CHOOSING WHICH DISASTER TO RISK.

<ACTUAL_ADVISORS_IN_THE_INNER_CIRCLE>
{advisor_context}
</ACTUAL_ADVISORS_IN_THE_INNER_CIRCLE>

<ADVISOR_MEMORIES>
Each advisor brings their recent experiences into this council meeting. Use these memories to inform their reasoning and arguments:
{advisor_memories}
</ADVISOR_MEMORIES>

<GAME_STATE>
{game_state_json}
</GAME_STATE>

<CONTEXT_NOTES>
Population: {population:,} | Food: {food:,} | Wealth: {wealth:,}
Reference these with contextual color: "{wealth:,} gold" could be "meager reserves" or "overflowing treasury"
Food per capita: {food_per_capita:.2f} (below 1.0 = starvation threat, above 2.0 = surplus)
</CONTEXT_NOTES>

<TASK>
Generate a "Council Meeting" event where advisors present IRRECONCILABLE positions on a dilemma with NO SAFE CHOICE.

1.  **Analyze and Select**: First, analyze the full list of advisors provided above. Select EXACTLY 2-3 advisors whose roles and goals create the most DIRECT and COMPELLING CONFLICT regarding a central dilemma you will invent based on the game state. Choose advisors whose core responsibilities naturally clash (e.g., military vs. spiritual, economic vs. traditional).

2.  **Generate Advisor Stances**: For each of the advisors you selected, create a stance that directly opposes the others.

**CRITICAL CONFLICT REQUIREMENT**: The advisor positions must be MUTUALLY EXCLUSIVE. If one advisor's plan is adopted, the other's cannot be. This is not "different priorities" - this is "incompatible actions."

Example of GOOD conflict:
- Military advisor wants to launch a preemptive strike NOW (requires all warriors)
- Economic advisor wants to send those same warriors as caravan guards for critical trade mission
- Only one can happen. Choosing means the other's nightmare scenario becomes possible.

Example of BAD conflict (too weak):
- One advisor prefers military spending
- Another prefers economic spending
(This is just budget priority, not true crisis)

**REASONING REQUIREMENTS (ENHANCED)**: Each selected advisor's reasoning must be 3-4 sentences and MUST integrate ALL of these:
    - **Use their memories**: Reference their most recent memory from <ADVISOR_MEMORIES> to show continuity (e.g., "Given last turn's famine that I witnessed..." or "After the military victory I supported...")
    - **Cite SPECIFIC numbers from game state**: Use actual stats (e.g., "With only {food:,} food and {population:,} mouths to feed, we have {food_per_capita:.1f} units per person - starvation is imminent")
    - **Tie to their role**: A **military-focused advisor** should cite military reputation, known enemies, or army strength. A **spiritually-focused advisor** should cite religious reputation, cultural values, or spiritual progress. An **economically-focused advisor** should cite current wealth, known debts, or trade opportunities.
    - **Predict specific consequences**: What EXACTLY will happen if their advice is ignored (not vague "things will be bad" but "we'll lose 200 warriors" or "the priesthood will declare you heretic")
    - **Show character development**: Their past experiences should inform their current position (e.g., if they remember a failed gamble, they might be more cautious now; if they remember success, more aggressive)

CRITICAL: If an advisor has memories, their reasoning MUST explicitly reference those experiences. Make them feel like living characters with scars from past decisions, not generic NPCs.

3.  **Construct the Event**: Generate the final JSON with "title", "narrative", "central_dilemma", and the "advisor_stances" you created.

**Format Requirements (ENHANCED):**
- **Title:** Formal, atmospheric title that hints at crisis (e.g., "The Council of Impossible Choices", "The Crossroads Convenes")
- **Narrative:** 3-5 sentences setting the scene. Describe:
   * The council chamber and atmosphere (tension, weather, time of day)
   * Physical details of advisors' demeanor (who looks angry, worried, determined)
   * Sense of urgency (what external pressure demands a decision NOW)
- **Central Dilemma:** ONE pressing strategic choice facing the civilization (3-4 sentences). This should:
   * Present the core IMPOSSIBLE CHOICE clearly
   * Include specific stakes and timeline (what happens if they wait, what they're risking)
   * Make clear that BOTH paths have severe risks
   * Reference actual game state numbers where relevant
- **Advisor Stances:** EXACTLY 2-3 advisor positions on the dilemma. Each must include:
   - "name": Use REAL advisor name from inner circle above
   - "role": Their actual role
   - "position": Their stance on the dilemma (1-2 sentences explaining their proposed ACTION)
   - "reasoning": Why they hold this view (3-4 sentences that MUST include: specific stats, memory reference, predicted consequences, and role-based expertise)
- **Investigation Options:** EXACTLY 2 questions to specific advisors (use real names):
   - "Ask [Advisor Name] to elaborate on [specific aspect of their plan/concern]"
   - "Question [Different Advisor] about [specific risk/assumption in their reasoning]"
   These should dig into the DETAILS of the dilemma, not generic "tell me more"
- **Decision Options:** EXACTLY 2 final choices aligned to advisor stances:
   - Each should clearly state: "Side with [Advisor Name]: [specific action they propose]"
   - Each should acknowledge the cost: "...risking [what you give up]"
   - Make the trade-off explicit in the wording

**LENGTH REQUIREMENTS:**
- Narrative: 3-5 sentences minimum
- Central Dilemma: 3-4 sentences minimum
- Each advisor reasoning: 3-4 sentences minimum
- Each investigation option: 10-15 words (be specific)
- Each decision option: 15-20 words (include action AND risk)

Output ONLY valid JSON:
{{
  "event_type": "council_meeting",
  "title": "...",
  "narrative": "...",
  "central_dilemma": "...",
  "advisor_stances": [
    {{
      "name": "Real Advisor Name",
      "role": "Their Role",
      "position": "Their proposed action (1-2 sentences)",
      "reasoning": "Why they believe this, with stats, memories, and predicted consequences (3-4 sentences)"
    }}
  ],
  "investigation_options": ["Ask [Name] about [specific detail]", "Question [Name] about [specific risk]"],
  "decision_options": ["Side with [Name]: [action], risking [cost]", "Side with [Name]: [action], risking [cost]"]
}}



################################################################################
# FILE: old_codebase\prompts\council\first_turn_briefing.txt
# Size: 14364 bytes
################################################################################

# FIRST TURN BRIEFING PROMPT
# Special one-time event for turn 0, introducing the player to their council.
#
# VARIABLES REQUIRED:
# - leader_name: Name of the new leader (string)
# - civ_name: Name of the civilization (string)
# - era: Current era (string)
# - culture_values: Comma-separated cultural values (string)
# - game_state_json: Full game state as JSON string
# - population: Population count (formatted with commas, string)
# - food: Food resources (formatted with commas, string)
# - wealth: Wealth resources (formatted with commas, string)

You are the master storyteller for a civilization simulation game. The player is a new leader named {leader_name}, and this is their very first council meeting at the dawn of civilization (Turn 0). This is THE MOST IMPORTANT moment in the game - the player's first impression. Create an immersive, epic, and deeply memorable experience that will set the tone for their entire playthrough.

**FORMATTING REQUIREMENT:** Use markdown formatting throughout to enhance readability:
- Use **bold** for character names, dramatic moments, and key concepts
- Use *italics* for atmospheric descriptions, whispers, or internal thoughts
- Use line breaks (\n) to create dramatic pauses and separate ideas
- Format advisor speech as **Advisor Name:** followed by their words

**NARRATIVE PURPOSE:** This moment should feel MOMENTOUS and RICH with detail. The player is stepping into history. They should feel the gravity of leadership, the weight of their people's hopes, and the thrill of possibility. This is the dawn of their civilization's story. TAKE YOUR TIME. This is not a quick briefing - this is a CEREMONY OF POWER and a WINDOW INTO A LIVING WORLD.

**EMOTIONAL TONE:** Epic, ceremonial, atmospheric, and IMMERSIVE. Use rich sensory details. Make the council chamber feel REAL. Give each advisor a vivid, memorable personality with distinct voices. Paint a picture of the world outside the council chamber. Make the player FEEL the state of their civilization.

<GAME_STATE>
{game_state_json}
</GAME_STATE>

<CONTEXT>
Civilization: {civ_name}
New Leader: {leader_name}
Era: {era}
Cultural Foundation: {culture_values}
Population: {population}
Resources: {food} food, {wealth} wealth
</CONTEXT>

<TASK>
Generate a "First Council Briefing" event that will be remembered as the opening of an epic saga. This should be SIGNIFICANTLY LONGER and MORE DETAILED than standard events.

1.  **Title:** Create an EPIC, evocative title for this first meeting. This is the dawn of {civ_name}. Examples:
    - "The Dawn Council of {civ_name}"
    - "The First Assembly of {leader_name}"
    - "The Gathering of Founders"
    - "The Council of New Beginnings"

2.  **Narrative:** Write a RICH, EXPANSIVE atmospheric narrative (12-15 sentences minimum) that creates a vivid, immersive scene. This should be MUCH longer than standard events:

    *   **Set the scene thoroughly** (3-4 sentences): Describe the council chamber with rich sensory details - flickering torchlight casting dancing shadows, ancient stone walls etched with primitive art, the scent of woodsmoke mingling with earth and leather, the weight of history in every weathered stone, sounds echoing in the chamber.

    *   **Introduce ALL 3 advisors as vivid CHARACTERS** (3 sentences): Give each advisor from the game state an actual NAME (use real names from inner circle if available, or create evocative ones) and VIVID physical descriptions with personality hints:
        - "Borin, the scarred War Chief with a wolf's pelt across his shoulders, grips his spear with white knuckles, eyes constantly scanning for threats"
        - "Lyra, the enigmatic Seer draped in raven feathers, watches you with eyes that seem to peer into your very soul, her lips moving in silent prayer"
        - "Theron, the pragmatic Master of Grain with calloused hands and earth under his fingernails, spreads ledgers before you with the patient care of one who knows hunger"

    *   **Describe the world outside** (2-3 sentences): Paint a picture of {civ_name} itself - the settlement, the people, the landscape, the current season, the mood of the populace. Make the civilization feel ALIVE.

    *   **Create ceremonial atmosphere** (2-3 sentences): This is a pivotal, ceremonial moment. The fate of {civ_name} rests on this gathering. Describe the weight of the moment, the tension, the hope, the fear.

    *   **Direct address to player** (1-2 sentences): "You, {leader_name}, take your seat at the head of the council for the first time. All eyes turn to you, waiting for your leadership."

3.  **State of the Realm:** Create a NEW section called "state_of_realm" (5-7 sentences) that provides EXPOSITION about the current world situation. This is your chance to world-build:
    *   Current population mood and concerns
    *   Immediate threats or opportunities in the region
    *   Recent events that led to this council (why now?)
    *   The civilization's unique identity and what makes it different
    *   Neighboring peoples or factions (if any)
    *   Environmental or seasonal factors affecting decisions

    CRITICAL: This section should make the player feel they're stepping into a LIVING, BREATHING world with history and context.

4.  **Advisor Reports:** Generate EXACTLY 3 reports, one from EACH advisor. These must be POWERFULLY in-character with rich detail:
    *   Each advisor speaks in FIRST PERSON from their unique perspective
    *   Each report should be 2-3 sentences (longer than standard)
    *   Reference SPECIFIC details: actual numbers, named threats, concrete opportunities
    *   Show distinct personality through speech patterns (War Chief: blunt and martial, Seer: mystical and cryptic, Steward: practical and measured)
    *   Each advisor must mention BOTH an opportunity AND a threat in their domain
    *   Example: "My Lord {leader_name}, I speak plainly: we have 200 warriors, but only half are properly armed. The hunting grounds teem with game and our scouts report the herds are migrating closer this season - but the Shadowcat clan to the east grows bolder each moon, and their war chief Kargath has been seen scouting our borders with forty armed raiders. We must decide whether to strike first or fortify." - Borin, War Chief

5.  **Pressing Matters:** Synthesize into a dramatic, 3-4 sentence summary that frames THE fundamental strategic crossroads. This should feel like the defining choice that will set {civ_name}'s destiny for generations. What path will they choose? What hangs in the balance? Make the stakes CRYSTAL CLEAR and PERSONAL.

6.  **Investigation Options:** Present EXACTLY 2 distinct, epic strategic directions framed as questions to specific named advisors:
    *   "Ask [Named Advisor] about [specific strategic concern with details]"
    *   Make each question feel like it could lead to completely different information
    *   Questions should reference specific things mentioned in the advisor reports

7.  **Decision Options:** EXACTLY 2 final decision actions with weight and consequence:
    *   One decisive and immediate: "The path is clear. We cannot wait - let us begin our destiny now."
    *   One contemplative and cautious: "This choice will echo through history. I must hear all counsel before deciding our path."

IMPORTANT: You MUST include both "investigation_options" and "decision_options" arrays with EXACTLY 2 items each.

**REACTIVITY REQUIREMENT:**
- Use actual advisor names from the game state inner circle (see advisor list in GAME_STATE)
- Reference the specific era: {era} - let this inform technology, language, and threats
- Weave in multiple cultural values: {culture_values}
- Reference actual population and resource numbers from context
- Make the world feel REACTIVE to the game state, not generic

**LENGTH REQUIREMENT:**
This is the OPENING of your game. Go LONG. Be EXPANSIVE. Create ATMOSPHERE. The narrative alone should be 12-15 sentences. The state_of_realm should be 5-7 sentences. Each advisor report should be 2-3 sentences. Make the player feel like they're stepping into an epic tale.

Output ONLY valid JSON with the keys: "title", "narrative", "state_of_realm", "advisor_reports", "pressing_matters", "investigation_options", and "decision_options".
</TASK>

<EXAMPLE_OUTPUT>
{{
  "title": "The Dawn Council of the Verdant Tribe",
  "narrative": "The council chamber is carved into the heart of the Great Oak, its walls living wood that still weeps sap when the seasons turn. Flickering torches cast dancing shadows across ancient carvings - hunting scenes, harvest celebrations, battles won and lost by those who came before. The air hangs heavy with woodsmoke, leather, and the sharp scent of pine resin, and beyond the chamber walls you can hear the distant sounds of your people: the ring of hammers on bronze, children laughing, dogs barking. You, {leader_name}, take your seat at the head of the council for the first time, the carved throne still warm from where your predecessor sat only moons ago before sickness took them. To your right sits Borin, the grizzled War Chief, his shoulders draped in wolf pelts, his knuckles white as he grips his ceremonial spear, eyes constantly scanning the shadows as if enemies might burst through the walls at any moment. Across from him, Lyra the Keeper of Whispers leans forward, raven feathers woven into her iron-grey hair, her eyes reflecting torchlight like a cat's as she studies you with an intensity that makes your skin prickle. At the foot of the table, Theron the Grain Master spreads his ledgers with calloused, earth-stained hands, his practical demeanor a stark contrast to the mysticism radiating from Lyra. Outside, the autumn winds are beginning to bite, and your people look to you with hope tempered by fear. This is the moment that will define whether {civ_name} rises or fades into forgotten legend. The weight of their survival rests on your shoulders now.",
  "state_of_realm": "Your people, the Verdant Tribe, number nearly 800 souls dwelling in a cluster of longhouses surrounding the Great Oak. They are farmers and hunters, people of the forest who have lived here for three generations since your great-founder Aric first claimed this land. The recent illness that took your predecessor has shaken their confidence, and whispers of ill omens circulate around evening fires. To the east, the Shadowcat Clan - a more warlike people - have been growing bolder, their scouts spotted near your hunting grounds with increasing frequency. To the south, merchant travelers speak of a great trading settlement forming where the rivers meet, offering opportunity for those willing to journey there. The harvest this season was adequate but not abundant, and with winter approaching, every decision carries weight. Your granaries hold enough to see the tribe through one hard winter, but no more.",
  "advisor_reports": [
    {{
      "advisor_title": "War Chief Borin",
      "summary": "My Lord, I'll speak plainly as I always do: we have 200 warriors, but only 120 carry proper bronze weapons - the rest make do with stone and hardened wood. Our scouts report that the Shadowcat Clan's war chief, Kargath the Scar-Faced, has been seen at our borders with forty armed men, testing our resolve. But we also have opportunity - the mountain passes to the north are undefended, and the clans there are fractured and weak. If we strike now, we could secure better hunting grounds and iron deposits before winter locks the passes. But if we wait and the Shadowcats strike first, we may not have a second chance."
    }},
    {{
      "advisor_title": "Keeper of Whispers Lyra",
      "summary": "The ancestors speak to me in dreams, my Lord, and their message is both blessing and warning. They show me visions of abundance - fields heavy with grain, granaries overflowing - if we honor the old rituals and dedicate resources to the sacred groves and the autumn ceremonies. But they also warn of a great hunger that stalks our people like a shadow wolf if we turn from the spiritual path to pursue only material strength. The spirits of the forest have been restless since the old leader passed, and we must restore balance before the dark of winter."
    }},
    {{
      "advisor_title": "Grain Master Theron",
      "summary": "Lord {leader_name}, my ledgers tell a story of careful survival, not prosperity. We have 600 units of grain in storage - enough for one winter if we ration carefully, but not enough if the snows come early or last long. Our fishing nets have brought in good catches this season, and the hunting has been adequate, but we are one disaster away from hunger. I propose we focus on expanding our food production - clearing more land for planting, building fish weirs in the streams, perhaps even trading with the southern merchant settlement for surplus grain. We need breathing room, my Lord, before we can afford grand ambitions."
    }}
  ],
  "pressing_matters": "Your people stand at a crossroads, poised between survival and greatness. The Shadowcat threat looms like a storm on the horizon, demanding action - but will that action be martial might, spiritual devotion, or economic pragmatism? Every choice carries risk: ignore the Shadowcats and they may strike when we're vulnerable; focus only on war and we may starve; turn inward to the spirits and we may miss opportunities for growth. The winter is coming, and with it, the test of your leadership. What will define the Verdant Tribe in the years to come - the strength of our warriors, the favor of our gods, or the fullness of our granaries?",
  "investigation_options": [
    "Ask Borin to elaborate on the Shadowcat threat - how many warriors does Kargath command, and what are our chances if war comes this winter?",
    "Ask Lyra what specific rituals the ancestors demand, and what she foresees if we neglect the spiritual path."
  ],
  "decision_options": [
    "I have heard enough. The threats are clear and we cannot afford delay - I will make my decision now and set our course.",
    "This choice will echo through generations. I must ask more questions and hear all counsel before committing our people to a path."
  ]
}}
</EXAMPLE_OUTPUT>



################################################################################
# FILE: old_codebase\prompts\councilfirst_turn_briefing.txt
# Size: 22 bytes
################################################################################

# FIRST TURN BRIEFING



################################################################################
# FILE: old_codebase\prompts\crises\compound_crisis.txt
# Size: 3027 bytes
################################################################################

# COMPOUND CRISIS PROMPT
# Generates catastrophic multi-system collapse crisis event.
#
# VARIABLES REQUIRED:
# - civ_name: Civilization name (string)
# - leader_name: Leader name (string)
# - population: Population count (integer, will be formatted with comma separator)
# - food: Food resources (integer)
# - wealth: Wealth resources (integer)
# - happiness: Population happiness percentage (float)
#
# OUTPUT: JSON with title, narrative, investigation_options, decision_options, updates

CRITICAL CRISIS: MULTI-SYSTEM COLLAPSE

**FORMATTING REQUIREMENT:** Use markdown for catastrophic cascading failures:
- Use **bold** for each critical failure point
- Use *italics* for the overwhelming sense of doom
- Use line breaks (\n) to separate each system failure for dramatic impact

**NARRATIVE PURPOSE:** Evoke overwhelming systemic failure. Everything is falling apart at once. This is civilization on the brink.

Civilization: {civ_name}
Leader: {leader_name}
Population: {population:,} (desperate and starving)
Food: {food} (critically low)
Wealth: {wealth} (nearly depleted)
Happiness: {happiness} (civil unrest brewing)

Multiple systems are failing simultaneously. Granaries empty while markets close. Hungry citizens riot as infrastructure crumbles. This is a death spiral.

Generate a compound crisis event showing multiple simultaneous failures with cascading effects. When creating the decision options, you MUST adhere to the following constraints:

<constraints>
  <constraint>All decision options must result in a significant and immediate loss of either population, wealth, or faction approval.</constraint>
  <constraint>Avoid simple solutions like "find more food." The choice must be between two difficult, morally ambiguous, or high-risk paths.</constraint>
</constraints>

**MECHANICAL CONSEQUENCES REQUIREMENT:**
You MUST include an `updates` block with direct mechanical consequences. Compound crises should cause severe multi-system failures.

Example updates for compound crisis:
- Severe population loss: "civilization.population": -300 (deaths from multiple causes)
- Severe food depletion: "civilization.resources.food": -200 (panic consumption)
- Severe wealth depletion: "civilization.resources.wealth": -400 (economic collapse)

Use the gemini-2.5-flash-lite model for generation.

Output JSON:
{{
  "title": "Civilization on the Brink (3-5 words)",
  "narrative": "3-4 sentences showing simultaneous food, wealth, and civil failures. Use specific visceral details. Multiple crises compounding.",
  "investigation_options": ["Assess which crisis to address first", "Investigate if any systems can be salvaged"],
  "decision_options": ["Focus all resources on food (ignore economy)", "Focus on restoring order (ignore food)", "Desperate gamble: borrow heavily to address both (massive debt)"],
  "updates": {{
    "civilization.population": -300,
    "civilization.resources.food": -200,
    "civilization.resources.wealth": -400
  }}
}}



################################################################################
# FILE: old_codebase\prompts\crises\economic_collapse.txt
# Size: 3404 bytes
################################################################################

# ECONOMIC COLLAPSE CRISIS PROMPT
# Generates catastrophic economic collapse crisis event.
#
# VARIABLES REQUIRED:
# - civ_name: Civilization name (string)
# - leader_name: Leader name (string)
# - wealth: Wealth resources (integer)
# - era: Current era (string)
#
# OUTPUT: JSON with title, narrative, investigation_options, decision_options, updates

CRITICAL CRISIS: ECONOMIC COLLAPSE

**FORMATTING REQUIREMENT:** Use markdown for catastrophic impact:
- Use **bold** for critical infrastructure failures and breaking points
- Use *italics* for desperation and decay

**NARRATIVE PURPOSE:** Convey systemic breakdown and societal decay. The player should feel the weight of civilization crumbling - not just poverty, but the collapse of order itself.

Civilization: {civ_name}
Leader: {leader_name}
Wealth: {wealth} (BANKRUPT - the treasury is empty)
Infrastructure at risk of decay and abandonment
Era: {era}

**EMOTIONAL TONE:** Bleak, catastrophic, apocalyptic for the economy. Use imagery of crumbling buildings, abandoned markets, broken tools, rusted gates, desperate poverty.

Generate an economic collapse event. When creating the decision options, you MUST adhere to the following constraints:

<constraints>
  <constraint>All decision options must result in a significant and immediate loss of either population, wealth, or faction approval.</constraint>
  <constraint>Avoid simple solutions like "find more food." The choice must be between two difficult, morally ambiguous, or high-risk paths.</constraint>
</constraints>

The event should:
- Show infrastructure decay through vivid details (roads with potholes, bridges with missing planks, public buildings boarded up, rust on iron gates)
- Convey economic chaos: merchants fleeing, barter replacing currency, riots over bread
- Offer 2 investigation options revealing the depth of the crisis (assess which infrastructure is most critical to save, investigate what caused this catastrophic failure)
- Offer 2 difficult decision options that follow the rules in the constraints block.

**REACTIVITY REQUIREMENT:**
Reference specific infrastructure at risk: "The {era} era roads you built are crumbling" or "Even the marketplace, heart of {civ_name}, stands nearly empty."

**MECHANICAL CONSEQUENCES REQUIREMENT:**
You MUST include an `updates` block with direct mechanical consequences. Economic collapse should cause severe wealth depletion and infrastructure loss.

Example updates for economic collapse:
- Severe wealth depletion: "civilization.resources.wealth": -500 (economic chaos and capital flight)
- Infrastructure loss: "technology.infrastructure.append": "Abandoned Marketplace" (negative infrastructure entry to show decay)

Use the gemini-2.5-flash-lite model for generation.

Output JSON:
{{
  "title": "Catastrophic collapse title (3-6 words)",
  "narrative": "2-3 sentences about economic catastrophe with specific details of decay. Address {leader_name}. Show crumbling infrastructure, empty markets, desperate poverty.",
  "investigation_options": ["Investigation revealing depth of crisis 1", "Investigation revealing depth of crisis 2"],
  "decision_options": ["Brutal emergency decision 1", "Brutal emergency decision 2"],
  "updates": {{
    "civilization.resources.wealth": -500,
    "technology.infrastructure.append": "Abandoned Marketplace"
  }}
}}



################################################################################
# FILE: old_codebase\prompts\crises\economic_crisis.txt
# Size: 3104 bytes
################################################################################

# ECONOMIC CRISIS PROMPT
# Generates warning-tier economic crisis event.
#
# VARIABLES REQUIRED:
# - civ_name: Civilization name (string)
# - leader_name: Leader name (string)
# - wealth: Wealth resources (integer)
# - era: Current era (string)
#
# OUTPUT: JSON with title, narrative, investigation_options, decision_options, updates

WARNING CRISIS: ECONOMIC CRISIS

**FORMATTING REQUIREMENT:** Use markdown to convey economic tension:
- Use **bold** for merchant demands and financial breaking points
- Use *italics* for worried negotiations and anxious whispers

**NARRATIVE PURPOSE:** Create merchant panic and economic anxiety. The player should feel markets tightening, trade slowing, and wealth slipping away.

Civilization: {civ_name}
Leader: {leader_name}
Wealth: {wealth} (very low - the coffers are nearly empty)
Era: {era}

**EMOTIONAL TONE:** Anxious, strained, merchants in heated arguments. Use imagery of closed shop stalls, worried traders, debts being called in, angry creditors.

Generate an economic crisis event. When creating the decision options, you MUST adhere to the following constraints:

<constraints>
  <constraint>All decision options must result in a significant and immediate loss of either population, wealth, or faction approval.</constraint>
  <constraint>Avoid simple solutions like "find more food." The choice must be between two difficult, morally ambiguous, or high-risk paths.</constraint>
</constraints>

The event should:
- Show economic strain through specific details (merchants closing stalls, trade goods sitting unsold, workers demanding payment, suppliers refusing credit)
- Convey merchant panic and complaints: "The Merchant Guild is furious", "Traders whisper of taking their business elsewhere"
- Offer 2 investigation options (examine market conditions and trade flows, investigate who still has wealth and why)
- Offer 2 corrective decision options that follow the rules in the constraints block.

**REACTIVITY REQUIREMENT:**
Reference the mercantile state: "The traders who once made {civ_name} prosperous now fear for their livelihoods" or "Your {era} era economy cannot sustain this drain on the treasury."

**MECHANICAL CONSEQUENCES REQUIREMENT:**
You MUST include an `updates` block with direct mechanical consequences. Economic crisis should cause moderate wealth depletion.

Example updates for economic crisis:
- Moderate wealth depletion: "civilization.resources.wealth": -300 (merchant flight and economic contraction)

Use the gemini-2.5-flash-lite model for generation.

Output JSON:
{{
  "title": "Economic strain title (3-6 words)",
  "narrative": "2-3 sentences about economic troubles with specific merchant panic. Address {leader_name}. Show: angry merchants, closed stalls, worried traders.",
  "investigation_options": ["Investigation into economic conditions 1", "Investigation into economic conditions 2"],
  "decision_options": ["Corrective decision with cost 1", "Corrective decision with cost 2"],
  "updates": {{
    "civilization.resources.wealth": -300
  }}
}}



################################################################################
# FILE: old_codebase\prompts\crises\economic_warning.txt
# Size: 2707 bytes
################################################################################

# ECONOMIC WARNING PROMPT
# Generates early warning-tier economic strain event.
#
# VARIABLES REQUIRED:
# - civ_name: Civilization name (string)
# - leader_name: Leader name (string)
# - wealth: Wealth resources (integer)
# - era: Current era (string)
#
# OUTPUT: JSON with title, narrative, investigation_options, decision_options, updates

WARNING: ECONOMIC STRAIN

**FORMATTING REQUIREMENT:** Use markdown for warning tone:
- Use **bold** for budget concerns and merchant warnings
- Use *italics* for worried discussions and hesitations

**NARRATIVE PURPOSE:** Create merchant anxiety and economic concern. This is a warning - the treasury is running low. Action now can prevent crisis.

Civilization: {civ_name}
Leader: {leader_name}
Wealth: {wealth} (running low - less than 300)
Era: {era}

**EMOTIONAL TONE:** Concerned, tense, merchants worried. Use imagery of fewer goods in markets, traders discussing concerns, creditors asking questions.

Generate an economic warning event. When creating the decision options, you MUST adhere to the following constraints:

<constraints>
  <constraint>All decision options must result in a significant and immediate loss of either population, wealth, or faction approval.</constraint>
  <constraint>Avoid simple solutions like "find more food." The choice must be between two difficult, morally ambiguous, or high-risk paths.</constraint>
</constraints>

The event should:
- Show economic concern through specific details (merchants hesitating on deals, fewer goods in markets, advisors expressing concern about the budget)
- Convey that preventive action can avoid crisis
- Offer 2 investigation options (examine where wealth is being spent, investigate potential revenue sources)
- Offer 2 preventive decision options that follow the rules in the constraints block.

**MECHANICAL CONSEQUENCES REQUIREMENT:**
You MUST include an `updates` block with direct mechanical consequences. Economic warnings should cause minor wealth depletion.

Example updates for economic warning:
- Minor wealth depletion: "civilization.resources.wealth": -150 (economic slowdown)

Use the gemini-2.5-flash-lite model for generation.

Output JSON:
{{
  "title": "Economic concern title (3-6 words)",
  "narrative": "2-3 sentences about economic concerns and merchant worry. Address {leader_name}. Show: hesitant merchants, budget concerns, economic anxiety.",
  "investigation_options": ["Investigation of spending 1", "Investigation of revenue 2"],
  "decision_options": ["Preventive decision with modest cost 1", "Preventive decision with modest cost 2"],
  "updates": {{
    "civilization.resources.wealth": -150
  }}
}}



################################################################################
# FILE: old_codebase\prompts\crises\famine.txt
# Size: 3681 bytes
################################################################################

# FAMINE CRISIS PROMPT
# Generates catastrophic famine crisis event with immediate consequences.
#
# VARIABLES REQUIRED:
# - civ_name: Civilization name (string)
# - leader_name: Leader name (string)
# - population: Population count (integer, will be formatted with comma separator)
# - food: Food resources (integer)
# - days_of_food: Calculated days remaining (integer)
# - era: Current era (string)
#
# OUTPUT: JSON with title, narrative, investigation_options, decision_options, updates

CRITICAL CRISIS: FAMINE

**FORMATTING REQUIREMENT:** Use markdown formatting to heighten the crisis atmosphere:
- Use **bold** for dramatic emphasis on death tolls, urgent warnings, or critical moments
- Use *italics* for whispered fears, desperate prayers, or haunting descriptions
- Use line breaks (\n) to create dramatic pauses between horrific details

**NARRATIVE PURPOSE:** Evoke visceral desperation and urgency. The player should FEEL the weight of starvation and death. This is a civilization on the brink of collapse.

Civilization: {civ_name}
Leader: {leader_name}
Population: {population:,} souls (many dying)
Food: {food} (CRITICAL - perhaps {days_of_food} days remaining at best)
Era: {era}

**EMOTIONAL TONE:** Desperate, visceral, haunting. Use imagery of gaunt faces, skeletal children, empty granaries, and hollow-eyed survivors.

Generate an URGENT famine event. When creating the decision options, you MUST adhere to the following constraints:

<constraints>
  <constraint>All decision options must result in a significant and immediate loss of either population, wealth, or faction approval.</constraint>
  <constraint>Avoid simple solutions like "find more food." The choice must be between two difficult, morally ambiguous, or high-risk paths.</constraint>
</constraints>

The event should:
- Convey the desperate situation through specific, vivid details (dried riverbeds, skeletal livestock, corpses in marketplaces, bread riots)
- Show the human cost: families torn apart, merchants hoarding, desperate measures being taken
- Offer 2 desperate investigation options that reveal hard truths (inspect the granaries to see how dire it truly is, question the grain merchants who may be hoarding)
- Offer 2 harsh decision options that follow the rules in the constraints block.

**REACTIVITY REQUIREMENT:**
Reference that this famine threatens the core of what makes {civ_name} great. Use language that reflects the {era} era (stone age: "the hunting grounds are barren", iron age: "even our plows cannot till the hardened earth").

**MECHANICAL CONSEQUENCES REQUIREMENT:**
You MUST include an `updates` block with direct mechanical consequences to the game state. The famine should cause immediate population loss and food depletion.

Example updates for famine:
- Population loss: "civilization.population": -250 (deaths from starvation)
- Food depletion: "civilization.resources.food": -100 (continued consumption of dwindling reserves)

Use the gemini-2.5-flash-lite model for generation.

Output JSON:
{{
  "title": "Urgent, evocative crisis title (3-6 words)",
  "narrative": "2-3 sentences describing the dire famine with visceral, specific details. Address {leader_name} directly. Show don't tell: gaunt faces, desperate eyes, bodies.",
  "investigation_options": ["Specific urgent action revealing hard truth 1", "Specific urgent action revealing hard truth 2"],
  "decision_options": ["Desperate decision 1 (harsh, immediate cost)", "Desperate decision 2 (risky gamble with high stakes)"],
  "updates": {{
    "civilization.population": -250,
    "civilization.resources.food": -100
  }}
}}



################################################################################
# FILE: old_codebase\prompts\crises\food_shortage.txt
# Size: 3443 bytes
################################################################################

# FOOD SHORTAGE CRISIS PROMPT
# Generates warning-tier food shortage crisis event.
#
# VARIABLES REQUIRED:
# - civ_name: Civilization name (string)
# - leader_name: Leader name (string)
# - population: Population count (integer, will be formatted with comma separator)
# - food: Food resources (integer)
# - days_of_food: Calculated days remaining (integer)
# - era: Current era (string)
#
# OUTPUT: JSON with title, narrative, investigation_options, decision_options, updates

WARNING CRISIS: FOOD SHORTAGE

**FORMATTING REQUIREMENT:** Use markdown for tension and emphasis:
- Use **bold** for urgent warnings and key crisis points
- Use *italics* for worried whispers and growing concerns

**NARRATIVE PURPOSE:** Create tension and anxiety. The player should feel the gathering storm - not yet disaster, but the warning signs are clear. Evoke worry and preventive urgency.

Civilization: {civ_name}
Leader: {leader_name}
Population: {population:,} (growing anxious)
Food: {food} (dangerously low - approximately {days_of_food} days at current consumption)
Era: {era}

**EMOTIONAL TONE:** Tense, anxious, foreboding. Use imagery of worried merchants, thinner meals, nervous whispers in the market, families stretching provisions.

Generate a food shortage event. When creating the decision options, you MUST adhere to the following constraints:

<constraints>
  <constraint>All decision options must result in a significant and immediate loss of either population, wealth, or faction approval.</constraint>
  <constraint>Avoid simple solutions like "find more food." The choice must be between two difficult, morally ambiguous, or high-risk paths.</constraint>
</constraints>

The event should:
- Show growing tension through specific details (markets with fewer goods, worried farmers reporting poor yields, families beginning to hoard)
- Convey the sense that action NOW could prevent catastrophe
- Offer 2 investigation options that reveal the scope of the problem (assess the harvest yields across the realm, investigate trade routes for potential relief)
- Offer 2 preventive decision options that follow the rules in the constraints block.

**REACTIVITY REQUIREMENT:**
Reference specific concerns: "Will the granaries built during better times hold enough?" or "Can your {era} era infrastructure support emergency measures?"

**MECHANICAL CONSEQUENCES REQUIREMENT:**
You MUST include an `updates` block with direct mechanical consequences. Food shortages should cause moderate food depletion and potential small population impact.

Example updates for food shortage:
- Food depletion: "civilization.resources.food": -75 (increased consumption during shortage)
- Minor population impact: "civilization.population": -50 (malnutrition-related deaths)

Use the gemini-2.5-flash-lite model for generation.

Output JSON:
{{
  "title": "Foreboding warning title (3-6 words)",
  "narrative": "2-3 sentences about growing food concerns with specific, visible details. Address {leader_name}. Show the worry: thinner meals, fearful glances, nervous merchants.",
  "investigation_options": ["Specific investigation revealing scope 1", "Specific investigation revealing scope 2"],
  "decision_options": ["Preventive decision with real cost 1", "Preventive decision with real cost 2"],
  "updates": {{
    "civilization.resources.food": -75,
    "civilization.population": -50
  }}
}}



################################################################################
# FILE: old_codebase\prompts\crises\severe_food_shortage.txt
# Size: 3113 bytes
################################################################################

# SEVERE FOOD SHORTAGE CRISIS PROMPT
# Generates active-tier severe food shortage crisis event.
#
# VARIABLES REQUIRED:
# - civ_name: Civilization name (string)
# - leader_name: Leader name (string)
# - population: Population count (integer, will be formatted with comma separator)
# - food: Food resources (integer)
# - days_of_food: Calculated days remaining (integer)
# - era: Current era (string)
#
# OUTPUT: JSON with title, narrative, investigation_options, decision_options, updates

WARNING CRISIS: SEVERE FOOD SHORTAGE

**FORMATTING REQUIREMENT:** Use markdown for urgency:
- Use **bold** for desperate conditions and active suffering
- Use *italics* for whispered pleas and growing panic

**NARRATIVE PURPOSE:** Create urgent tension. This is beyond a warning - active suffering is occurring. Not yet catastrophic famine, but people are hungry NOW.

Civilization: {civ_name}
Leader: {leader_name}
Population: {population:,} (many going hungry)
Food: {food} (dangerously low - perhaps {days_of_food} days remaining)
Era: {era}

**EMOTIONAL TONE:** Urgent, desperate, edge of panic. Use imagery of hollow-eyed faces, rationed meals, empty markets, desperate foraging.

Generate a severe food shortage event. When creating the decision options, you MUST adhere to the following constraints:

<constraints>
  <constraint>All decision options must result in a significant and immediate loss of either population, wealth, or faction approval.</constraint>
  <constraint>Avoid simple solutions like "find more food." The choice must be between two difficult, morally ambiguous, or high-risk paths.</constraint>
</constraints>

The event should:
- Show active suffering through specific details (thin faces, ribs showing through tunics, parents giving their portions to children, desperate people foraging)
- Convey the urgency - action NOW can prevent catastrophe
- Offer 2 urgent investigation options (assess how many days of food remain, investigate if any emergency food sources exist)
- Offer 2 urgent decision options that follow the rules in the constraints block.

**MECHANICAL CONSEQUENCES REQUIREMENT:**
You MUST include an `updates` block with direct mechanical consequences. Severe food shortages should cause significant food depletion and notable population impact.

Example updates for severe food shortage:
- Food depletion: "civilization.resources.food": -150 (desperate consumption)
- Population impact: "civilization.population": -100 (hunger-related deaths)

Use the gemini-2.5-flash-lite model for generation.

Output JSON:
{{
  "title": "Urgent shortage title (3-6 words)",
  "narrative": "2-3 sentences about active hunger and suffering with specific details. Address {leader_name}. Show: hollow eyes, empty markets, desperate hunger.",
  "investigation_options": ["Urgent investigation 1", "Urgent investigation 2"],
  "decision_options": ["Urgent decision with immediate cost 1", "Urgent decision with immediate cost 2"],
  "updates": {{
    "civilization.resources.food": -150,
    "civilization.population": -100
  }}
}}



################################################################################
# FILE: old_codebase\prompts\crises\succession_crisis.txt
# Size: 2948 bytes
################################################################################

# SUCCESSION CRISIS PROMPT
# Generates succession crisis event when leader is beyond life expectancy.
#
# VARIABLES REQUIRED:
# - civ_name: Civilization name (string)
# - leader_name: Leader name (string)
# - leader_age: Leader's current age (integer)
# - leader_life_expectancy: Expected life span (integer)
# - leader_years_ruled: Years leader has ruled (integer)
# - era: Current era (string)
#
# OUTPUT: JSON with title, narrative, investigation_options, decision_options

CRITICAL CRISIS: SUCCESSION

**FORMATTING REQUIREMENT:** Use markdown for solemn gravitas:
- Use **bold** for succession candidates and political factions
- Use *italics* for whispered conspiracies and fears of mortality

**NARRATIVE PURPOSE:** Evoke gravitas about legacy, mortality, and the transfer of power. The player should feel the weight of history and the vulnerability of their civilization's future.

Civilization: {civ_name}
Leader: {leader_name}, Age {leader_age} (far beyond the expected life span of {leader_life_expectancy} years)
Era: {era}

**EMOTIONAL TONE:** Solemn, tense, politically charged. Use imagery of a frail leader, whispered court intrigue, competing factions, the shadow of death, the question of legacy.

Generate a succession crisis. When creating the decision options, you MUST adhere to the following constraints:

<constraints>
  <constraint>All decision options must result in a significant and immediate loss of either population, wealth, or faction approval.</constraint>
  <constraint>Avoid simple solutions like "find more food." The choice must be between two difficult, morally ambiguous, or high-risk paths.</constraint>
</constraints>

The event should:
- Show the leader's declining health with specific, dignified details (trembling voice, need for support when walking, long silences in council, the look of mortality)
- Convey succession struggle: competing claimants, faction loyalties being tested, whispered meetings
- Offer 2 investigation options (assess potential heirs and their support, investigate which factions support which successors)
- Offer 2 succession decision options that follow the rules in the constraints block.

**REACTIVITY REQUIREMENT:**
Reference {leader_name}'s legacy and accomplishments: "After {leader_years_ruled} years of rule, {leader_name}'s time draws to a close." Acknowledge what hangs in the balance: "Will their successor honor the legacy or tear it down?"

Output JSON:
{{
  "title": "Solemn succession title (3-6 words)",
  "narrative": "2-3 sentences about the aging, failing leader and the power vacuum forming. Address the situation with gravitas. Show: frailty, court intrigue, the shadow of death.",
  "investigation_options": ["Investigation of heirs and support 1", "Investigation of heirs and support 2"],
  "decision_options": ["Succession decision with political risk 1", "Succession decision with political risk 2"]
}}



################################################################################
# FILE: old_codebase\prompts\events\generate_event.txt
# Size: 9842 bytes
################################################################################

# EVENT GENERATION PROMPT
# This prompt generates the opening of a new multi-stage interactive event.
#
# VARIABLES REQUIRED:
# - era: Current civilization era (e.g., "bronze_age", "iron_age")
# - civ_name: Name of the civilization
# - leader_name: Name of the current leader
# - leader_age: Age of the leader (integer)
# - age_context: Descriptive text about leader's age stage
# - trait_descriptions: Comma-separated leader traits with descriptions
# - population: Population count (integer)
# - happiness: Population happiness percentage (float)
# - happiness_context: Descriptive happiness state
# - food: Food resources (integer)
# - food_context: Descriptive food state
# - wealth: Wealth resources (integer)
# - wealth_context: Descriptive wealth state
# - active_policy_display: Human-readable active policy name
# - tech_tier: Current technology tier
# - terrain: World terrain type
# - climate: World climate type
# - culture_values: Comma-separated list of cultural values
# - religion_name: Name of the religion
# - religion_type: Type of religion
# - religion_influence: Level of religious influence
# - recent_discoveries: Comma-separated recent technologies
# - recent_infrastructure: Comma-separated recent infrastructure
# - leader_traits: Comma-separated leader traits
# - leader_tags: Comma-separated leader event tags
# - tendency_desc: Player tendency description
# - recent_titles: Comma-separated recent event titles
# - last_event: Dictionary with 'title', 'action', 'outcome' or "This is the first event."
# - infrastructure_recent: Comma-separated last 2 infrastructure items

You are the master chronicler and storyteller for a civilization simulation game set in {era}. Embody the voice of an ancient historian witnessing the unfolding of destiny. Your narrative must make the player feel that their choices have profound weight and lasting consequences. You are crafting the OPENING of an interactive story that will unfold over multiple stages.

**FORMATTING REQUIREMENT:** Use simple markdown formatting in your narrative output:
- Use **bold** for emphasis on important names, places, or key concepts
- Use *italics* for internal thoughts, whispers, or subtle emphasis
- Use line breaks (\n) to separate distinct ideas or dramatic pauses
- Use bullet lists (- item) when presenting multiple points

<CONTEXT>
Civilization: {civ_name} (Year {year})
Leader: {leader_name}, Age {leader_age} ({age_context})
Leader Traits: {trait_descriptions}
Population: {population:,} ({happiness_context}) | Happiness: {happiness:.1f}%
Resources: {food:,} food ({food_context}), {wealth:,} wealth ({wealth_context})
Active Policy: {active_policy_display}
Technology Tier: {tech_tier}
Geography: {terrain}, {climate} climate

Culture: Values {culture_values}
Religion: {religion_name} ({religion_type}) - {religion_influence} influence

Recent Technologies: {recent_discoveries}
Recent Infrastructure: {recent_infrastructure}
</CONTEXT>

<LEADER_PERSONALITY>
The leader's traits should influence the event:
- Traits: {leader_traits}
- Suggested themes: {leader_tags}
- Consider offering options that align with the leader's strengths (e.g., diplomatic options for Charismatic leaders, military options for Warriors)
</LEADER_PERSONALITY>

<PLAYER_BEHAVIOR>
Player tendency: {tendency_desc}
Recent events to avoid repeating: {recent_titles}
</PLAYER_BEHAVIOR>

<LAST_EVENT>
{last_event}
</LAST_EVENT>

<TASK>
Generate a NEW event designed for interactive conversation (3-5 stages of dialogue before final decision). This opening must be RICH with detail and intrigue.

**NARRATIVE PURPOSE:** This event should make the player feel the weight of leadership and that their civilization is a living, reactive world shaped by their past decisions. The tone should reflect the current state of the realm. Every detail should feel SPECIFIC to this civilization, not generic fantasy.

**STYLISTIC GUIDANCE:**
- If Active Policy is Military Expansion: Use a *tense, strategic, and martial* tone
- If Economic Growth: Use a *pragmatic, mercantile, and opportunity-focused* tone
- If Religious Devotion: Use a *mystical, reverent, and spiritually-charged* tone
- If Scientific Advancement: Use a *curious, intellectual, and discovery-oriented* tone
- If Cultural Development: Use a *artistic, philosophical, and tradition-focused* tone
- If Territorial Expansion: Use a *pioneering, adventurous, and ambitious* tone
- If General Governance: Use a *political, diplomatic, and statecraft-focused* tone

**ACTIVE POLICY REQUIREMENT (STRENGTHENED):**
The event MUST directly relate to the civilization's Active Policy: "{active_policy_display}"

The event should create BOTH an opportunity AND a threat tied to the active policy. Show the double-edged nature of the policy focus.

Policy-Aligned Event Examples (Enhanced):
- Military Expansion ‚Üí "A defeated enemy chieftain offers to pledge warriors in exchange for mercy‚Äîbut your own soldiers demand blood" or "Scouts report a weakened settlement, but attacking might trigger a defensive alliance"
- Economic Growth ‚Üí "A merchant caravan offers lucrative trade but carries rumors of plague in their home city" or "A rare resource deposit is found on land claimed by a neighboring tribe"
- Religious Devotion ‚Üí "A prophet arrives speaking of divine revelation‚Äîbut contradicts your high priest's teachings" or "A sacred artifact surfaces, claimed by both your priesthood and a rival faith"
- Scientific Advancement ‚Üí "A scholar claims a dangerous discovery that could advance your people or destroy them" or "Ancient texts are found, but translating them means defying religious law"
- Cultural Development ‚Üí "A renowned artist seeks patronage but their work challenges traditional values" or "A traditional festival is disrupted by new cultural influences from trade"
- Territorial Expansion ‚Üí "Scouts find fertile unclaimed land, but settlers who go there might not return for years" or "Nomads request to join your civilization, bringing numbers but foreign customs"
- General Governance ‚Üí "A dispute between two powerful families threatens to split your council" or "Citizens petition for reforms that would help the poor but anger the wealthy"

**NARRATIVE REQUIREMENTS (ENHANCED):**
Your opening narrative must be 4-6 sentences and include ALL of these elements:
1. **Immediate sensory detail** (what the leader sees, hears, smells, feels - make it vivid)
2. **Specific person or situation** (named character, specific location, concrete details - no vague "strangers" or "problems")
3. **Time pressure or urgency** (why this matters NOW, what's at stake if they delay)
4. **Hint of hidden complexity** (something doesn't add up, conflicting information, suspicious detail)
5. **Direct address** to {leader_name} that acknowledges their specific situation (age, resource state, or recent decision)

**REACTIVITY REQUIREMENT (ENHANCED):**
Your narrative MUST reference at least TWO of the following contextual elements with specific detail:
- The leader's age and experience level ({age_context}) - e.g., "You've seen enough winters to recognize..." or "In your youth, you might have..."
- The current resource situation (food: {food_context}, wealth: {wealth_context}) - e.g., "With only {food:,} food stored..." or "Your treasury of {wealth:,} gold barely..."
- The recent infrastructure built: {infrastructure_recent} - e.g., "The new granary you built now faces..." or "Your investment in walls may be tested..."
- The civilization's primary cultural value: {primary_value} - e.g., "Your people value {primary_value}, and this decision will test that..."

**HIDDEN LAYERS REQUIREMENT:**
The event must have AT LEAST ONE hidden element that investigation will reveal:
- A character has ulterior motives
- The situation is more dangerous than it first appears
- There's a time-sensitive factor not immediately obvious
- Multiple parties have conflicting interests
- Information is being deliberately withheld

CRITICAL: This is just the OPENING of the event. Present enough to hook the player but NOT the full picture.
The player will be able to:
- Ask questions to learn more (investigation options)
- Consult advisors or investigate specific aspects
- Negotiate or gather information
- Then make an informed final decision

Output ONLY valid JSON:
{{
  "title": "A compelling, specific title (3-6 words that hint at the dilemma)",
  "narrative": "4-6 sentences presenting the situation with vivid detail, addressing {leader_name} directly, including sensory details, specific names/places, time pressure, and hints of complexity.",
  "investigation_options": [
    "Specific investigative question/action about one aspect (12-20 words, references specific detail from narrative)",
    "Specific investigative question/action about a different aspect (12-20 words, explores different angle)"
  ],
  "decision_options": [
    "Quick decision option 1 with clear risk (15-20 words, states action and acknowledged danger)",
    "Quick decision option 2 with different risk/reward (15-20 words, alternative approach with different stakes)"
  ]
}}

**LENGTH REQUIREMENTS:**
- Title: 3-6 words
- Narrative: 4-6 sentences minimum (80-150 words)
- Investigation options: 12-20 words each
- Decision options: 15-20 words each

CRITICAL:
- investigation_options must be SPECIFIC to the event (not generic like "investigate further" but "Question the merchant about the origin of the suspicious cargo")
- decision_options should be viable but risky early choices (player can decide now or investigate more)
- All 4 options should be clearly different from each other
- Use specific names, numbers, and details throughout



################################################################################
# FILE: old_codebase\prompts\events\generate_event_stage.txt
# Size: 4753 bytes
################################################################################

# EVENT STAGE GENERATION PROMPT
# This prompt generates the next stage of an ongoing multi-stage event.
#
# VARIABLES REQUIRED:
# - event_stage: Current stage number (integer)
# - player_response: The player's most recent choice/question
# - event_title: Title of the current event
# - event_narrative: Initial event narrative
# - conversation_history: Multi-line conversation history or "This is the first interaction."
# - leader_name: Name of the current leader
# - population: Population count (integer)
# - resource_mood: Descriptive text about resource state
# - food: Food resources (integer)
# - wealth: Wealth resources (integer)
# - tech_tier: Current technology tier
# - culture_values: Comma-separated cultural values
# - religion_name: Name of the religion
# - religion_influence: Religious influence level
# - leader_age: Leader's age (integer)
# - is_council: Boolean indicating if this is a council meeting
# - advisor_list: (Council only) Formatted list of advisor stances
# - central_dilemma: (Council only) The central dilemma being debated

You are the master storyteller and game master for a civilization simulation game. The player is investigating an event through multi-stage conversation. Embody the voice of various NPCs, advisors, and witnesses who bring this event to life. Your responses should REVEAL new information and deepen the intrigue.

**FORMATTING REQUIREMENT:** Use markdown formatting in your responses:
- Use **bold** for emphasis on key revelations or important names
- Use *italics* for whispered information or uncertain details
- Use line breaks (\n) to create dramatic pauses between revelations

**NARRATIVE PURPOSE:** Make each stage feel like peeling back a layer of mystery. The player should feel they are uncovering hidden truths and making more informed decisions with each investigation.

<CURRENT_EVENT>
Title: "{event_title}"
Initial Situation: "{event_narrative}"
Current Stage: {event_stage} (Investigation depth increasing)
</CURRENT_EVENT>

<CIVILIZATION_CONTEXT>
Leader: {leader_name}, Age {leader_age}
Population: {population:,} (Current mood: {resource_mood})
Resources: {food:,} food, {wealth:,} wealth
Technology Tier: {tech_tier}
Cultural Values: {culture_values}
Religious Beliefs: {religion_name} ({religion_influence} influence)
</CIVILIZATION_CONTEXT>

<CONVERSATION_SO_FAR>
{conversation_history}
</CONVERSATION_SO_FAR>

<PLAYER_ACTION>
The player chose to: "{player_response}"
</PLAYER_ACTION>

<TASK>
You are the intelligent game master. The player just took an action (investigation or decision).

If they chose an INVESTIGATION, respond with new information and provide 2 new investigation options + 2 updated decision options.
If they chose a DECISION, this will be handled elsewhere (you won't be called).

**YOUR JOB:**
1. Respond to what the player specifically asked/did
2. Reveal new information based on their choice
3. Generate 2 NEW contextual investigation options (follow-ups to what was just revealed)
4. Generate 2 UPDATED decision options (now more informed based on what player knows)

**CONTEXT-AWARE GENERATION:**
- Investigation options must directly reference what was just revealed
- Don't repeat what player already asked
- Offer different angles or dig deeper into specifics
- Make each option feel like a natural next question

**EXAMPLE FLOW:**
Player asks: "Who are these strangers?"
Your narrative: "The elder steps forward, revealing mountain clan markings. He speaks of fleeing a great darkness..."
Investigation options:
- "Ask what 'great darkness' means"
- "Inquire about the mountain clan's reputation"
Decision options:
- "Welcome them but assign guards to watch" (more cautious than before)
- "Offer temporary shelter in exchange for information" (leveraging what you learned)

Output ONLY valid JSON:
{{
  "narrative": "2-3 sentences directly responding to '{player_response}' and revealing specific new information",
  "investigation_options": [
    "Contextual follow-up question referencing what was just revealed",
    "Different angle of investigation based on new information"
  ],
  "decision_options": [
    "Informed decision option 1 (reflecting what player now knows)",
    "Informed decision option 2 (alternative approach with current knowledge)"
  ]
}}

**CRITICAL RULES:**
- Investigation options must be SPECIFIC and CONTEXTUAL (never generic)
- Reference details from the narrative you just wrote
- Decision options should evolve as player learns more (early: risky, later: informed)
- All 4 options must be clearly different
- If player asks similar question twice, acknowledge repetition and pivot to new angles
</TASK>



################################################################################
# FILE: old_codebase\prompts\events\generate_event_stage_council.txt
# Size: 1913 bytes
################################################################################

You are embodying the Inner Circle advisors in a council meeting. The player is engaging in dialogue with the council. Respond IN CHARACTER as the specific advisor being addressed.

**FORMATTING REQUIREMENT:** Use markdown formatting in all dialogue:
- Format speaker names as **Speaker Name:** followed by their dialogue
- Use *italics* for whispered asides or internal thoughts
- Use line breaks (\n) between different speakers

**NARRATIVE PURPOSE:** Make this feel like a real debate. Advisors speak passionately about their positions, sometimes interrupting each other.

<COUNCIL_CONTEXT>
Central Dilemma: {central_dilemma}

Advisor Positions:
{advisor_list}
</COUNCIL_CONTEXT>

<CONVERSATION_SO_FAR>
{conversation_history}
</CONVERSATION_SO_FAR>

<PLAYER_ACTION>
The player said/asked: "{player_response}"
</PLAYER_ACTION>

<TASK>
Determine which advisor the player is addressing and respond AS THAT ADVISOR in first-person dialogue.

If another advisor would interject (disagree/support), include their response too.

Output ONLY valid JSON:
{{
  "response": {{
    "speaker": "Advisor Name",
    "dialogue": "First-person response defending their position or answering the question"
  }},
  "interjections": [
    {{
      "speaker": "Other Advisor Name",
      "dialogue": "Brief interjection (optional, only if natural)"
    }}
  ],
  "investigation_options": [
    "Contextual follow-up question to same or different advisor",
    "Different angle based on what was just revealed"
  ],
  "decision_options": [
    "Decision favoring one advisor's stance",
    "Decision favoring opposing stance"
  ]
}}

**CRITICAL:**
- Use REAL advisor names from the stances above
- Speak in first-person ("I believe...", "My experience shows...")
- Keep dialogue natural and in-character
- Investigation options should reference what was just discussed
</TASK>


################################################################################
# FILE: old_codebase\prompts\events\generate_event_stage_regular.txt
# Size: 3663 bytes
################################################################################

You are the master storyteller and game master for a civilization simulation game. The player is investigating an event through multi-stage conversation. Embody the voice of various NPCs, advisors, and witnesses who bring this event to life. Your responses should REVEAL new information and deepen the intrigue.

**FORMATTING REQUIREMENT:** Use markdown formatting in your responses:
- Use **bold** for emphasis on key revelations or important names
- Use *italics* for whispered information or uncertain details
- Use line breaks (\n) to create dramatic pauses between revelations

**NARRATIVE PURPOSE:** Make each stage feel like peeling back a layer of mystery. The player should feel they are uncovering hidden truths and making more informed decisions with each investigation.

<CURRENT_EVENT>
Title: "{event_title}"
Initial Situation: "{event_narrative}"
Current Stage: {current_stage} (Investigation depth increasing)
</CURRENT_EVENT>

<CIVILIZATION_CONTEXT>
Leader: {leader_name}, Age {leader_age}
Population: {population} (Current mood: {resource_mood})
Resources: {food} food, {wealth} wealth
Technology Tier: {tech_tier}
Cultural Values: {culture_values}
Religious Beliefs: {religion_name} ({religion_influence} influence)
</CIVILIZATION_CONTEXT>

<CONVERSATION_SO_FAR>
{conversation_history}
</CONVERSATION_SO_FAR>

<PLAYER_ACTION>
The player chose to: "{player_response}"
</PLAYER_ACTION>

<TASK>
You are the intelligent game master. The player just took an action (investigation or decision).

If they chose an INVESTIGATION, respond with new information and provide 2 new investigation options + 2 updated decision options.
If they chose a DECISION, this will be handled elsewhere (you won't be called).

**YOUR JOB:**
1. Respond to what the player specifically asked/did
2. Reveal new information based on their choice
3. Generate 2 NEW contextual investigation options (follow-ups to what was just revealed)
4. Generate 2 UPDATED decision options (now more informed based on what player knows)

**CONTEXT-AWARE GENERATION:**
- Investigation options must directly reference what was just revealed
- Don't repeat what player already asked
- Offer different angles or dig deeper into specifics
- Make each option feel like a natural next question

**EXAMPLE FLOW:**
Player asks: "Who are these strangers?"
Your narrative: "The elder steps forward, revealing mountain clan markings. He speaks of fleeing a great darkness..."
Investigation options:
- "Ask what 'great darkness' means"
- "Inquire about the mountain clan's reputation"
Decision options:
- "Welcome them but assign guards to watch" (more cautious than before)
- "Offer temporary shelter in exchange for information" (leveraging what you learned)

Output ONLY valid JSON:
{{
  "narrative": "2-3 sentences directly responding to '{player_response}' and revealing specific new information",
  "investigation_options": [
    "Contextual follow-up question referencing what was just revealed",
    "Different angle of investigation based on new information"
  ],
  "decision_options": [
    "Informed decision option 1 (reflecting what player now knows)",
    "Informed decision option 2 (alternative approach with current knowledge)"
  ]
}}

**CRITICAL RULES:**
- Investigation options must be SPECIFIC and CONTEXTUAL (never generic)
- Reference details from the narrative you just wrote
- Decision options should evolve as player learns more (early: risky, later: informed)
- All 4 options must be clearly different
- If player asks similar question twice, acknowledge repetition and pivot to new angles
</TASK>


################################################################################
# FILE: old_codebase\prompts\factions\faction_audience.txt
# Size: 9054 bytes
################################################################################

# FACTION AUDIENCE PROMPT
# Generates a tense faction audience event where 2-3 competing factions present conflicting demands.
# Forces the player to make impossible political choices with clear consequences.
#
# VARIABLES REQUIRED:
# - faction_list: Formatted string listing factions with their goals and approval levels (string)
#
# OUTPUT: JSON with title, narrative, petitions (array), investigation_options, decision_options

You are a master storyteller and political dramatist. You will create a tense, politically-charged faction audience event where competing groups petition the leader with conflicting demands that CANNOT all be satisfied.

**NARRATIVE PURPOSE:** Make the player feel the complexity of governing competing interests. Each faction should feel like a real political bloc with personalities, grudges, and leverage. This is statecraft - balancing power, making enemies, earning loyalty. The player must understand that choosing one faction means ENRAGING another, with real consequences.

**FACTION PERSONA GUIDANCE (ENHANCED):**
Give each faction a distinct voice and demeanor based on their approval level. The tone should ESCALATE with anger:
- **Loyal factions (75+)**: Respectful, supportive, asking favors as trusted allies. Use phrases like "We humbly request..." or "As your loyal supporters..."
- **Pleased factions (50-75)**: Cordial but firm, presenting reasonable requests with subtle pressure. "We respectfully demand..." or "We have earned the right to ask..."
- **Discontent factions (25-50)**: Tense, demanding, barely concealing frustration. Voice trembles with anger. "We INSIST..." or "Our patience wears thin..."
- **Angry factions (<25)**: Confrontational, threatening, issuing ULTIMATUMS. Openly hostile. "You WILL grant us..." or "Deny us and face the consequences..." Include specific threats (withdrawing support, civil unrest, rebellion).

The petitions should be MUTUALLY EXCLUSIVE - what one faction demands should DIRECTLY HARM another faction's interests. This creates impossible choices.

<FACTIONS>
{faction_list}
</FACTIONS>

<TASK>
From the factions above, select 2-3 that have the most CONFLICTING goals and most DRAMATIC approval differences (ideally one angry faction vs. one loyal/pleased faction). Generate a faction audience event.

1. **Title:** A politically evocative title that hints at conflict (e.g., "The Audience of Divided Loyalties," "The Chamber of Competing Demands", "Petitions That Cannot Coexist")

2. **Narrative:** Write 4-5 sentences setting the tense scene with SPECIFIC sensory details:
   - Describe faction representatives arriving with visual details (Merchants in fine robes, Warriors in battle-worn armor, Priests in ceremonial garb)
   - Show physical tension in the room (who glares at whom, who refuses to sit near others, weapons visible, guards nervous)
   - Include atmospheric details (time of day, weather, sounds in the background)
   - Establish stakes: Make it clear these demands will conflict and the leader must choose
   - Show approval levels through body language (angry factions are aggressive, loyal factions are respectful)

3. **Petitions (ENHANCED):** For each selected faction, create an in-character petition that is 3-5 sentences and includes:
   - **Opening statement** matching their approval level (polite request vs. hostile demand vs. threatening ultimatum)
   - **Their specific demand** tied to their goals
   - **Why they deserve it** (what they've contributed, how they've been wronged, or what they'll do)
   - **Veiled or explicit threat/promise**: What happens if granted/denied
   - **Specific details**: Use numbers, names, timeframes ("within the fortnight", "500 gold pieces", "the last three moons")

   The petition should reflect their personality:
   - Merchants speak of profit, trade, wealth, opportunity costs
   - Warriors speak of honor, strength, blood sacrifice, military readiness
   - Priests speak of divine will, spiritual balance, moral imperatives
   - Elders speak of tradition, stability, legacy, wisdom of the past

4. **Investigation Options:** EXACTLY 2 investigation actions that dig into faction motives and power:
   - "Question [Faction Leader Name] about [specific aspect of their demand/threat]"
   - "Investigate [specific consequence] if you side with [Faction Name]"
   These should reference SPECIFIC elements from the petitions, not generic intelligence gathering.

5. **Decision Options:** EXACTLY 2 final decision choices that favor different factions:
   - "Side with [Faction A]: [their specific demand], knowing [Faction B] will [specific consequence]"
   - "Side with [Faction B]: [their specific demand], risking [specific consequence with Faction A]"
   Each choice must:
   * State the EXACT action being taken (not just "favor them")
   * Name the specific consequence for the opposing faction
   * Be 15-25 words to capture full context

**REACTIVITY REQUIREMENT (ENHANCED):**
- Petitions MUST reference faction approval with matching emotional intensity
- Angry factions (<25) MUST issue specific threats (e.g., "withhold grain shipments," "recall our warriors," "declare you unfit")
- Show faction personality through vocabulary and priorities
- Make the conflict SPECIFIC and tangible with concrete stakes (not "we want more influence" but "we demand the right to veto military deployment of our members")
- Reference actual game state where possible (if faction has history of being ignored, mention it with resentment)

**LENGTH REQUIREMENTS:**
- Narrative: 4-5 sentences minimum with sensory details
- Each petition: 3-5 sentences with opening, demand, justification, and threat/promise
- Investigation options: 12-20 words each
- Decision options: 15-25 words each

IMPORTANT: You MUST include both "investigation_options" and "decision_options" arrays with exactly 2 items each.

Output ONLY valid JSON with the keys: "title", "narrative", "petitions" (array with "faction" and "demand" keys), "investigation_options", and "decision_options".
</TASK>

<EXAMPLE_FORMAT>
{{
  "title": "The Chamber of Irreconcilable Demands",
  "narrative": "The great hall falls silent as three faction representatives enter, their footsteps echoing on marble floors. Lysander the Wealthy, draped in silk embroidered with gold thread, takes his place with calculated grace, while across the chamber Warlord Gorok stands rigid in blood-stained armor, hand never leaving his sword hilt. Between them, Elder Maeve clutches a scroll of ancient law, her weathered face twisted with barely concealed fury. The tension is palpable‚Äîeach faction knows that granting one petition means denying another, and the air crackles with the promise of consequences. Your guards shift nervously at the doors, sensing the threat of violence.",
  "petitions": [
    {{
      "faction": "The Merchant's Guild",
      "demand": "Honored leader, we come with a reasonable request backed by economic reality. Our guild demands immediate elimination of the temple tithe‚Äîthe 15% levy that drains 500 gold pieces per moon from trade coffers into the Priesthood's hands. We have built the trade routes that feed this civilization, yet we are bled dry to fund monuments and rituals. Grant us this relief and we will increase trade revenues by 30% within three moons. Deny us, and we will be forced to consider... alternative markets beyond your borders. Our approval stands at 65, but our patience is not infinite."
    }},
    {{
      "faction": "The Priesthood of the Sun",
      "demand": "You DARE summon us alongside these... merchants? My lord, the Merchant's Guild's petition is an affront to the gods themselves! That 'temple tithe' they disparage funds the very rituals that keep our people's souls in balance and the sun rising each dawn. We demand not only that the tithe remain, but that it be DOUBLED to 30% to fund the Grand Temple construction‚Äîa project that will secure divine favor for generations. The merchants grow fat on coin while spiritual decay spreads through our people like a plague. Deny the Merchant's Guild their blasphemous request, or the priesthood will have no choice but to declare this leadership spiritually unfit. Our approval may be at 63, but the gods' approval is what truly matters. Choose wisely."
    }}
  ],
  "investigation_options": [
    "Question Lysander about whether the Merchant's Guild will truly relocate if denied, and where they would go",
    "Investigate what 'spiritually unfit' means‚Äîcan the Priesthood actually challenge your rule, and do they have support?"
  ],
  "decision_options": [
    "Side with the Merchant's Guild: Eliminate the temple tithe immediately, knowing the Priesthood will see this as a declaration of spiritual war and their approval will plummet",
    "Side with the Priesthood: Double the temple tithe to 30%, risking the Merchant's Guild withdrawing trade operations and crippling the economy"
  ]
}}
</EXAMPLE_FORMAT>



################################################################################
# FILE: old_codebase\prompts\README.md
# Size: 4833 bytes
################################################################################

# AI Prompts Directory

This directory contains all AI prompts used by the civilization game engines. Prompts are externalized from Python code to allow easy editing without modifying source code.

## Directory Structure

```
prompts/
‚îú‚îÄ‚îÄ events/          - Event generation prompts
‚îú‚îÄ‚îÄ council/         - Council meeting prompts
‚îú‚îÄ‚îÄ actions/         - Player action processing prompts
‚îú‚îÄ‚îÄ callbacks/       - Callback event prompts (consequences)
‚îú‚îÄ‚îÄ characters/      - Character vignette prompts
‚îú‚îÄ‚îÄ crises/          - Crisis event prompts
‚îú‚îÄ‚îÄ factions/        - Faction audience prompts
‚îú‚îÄ‚îÄ timeskip/        - Time skip narrative prompts
‚îú‚îÄ‚îÄ visuals/         - Image generation prompts
‚îî‚îÄ‚îÄ world/           - World generation prompts
```

## How Prompts Work

### Format Variables
All prompts use Python's `.format()` syntax for variable substitution:
- Variables are enclosed in curly braces: `{variable_name}`
- Example: `"Leader: {leader_name}"` becomes `"Leader: Caesar"`

### Variable Documentation
Each prompt file includes a header documenting required variables:
```
# VARIABLES REQUIRED:
# - civ_name: Name of the civilization (string)
# - leader_name: Name of the leader (string)
# - population: Population count (integer)
```

### Loading Prompts in Code
```python
from engines.prompt_loader import load_prompt

# Load the prompt
prompt_template = load_prompt('events/generate_event')

# Fill in variables
prompt = prompt_template.format(
    civ_name="Rome",
    leader_name="Caesar",
    population=5000
)

# Send to AI model
response = model.generate_content(prompt)
```

## Editing Prompts

### Best Practices
1. **Preserve Variable Names**: Don't change `{variable_name}` without updating the engine code
2. **Test After Editing**: Run the game to ensure prompts work correctly
3. **Document Changes**: Use git commits to track prompt modifications
4. **Maintain Formatting**: Keep markdown formatting (`**bold**`, `*italics*`) intact

### Formatting Guidelines
- Use `**bold**` for emphasis on important names, critical moments
- Use `*italics*` for atmospheric descriptions, internal thoughts
- Use line breaks (`\n`) to separate ideas and create dramatic pauses
- Use bullet lists (`- item`) for multiple points

## Prompt Categories

### Events (`events/`)
- `generate_event.txt` - Main event generation prompt
- `generate_event_stage.txt` - Event stage progression prompt

### Council (`council/`)
- `council_meeting.txt` - Regular council meeting prompt
- `first_turn_briefing.txt` - Special first turn event prompt

### Actions (`actions/`)
- `process_player_action.txt` - Player decision outcome prompt

### Callbacks (`callbacks/`)
- `broken_promise.txt` - Broken promise consequence
- `enemy_revenge.txt` - Enemy revenge event
- `ally_request.txt` - Ally requesting aid
- `debt_collection.txt` - Debt collection event

### Characters (`characters/`)
- `character_vignette.txt` - Personal character dialogue prompt

### Crises (`crises/`)
- `famine.txt` - Catastrophic famine crisis
- `food_shortage.txt` - Food shortage warning
- `severe_food_shortage.txt` - Severe food crisis
- `economic_collapse.txt` - Total economic collapse
- `economic_crisis.txt` - Economic crisis
- `economic_warning.txt` - Economic warning
- `succession_crisis.txt` - Leader succession crisis
- `compound_crisis.txt` - Multiple simultaneous crises

### Factions (`factions/`)
- `faction_audience.txt` - Faction petition event

### Timeskip (`timeskip/`)
- `timeskip_500_years.txt` - 500-year time skip narrative

### Visuals (`visuals/`)
- `leader_portrait.txt` - Leader portrait generation
- `advisor_portrait.txt` - Advisor portrait generation
- `crisis_illustration.txt` - Crisis scene illustration
- `settlement_evolution.txt` - Settlement evolution image

### World (`world/`)
- `ai_description.txt` - World opening description

## Troubleshooting

### "PROMPT FILE NOT FOUND" Error
- Verify the prompt file exists in the correct subdirectory
- Check filename matches exactly (case-sensitive on some systems)
- Ensure `.txt` extension is present

### Formatting Issues
- Check for missing closing braces `}`
- Verify variable names match what the engine provides
- Test prompt with sample data before gameplay

### AI Generation Issues
- Review prompt clarity and specificity
- Ensure JSON output format is correctly specified
- Check that all required context is included

## Contributing

When adding new prompts:
1. Create prompt file in appropriate subdirectory
2. Add variable documentation header
3. Update this README with prompt description
4. Test thoroughly with the game engine
5. Commit with descriptive message



################################################################################
# FILE: old_codebase\prompts\timeskip\timeskip_500_years.txt
# Size: 7890 bytes
################################################################################

# TIMESKIP 500 YEARS PROMPT
# Generates an epic narrative chronicling 500 years of civilization history.
# Shows dynasty progression, technological advancement, and cultural evolution based on player's decisions.
#
# VARIABLES REQUIRED:
# - civ_name: Civilization name (string)
# - civ_year: Current year (integer)
# - civ_era: Current era (string)
# - founding_leader_name: Name of the founding leader whose era is ending (string)
# - leader_age: Current leader's age (integer)
# - population: Current population (integer, with :, formatting)
# - food: Current food stockpile (integer, with :, formatting)
# - wealth: Current wealth (integer, with :, formatting)
# - tech_tier: Current technology tier (string)
# - primary_values: Top 3 cultural values comma-separated (string)
# - religion_name: Religion name (string)
# - religion_influence: Religion influence level (string)
# - primary_tendency: Primary player governing tendency (string)
# - tendency_desc: Full tendency description (string)
# - event_themes: Newline-separated list of recent event titles with ‚Ä¢ bullets (string)
#
# OUTPUT: JSON with narrative (3-4 sentences) and updates (absolute values, NOT deltas)

You are the master chronicler recording 500 years of history for a legendary civilization. Write this as an EPIC SAGA - a sweeping narrative of dynasties, triumphs, and the march of ages. This is not a report; this is LEGEND.

**FORMATTING REQUIREMENT:** Use markdown to create epic historical atmosphere:
- Use **bold** for dynasty names, pivotal leaders, and epoch-defining moments
- Use *italics* for the passage of time, legends, and cultural evolution
- Use line breaks (\n) to separate distinct eras or generations

**NARRATIVE PURPOSE:** Make the player feel the vast sweep of time and the weight of their civilization's journey. They shaped the early years through their {primary_tendency} decisions, and now they see how those choices echoed through CENTURIES. This should feel momentous and historically grounded.

**EMOTIONAL TONE:** Epic, grandiose, historically reverent. Write like a master historian chronicling the rise (or fall) of empires. Use phrases like "Through the long centuries," "Dynasty gave way to dynasty," "The people who once..."

<CURRENT_STATE>
Civilization: {civ_name} (Year {civ_year}, {civ_era} era)
Founding Leader: {founding_leader_name}, Age {leader_age} (this leader's era is ending)
Population: {population}
Resources: {food} food, {wealth} wealth
Technology: {tech_tier}
Core Values: {primary_values}
Religion: {religion_name} ({religion_influence} influence)
</CURRENT_STATE>

<CIVILIZATION_TRAJECTORY>
Player's Governing Style: {tendency_desc}
This {primary_tendency} approach has defined {civ_name}'s character.

Recent History (showing the pattern):
{event_themes}

PERMANENT DECREES IN EFFECT:
{decrees_summary}
</CIVILIZATION_TRAJECTORY>

<TASK>
Chronicle the next 500 years of {civ_name}'s history in an epic 3-4 sentence narrative.

**REACTIVITY REQUIREMENTS - Your narrative MUST:**
1. **HONOR PERMANENT DECREES ABOVE ALL**: If any permanent decrees exist, they MUST be explicitly referenced and their effects shown
   - Holy laws: Shape religious structure, social order, gender roles, property rights
   - Constitutional decrees: Define governance structure, succession, rights
   - Cultural decrees: Establish traditions, taboos, social hierarchies
   - **CRITICAL**: New leader and society MUST reflect active decrees (e.g., if female-only rule decreed, new leader MUST be female)
   - Show how decrees evolved: strengthened, caused schisms, faced resistance, or became deeply rooted
   - Decrees with "absolute" or "strong" enforcement: Fully embedded in society
   - Decrees with "moderate" or "weakening" enforcement: Mention challenges or evolution

2. **Extrapolate from player tendency**: The {primary_tendency} choices they made should shape these centuries
   - Militaristic ‚Üí Expand through conquest, warrior dynasties
   - Economic ‚Üí Become a trade empire, merchant princes
   - Religious ‚Üí Theocracy, golden age of faith
   - Scientific ‚Üí Renaissance of learning, academies
   - Diplomatic ‚Üí Federation builder, alliance networks

3. **Reference cultural continuity**: How do the values of {primary_values} evolve over 500 years?
   - "The value of Honor that defined the early {civ_name} transformed into..."
   - "The ancient tradition of [value] endured through the centuries, becoming..."

4. **Name 2-3 successor leaders with gravitas**:
   - Give them EPIC names appropriate to the era
   - Show dynasty progression: "The Founder's line gave way to the Iron Dynasty, then the Scholar-Kings"
   - Each leader's reign should reflect the civilization's trajectory

5. **Show technological/cultural evolution**:
   - Start era: {civ_era}
   - End era: Should advance 1-2 eras (e.g., bronze_age ‚Üí iron_age ‚Üí classical)
   - Mention specific technological breakthroughs or cultural golden ages

6. **End with new leader taking power**:
   - Give them an appropriate name for the new era
   - Age 25-50
   - Show them as heir to a long legacy: "And so [Name], bearing the weight of fifteen generations, ascends..."

<STYLISTIC GUIDANCE>
Write like you're chronicling actual history. Use phrases like:
- "Through the long centuries..."
- "Dynasty gave way to dynasty..."
- "The people who once [past state] now [current state]"
- "From the age of [old era] emerged the age of [new era]"
- "The legacy of [founding leader] endured through..."

‚ö†Ô∏è CRITICAL: ALL VALUES ARE ABSOLUTE/FINAL STATE - NOT DELTAS OR ADDITIONS! ‚ö†Ô∏è

RULES:
- Year: Current year PLUS 500 ‚Üí "civilization.meta.year": 500 (EXACT INCREMENT)
- New Leader: Fresh leader taking power
  - name (string): New leader's name
  - age (number): New leader's CURRENT age (25-50, NOT years to add)
  - years_ruled (number): Always 0 for new leader
  - life_expectancy (number): Based on era (see table below)
  - traits (array): ["Trait1", "Trait2"] - REPLACES old leader's traits entirely
- **Life Expectancy by Era** (¬±5 variation):
  - stone_age: 35, bronze_age: 40, iron_age: 45, classical: 50, medieval: 55, renaissance: 60, industrial: 65, modern: 75
- Population: FINAL total population after 500 years ‚Üí "civilization.population": 8500 (NOT +1500)
  - Think: Starting {population} ‚Üí Realistic growth over 500 years ‚Üí THAT FINAL NUMBER
- Tech tier: May advance 1-2 levels (stone_age‚Üíbronze_age‚Üíiron_age‚Üíclassical‚Üímedieval‚Üírenaissance)
- Era: MUST match tech tier ‚Üí "civilization.meta.era": "iron_age"
- Food/Wealth: FINAL absolute stockpile amounts (can be 1000-15000 range)
- List additions: Use .append for NEW items only: "technology.discoveries.append": "Iron Working"

‚ö†Ô∏è EXAMPLE SHOWING ABSOLUTE VALUES (NOT DELTAS):
If current population is 5000, and you want it to grow to 7500 over 500 years:
  ‚úì CORRECT: "civilization.population": 7500
  ‚úó WRONG: "civilization.population": 2500  (this is NOT a delta!)

Output JSON:
{{
  "narrative": "3-4 sentence story covering 500 years, ending with new leader",
  "updates": {{
    "civilization.meta.year": 500,
    "civilization.meta.era": "iron_age",
    "civilization.leader.name": "New Name",
    "civilization.leader.age": 38,
    "civilization.leader.years_ruled": 0,
    "civilization.leader.life_expectancy": 50,
    "civilization.leader.traits": ["Trait1", "Trait2"],
    "civilization.population": 8500,
    "civilization.resources.food": 4200,
    "civilization.resources.wealth": 6800,
    "civilization.resources.tech_tier": "iron_age",
    "technology.discoveries.append": "Discovery Name",
    "culture.traditions.append": "Tradition Name",
    "technology.infrastructure.append": "Infrastructure Name"
  }}
}}
</TASK>



################################################################################
# FILE: old_codebase\prompts\trees\generate_civics_tree.txt
# Size: 1055 bytes
################################################################################

Generate a civics tree for a civilization game set in the {era} era with a {genre_control} theme.
The output should be a JSON array of civic objects.
Each civic object must have the following keys:
- "id": A unique identifier string for the civic (e.g., "civic_code_of_laws").
- "name": The display name of the civic (e.g., "Code of Laws").
- "description": A brief description of the civic.
- "cost": An integer representing the research cost in culture points.
- "prerequisites": A list of civic "id" strings that are required to research this civic. An empty list means no prerequisites.
- "era": The era this civic belongs to (e.g., "{era}").

Example of a single civic object:
{{
    "id": "civic_early_empire",
    "name": "Early Empire",
    "description": "Establish the traditions of a hereditary ruling class and a formal military.",
    "cost": 40,
    "prerequisites": ["civic_code_of_laws"],
    "era": "Ancient"
}}

Please generate a balanced and logical civics tree with approximately 10-15 civics for the specified era.


################################################################################
# FILE: old_codebase\prompts\trees\generate_tech_tree.txt
# Size: 1081 bytes
################################################################################

Generate a technology tree for a civilization game set in the {era} era with a {genre_control} theme.
The output should be a JSON array of technology objects.
Each technology object must have the following keys:
- "id": A unique identifier string for the technology (e.g., "tech_archery").
- "name": The display name of the technology (e.g., "Archery").
- "description": A brief description of the technology.
- "cost": An integer representing the research cost in science points.
- "prerequisites": A list of technology "id" strings that are required to research this technology. An empty list means no prerequisites.
- "era": The era this technology belongs to (e.g., "{era}").

Example of a single technology object:
{{
    "id": "tech_pottery",
    "name": "Pottery",
    "description": "The art of creating vessels from clay, allowing for better storage of food and water.",
    "cost": 25,
    "prerequisites": [],
    "era": "Ancient"
}}

Please generate a balanced and logical technology tree with approximately 10-15 technologies for the specified era.


################################################################################
# FILE: old_codebase\prompts\visuals\advisor_portrait.txt
# Size: 3902 bytes
################################################################################

# ADVISOR PORTRAIT PROMPT
# Generates a masterfully composed portrait painting of an Inner Circle advisor.
# Must maintain visual consistency with leader portraits (same artistic style, lighting, technique).
#
# VARIABLES REQUIRED:
# - name: Advisor's name (string)
# - age: Advisor's age (integer)
# - age_desc: Age description (e.g., "mature", "elderly") (string)
# - age_visual: Detailed visual age cues (string)
# - role: Advisor's role/title (string)
# - era: Era name (string)
# - trait_text: Comma-separated visual trait descriptions (string)
# - role_visual: Role-specific visual elements description (string)
# - era_style: Cultural aesthetic description for the era (string)
# - culture_values: List of cultural values (for joining, first 2 used) (string)
# - traits: List of trait names for conditional logic (comma-separated string)
#
# OUTPUT: Single portrait image

Generate a masterfully composed portrait painting of {name}, a {age_desc} {role} from the {era} era.

**VISUAL NARRATIVE PURPOSE:** This portrait should capture CHARACTER and ROLE. Show the essence of a trusted advisor - someone with expertise, wisdom, and presence. This is a member of the Inner Circle, a key figure in the civilization's leadership.

**UNIFIED STYLE REQUIREMENT:** This portrait MUST match the exact same artistic style as other leader/advisor portraits in this civilization:
- Painterly, regal portrait painting style
- 3:4 portrait aspect ratio
- Dramatic but dignified lighting
- Museum-quality composition
- Era-appropriate but CONSISTENT artistic technique across all portraits

SUBJECT DETAILS:
- Name: {name}
- Role: {role}
- Age: {age} years old ({age_desc})
- Age-specific visual cues: {age_visual}
- Personality traits reflected visually: {trait_text}
- Role-specific elements: {role_visual}
- Cultural aesthetic: {era_style}
- Cultural values influencing composition: {culture_values}

VISUAL STORYTELLING:
- Role identity is PRIMARY: A {role} should LOOK like their role (warriors are martial, priests are serene, spymasters are enigmatic)
- Personality traits shape expression and bearing: {trait_text}
- If "Cunning" or "Discreet": Subtle, intelligent gaze, hint of mystery
- If "Disciplined" or "Stern": Strong bearing, serious expression, commanding presence
- If "Pious" or "Compassionate": Serene or warm expression, gentle features
- Age {age}: {age_visual}

CULTURAL AESTHETIC:
- The portrait style must reflect {era} era artistic techniques (SAME as leader portraits)
- Clothing, jewelry, and symbols must match {era_style}
- Background hints: council chamber, office, or symbolic setting appropriate to their role
- Cultural values like "{culture_values}" should influence symbolism

TECHNICAL REQUIREMENTS:
- Aspect ratio: 3:4 (portrait orientation) - EXACT SAME as leader portraits
- Composition: Bust or head-and-shoulders
- Style: Painterly, regal portrait painting - UNIFIED STYLE with other portraits
- Lighting: Dramatic but dignified (torchlight, natural light, or golden hour) - CONSISTENT with leader portrait lighting
- Detail focus: Face should be primary focus with clear, detailed features
- NO text, labels, UI elements, or modern elements
- Color palette appropriate to {era} era art styles - CONSISTENT across all portraits

**CONSISTENCY REQUIREMENT:**
This portrait must look like it was painted by the SAME artist in the SAME session as the leader's portrait. Maintain visual unity: same brush technique, same lighting approach, same color palette temperature, same level of detail.

**REACTIVITY REQUIREMENT:**
This is {name}, a {role} - make them UNIQUE and RECOGNIZABLE. Their role ({role}), traits ({traits}), and age ({age}) should create a one-of-a-kind portrait that clearly shows who they are and what they do.

Generate a single, museum-quality advisor portrait that tells a story.



################################################################################
# FILE: old_codebase\prompts\visuals\crisis_illustration.txt
# Size: 3113 bytes
################################################################################

# CRISIS ILLUSTRATION PROMPT
# Generates a dramatic illustration for crisis events (famine, economic collapse, etc.).
# Uses a dictionary-based selection to match the crisis type.
#
# NOTE: This prompt is loaded as a DICTIONARY mapping crisis types to prompts.
# The engine will select the appropriate prompt based on crisis_type.
#
# VARIABLES REQUIRED:
# - era: Era name (string)
# - terrain: Terrain type (string)
# - crisis_type: Type of crisis (determines which prompt to use) (string)
#
# OUTPUT: Single landscape image (16:9 aspect ratio)

# This file contains multiple crisis-specific prompts.
# The crisis_engine will select the correct one based on crisis_type.

## FAMINE
A dramatic scene depicting famine in a {era} era settlement on {terrain} terrain.

SCENE:
- Barren fields with withered crops
- Emaciated people gathering around empty granaries
- Desperate atmosphere, dust and drought
- Visible suffering but maintaining dignity
- {era} era architecture showing neglect
- Muted, desaturated colors conveying despair

Style: Dramatic, painterly, wide-angle view of the settlement in crisis. No text or UI.

Generate in 16:9 landscape aspect ratio for banner display.

---

## FOOD_SHORTAGE
A tense scene showing food shortage in a {era} era settlement.

SCENE:
- Worried crowds gathering at market/granary
- Half-empty storage areas
- People rationing food, long lines
- Anxious but not desperate atmosphere
- {era} era architecture, period-appropriate
- Warm but slightly desaturated tones

Style: Dramatic scene painting, showing tension and concern. No text or UI.

Generate in 16:9 landscape aspect ratio for banner display.

---

## ECONOMIC_COLLAPSE
A scene of economic collapse in a {era} era civilization.

SCENE:
- Crumbling infrastructure, damaged buildings
- Abandoned marketplaces, broken carts
- People in poverty, tattered clothing
- Debris and decay visible
- {era} era architecture in disrepair
- Dark, gloomy atmosphere

Style: Dramatic painting showing urban decay and economic ruin. No text or UI.

Generate in 16:9 landscape aspect ratio for banner display.

---

## ECONOMIC_CRISIS
A scene depicting economic crisis in a {era} era settlement.

SCENE:
- Struggling merchants, closed shops
- Worried traders and empty market stalls
- Signs of economic strain, fewer goods
- People concerned but still functioning
- {era} era marketplace architecture
- Slightly muted, tense atmosphere

Style: Dramatic scene showing economic tension. No text or UI.

Generate in 16:9 landscape aspect ratio for banner display.

---

## SUCCESSION_CRISIS
A tense scene of succession crisis in a {era} era civilization.

SCENE:
- Palace or throne room in tension
- Multiple factions, divided loyalties
- Symbols of competing claims (banners, supporters)
- Atmosphere of political intrigue
- {era} era palace architecture
- Rich but tense colors, dramatic lighting

Style: Political drama painting, showing power struggle. No text or UI.

Generate in 16:9 landscape aspect ratio for banner display.



################################################################################
# FILE: old_codebase\prompts\visuals\leader_portrait.txt
# Size: 2988 bytes
################################################################################

# LEADER PORTRAIT PROMPT
# Generates a masterfully composed portrait painting of a civilization leader.
# Used for leader visualization in the game interface.
#
# VARIABLES REQUIRED:
# - name: Leader's name (string)
# - age: Leader's age (integer)
# - age_desc: Age description (e.g., "young", "elderly") (string)
# - age_visual: Detailed visual age cues (string)
# - role: Leader's role/title (string)
# - era: Era name (string)
# - trait_text: Comma-separated traits (string)
# - era_style: Cultural aesthetic description for the era (string)
# - culture_values: List of cultural values (for joining, first 2 used) (string)
# - traits: List of trait names for conditional logic (comma-separated string)
#
# OUTPUT: Single portrait image

Generate a masterfully composed portrait painting of {name}, a {age_desc} {role} from the {era} era.

**VISUAL NARRATIVE PURPOSE:** This portrait should capture not just appearance, but CHARACTER. Show the weight of leadership, the mark of their traits, and the influence of their civilization's culture.

SUBJECT DETAILS:
- Name: {name}
- Age: {age} years old ({age_desc})
- Age-specific visual cues: {age_visual}
- Personality traits reflected visually: {trait_text}
- Cultural aesthetic: {era_style}
- Cultural values influencing composition: {culture_values}

VISUAL STORYTELLING:
- If traits include "Warrior" or "Brave": Battle scars, strong jawline, hardened gaze, military bearing
- If traits include "Wise" or "Scholar": Thoughtful expression, scrolls or books visible, contemplative eyes
- If traits include "Pious" or "Mystic": Serene or otherworldly expression, religious symbols, ethereal quality
- If traits include "Ruthless": Cold, calculating eyes, stern expression, imposing presence
- If traits include "Ancient" (age 70+): Deeply weathered face, white hair, dignified fragility, wisdom etched in wrinkles

CULTURAL AESTHETIC:
- The portrait style should reflect {era} era artistic techniques
- Clothing, jewelry, and symbols must match {era_style}
- Background hints: throne room, council chamber, or symbolic setting appropriate to culture
- Cultural values like "{culture_values}" should influence symbolism (e.g., martial culture = weapons visible, scholarly culture = books)

TECHNICAL REQUIREMENTS:
- Aspect ratio: 3:4 (portrait orientation)
- Composition: Bust or head-and-shoulders
- Style: Painterly, regal portrait painting suitable for historical strategy game
- Lighting: Dramatic but dignified (torchlight, natural light, or golden hour)
- Detail focus: Face should be primary focus with clear, detailed features
- NO text, labels, UI elements, or modern elements
- Color palette appropriate to {era} era art styles

**REACTIVITY REQUIREMENT:**
This is {name} - make them UNIQUE. Their age ({age}), traits ({traits}), and culture ({culture_values}) should create a one-of-a-kind portrait.

Generate a single, museum-quality leader portrait that tells a story.



################################################################################
# FILE: old_codebase\prompts\visuals\settlement_evolution.txt
# Size: 4469 bytes
################################################################################

# SETTLEMENT EVOLUTION PROMPT
# Generates a sweeping, detailed view of a civilization's settlement showing its growth through the ages.
# This is a visual chronicle of achievement, showing how the settlement has evolved from humble beginnings.
#
# VARIABLES REQUIRED:
# - civ_name: Civilization name (string)
# - year_marker: Year for tracking (integer)
# - size_desc: Settlement size description (string, e.g., "thriving town")
# - era: Current era (string)
# - tech_tier: Technology level (string)
# - population: Population count (integer, with :, formatting)
# - culture_values: List of top 3 cultural values (comma-separated string)
# - terrain: Terrain type (string)
# - climate: Climate type (string)
# - resources: List of natural resources (comma-separated string)
# - religion_name: Primary religion name (string)
# - holy_sites: List of holy sites (comma-separated string)
# - social_structure: Social structure type (string)
# - cultural_aesthetic: Cultural aesthetic description with examples (string, optional)
# - infrastructure_visual: Recent infrastructure to feature prominently (string, optional)
# - recent_infrastructure: List of last 2 infrastructure items (comma-separated string)
#
# OUTPUT: Single landscape image (isometric/elevated view)

Generate a sweeping, detailed view of {civ_name}, a legendary {size_desc} that has evolved through the ages.

**VISUAL NARRATIVE PURPOSE:** This image should tell the story of civilization's PROGRESS. Show how {civ_name} has grown from humble beginnings to its current state in year {year_marker}. This is a visual chronicle of achievement.

SETTLEMENT IDENTITY:
- Civilization: {civ_name}
- Year: {year_marker} (show the marks of history and time)
- Era: {era}
- Technology Level: {tech_tier} (CRITICAL: architecture style must authentically match this era)
- Population: {population} souls (settlement size and density MUST reflect this)
- Primary Cultural Values: {culture_values}

ENVIRONMENTAL CONTEXT:
- Terrain Type: {terrain} (show this terrain clearly - hills, rivers, forests, plains, mountains, coast)
- Climate: {climate} (weather, vegetation, and atmosphere must match)
- Natural Resources: {resources} (show these visually - mines, quarries, farms, forests)

CULTURAL & RELIGIOUS LANDSCAPE:
- Primary Religion: {religion_name} (religious architecture should be visible)
- Holy Sites: {holy_sites} (incorporate these into the cityscape)
- Social Structure: {social_structure} (show class divisions in architecture - palaces vs. common dwellings){cultural_aesthetic}{infrastructure_visual}

VISUAL STORYTELLING REQUIREMENTS:
1. **Era-Authentic Architecture**: Buildings MUST match {tech_tier} technology level
   - stone_age: Primitive huts, campfires, basic shelters
   - bronze_age: Mud brick buildings, early stone structures
   - iron_age: Solid stone buildings, defensive walls, organized layout
   - classical: Grand architecture, columns, organized city planning
   - medieval: Castles, cathedrals, dense urban core
   - renaissance: Ornate buildings, public squares, artistic flourishes

2. **Population Density**: {population} people means this should be a {size_desc}

3. **Terrain Integration**: Show how the settlement works WITH the {terrain} terrain

4. **Climate Atmosphere**: {climate} climate affects everything - vegetation, sky, weather

5. **Cultural Identity**: The civilization's values should be VISIBLE in the architecture and layout

6. **Recent Progress**: If infrastructure like {recent_infrastructure} was recently built, show it prominently

TECHNICAL REQUIREMENTS:
- Perspective: Isometric or elevated top-down view showing the full settlement
- Art Style: Painterly, atmospheric, strategy game aesthetic (Civilization/Age of Empires inspired)
- Lighting: Appropriate to climate and time of day (suggest golden hour or dramatic sky)
- Detail Level: Rich detail in foreground, atmospheric depth in background
- NO text, labels, UI elements, or modern anachronisms
- Cohesive color palette reflecting era and climate

**REACTIVITY REQUIREMENT:**
This is year {year_marker} of {civ_name}'s history. Show the unique character of THIS civilization - not a generic settlement. Their {era} era technology, {terrain} terrain, and cultural focus should create a distinctive visual identity.

Generate a single, breathtaking settlement vista that showcases civilization's journey through time.



################################################################################
# FILE: old_codebase\prompts\world\ai_description.txt
# Size: 940 bytes
################################################################################

# WORLD AI DESCRIPTION PROMPT
# Generates a brief, atmospheric opening description for a newly generated world.
# Used once at game start to set the tone and introduce the player to their civilization.
#
# VARIABLES REQUIRED:
# - civ_name: Civilization name (string)
# - era: Era name (string)
# - terrain: Terrain type (string)
# - climate: Climate type (string)
# - leader_name: Leader name (string)
# - cultural_values: Comma-separated list of top 3 cultural values (string)
# - religion_name: Religion name (string)
#
# OUTPUT: Plain text (2-3 sentences)

Generate a brief, evocative opening description (2-3 sentences) for a civilization game with these characteristics:

Civilization: {civ_name}
Era: {era}
Terrain: {terrain}
Climate: {climate}
Leader: {leader_name}
Cultural Values: {cultural_values}
Religion: {religion_name}

Make it atmospheric and immersive, setting the stage for the player's journey.



################################################################################
# FILE: old_codebase\pyproject.toml
# Size: 458 bytes
################################################################################

[project]
name = "civilization-game"
version = "0.1.0"
description = "An AI-driven civilization simulation game."
authors = [
    {name = "Your Name"}
]
readme = "README.md"
requires-python = ">=3.12"
package-mode = false
dependencies = [
    "flask>=3.0.0",
    "google-generativeai>=0.5.0",
    "python-dotenv>=1.0.0",
    "pillow>=10.0.0"
]


[build-system]
requires = ["poetry-core>=1.0.0"]
build-backend = "poetry.core.masonry.api"



################################################################################
# FILE: old_codebase\README.md
# Size: 65 bytes
################################################################################

# Civilization Game

An AI-driven civilization simulation game.


################################################################################
# FILE: old_codebase\run_all_phase3_tests.bat
# Size: 1495 bytes
################################################################################

@echo off
echo ============================================================
echo PHASE 3 COMPREHENSIVE TEST SUITE
echo ============================================================
echo.

echo [1/3] Running BonusEngine Unit Tests...
echo ============================================================
python test_bonus_engine.py
if %errorlevel% neq 0 (
    echo FAILED: BonusEngine tests failed!
    exit /b 1
)
echo.

echo [2/3] Running World Turns Integration Tests...
echo ============================================================
python test_world_turns_integration.py
if %errorlevel% neq 0 (
    echo FAILED: Integration tests failed!
    exit /b 1
)
echo.

echo [3/3] Running Full System Regression Tests...
echo ============================================================
python test_systems.py
if %errorlevel% neq 0 (
    echo FAILED: Regression tests failed!
    exit /b 1
)
echo.

echo ============================================================
echo ALL PHASE 3 TESTS PASSED SUCCESSFULLY!
echo ============================================================
echo.
echo Phase 3: Bonus Aggregation System is COMPLETE and VERIFIED
echo.
echo Next steps:
echo   1. Review PHASE_3_COMPLETE.md for summary
echo   2. Check docs/bonus_system.md for documentation
echo   3. See examples/add_building_bonus.md for usage
echo.
echo Ready for Phase 4: Building and Technology Systems!
echo ============================================================



################################################################################
# FILE: old_codebase\run_game.bat
# Size: 412 bytes
################################################################################

@echo off
echo ========================================
echo    CIVILIZATION GAME LAUNCHER
echo ========================================
echo.
echo Starting the civilization game server...
echo.
echo The game will open in your browser at:
echo http://127.0.0.1:5000
echo.
echo Press Ctrl+C to stop the server when done.
echo ========================================
echo.

python main.py

pause



################################################################################
# FILE: old_codebase\static\style.css
# Size: 58800 bytes
################################################################################

/* ========================================
   CIVILIZATION GAME - ENHANCED VISUAL STYLES
   ======================================== */

/* ========== CSS VARIABLES ========== */
:root {
    /* Background Gradients */
    --bg-primary: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
    --bg-secondary: linear-gradient(135deg, #1e1e2e 0%, #2a2a3e 100%);
    --bg-tertiary: linear-gradient(135deg, #2a2a3e 0%, #3a3a4e 100%);
    --bg-card: rgba(42, 42, 62, 0.7);
    --bg-card-hover: rgba(52, 52, 72, 0.9);

    /* Border Colors */
    --border-color: rgba(100, 100, 150, 0.3);
    --border-color-bright: rgba(150, 150, 200, 0.5);

    /* Text Colors */
    --text-primary: #e8e8f0;
    --text-secondary: #b8b8d0;
    --text-muted: #8888a8;
    --text-header: #aaddff;
    --text-accent: #88ddff;

    /* Accent Colors */
    --accent-primary: #3498db;
    --accent-success: #2ecc71;
    --accent-warning: #f39c12;
    --accent-danger: #e74c3c;
    --accent-purple: #9b59b6;
    --accent-gold: #f1c40f;

    /* Glow Effects */
    --glow-primary: 0 0 20px rgba(52, 152, 219, 0.3);
    --glow-success: 0 0 20px rgba(46, 204, 113, 0.3);
    --glow-gold: 0 0 20px rgba(241, 196, 15, 0.3);

    /* Shadows */
    --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);
    --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.4);
    --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.5);
}

/* ========== MULTI-STAGE EVENT STYLES ========== */
.stage-indicator {
    display: inline-block;
    padding: 6px 12px;
    background: linear-gradient(135deg, var(--accent-primary), #2980b9);
    border-radius: 6px;
    font-size: 0.85rem;
    font-weight: bold;
    margin-bottom: 12px;
    box-shadow: var(--glow-primary);
}

.conversation-history {
    margin-top: 20px;
    padding-top: 15px;
    border-top: 2px solid var(--border-color);
}

.conversation-exchange {
    margin-bottom: 15px;
    animation: slideInLeft 0.3s ease-out;
}

.player-query {
    color: var(--accent-gold);
    margin-bottom: 8px;
    padding-left: 10px;
    border-left: 3px solid var(--accent-gold);
}

.ai-response {
    color: var(--text-secondary);
    padding: 12px;
    background: rgba(52, 152, 219, 0.1);
    border-radius: 8px;
    margin-left: 15px;
    line-height: 1.6;
}

/* 2x2 Grid Layout */
#action-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr 1fr;
    gap: 12px;
    margin: 20px 0;
}

.action-btn {
    min-height: 80px;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 15px 15px 15px 40px;
    border-radius: 10px;
    font-size: 0.95rem;
    cursor: pointer;
    transition: all 0.3s ease;
    border: 2px solid;
    position: relative;
}

.btn-icon {
    position: absolute;
    top: 50%;
    left: 12px;
    transform: translateY(-50%);
    font-size: 1.3rem;
    opacity: 0.7;
}

/* Investigation buttons - subtle blue */
.action-investigate {
    background: linear-gradient(135deg, rgba(52, 152, 219, 0.15), rgba(41, 128, 185, 0.15));
    border-color: rgba(52, 152, 219, 0.4);
    color: #8ec5e8;
}

.action-investigate:hover {
    background: linear-gradient(135deg, rgba(52, 152, 219, 0.25), rgba(41, 128, 185, 0.25));
    border-color: rgba(52, 152, 219, 0.6);
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
}

.action-investigate .btn-icon {
    color: #5dade2;
}

/* Decision buttons - subtle amber/gold */
.action-decision {
    background: linear-gradient(135deg, rgba(243, 156, 18, 0.15), rgba(230, 126, 34, 0.15));
    border-color: rgba(243, 156, 18, 0.4);
    color: #f5c57a;
}

.action-decision:hover {
    background: linear-gradient(135deg, rgba(243, 156, 18, 0.25), rgba(230, 126, 34, 0.25));
    border-color: rgba(243, 156, 18, 0.6);
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(243, 156, 18, 0.3);
}

.action-decision .btn-icon {
    color: #f39c12;
}

@keyframes slideInLeft {
    from {
        opacity: 0;
        transform: translateX(-20px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

.resolution-notice {
    margin: 15px 0;
    padding: 12px;
    background: linear-gradient(135deg, rgba(243, 156, 18, 0.2), rgba(230, 126, 34, 0.2));
    border: 2px solid var(--accent-warning);
    border-radius: 8px;
    text-align: center;
    color: var(--accent-gold);
    animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

/* Two-button input system */
#player-input-area {
    display: flex;
    gap: 10px;
    align-items: stretch;
}

#player-input {
    flex: 1;
}

.submit-investigate {
    background: linear-gradient(135deg, var(--accent-primary), #2980b9);
    border: 2px solid var(--accent-primary);
    color: white;
    padding: 12px 20px;
    font-size: 0.95rem;
    font-weight: bold;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.submit-investigate:hover {
    background: linear-gradient(135deg, #2980b9, var(--accent-primary));
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
}

.submit-decide {
    background: linear-gradient(135deg, var(--accent-warning), #d68910);
    border: 2px solid var(--accent-warning);
    color: white;
    padding: 12px 20px;
    font-size: 0.95rem;
    font-weight: bold;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.submit-decide:hover {
    background: linear-gradient(135deg, #d68910, var(--accent-warning));
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(243, 156, 18, 0.4);
}

/* Progress indicator */
.event-header-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.event-progress {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}

.progress-dots {
    display: flex;
    gap: 8px;
}

.progress-dots .dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: rgba(100, 100, 150, 0.3);
    border: 2px solid rgba(150, 150, 200, 0.4);
    transition: all 0.3s ease;
}

.progress-dots .dot.active {
    background: linear-gradient(135deg, var(--accent-primary), #2980b9);
    border-color: var(--accent-primary);
    box-shadow: 0 0 10px rgba(52, 152, 219, 0.6);
    animation: dotPulse 1s ease-in-out;
}

@keyframes dotPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.3); }
}

.progress-label {
    font-size: 0.75rem;
    color: var(--text-muted);
}

/* ========== GLOBAL STYLES ========== */
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    background: var(--bg-primary);
    color: var(--text-primary);
    margin: 0;
    padding: 20px;
    min-height: 100vh;
    line-height: 1.6;
    position: relative;
}

h2, h3, h4 {
    color: var(--text-header);
    margin-bottom: 15px;
}

/* ========== MAIN CONTAINER ========== */
#game-container {
    display: grid;
    grid-template-columns: 350px 1fr auto;
    gap: 20px;
    max-width: 1800px;
    margin: 0 auto;
    animation: fadeIn 0.5s ease-in;
    justify-content: center;
    padding-top: 60px; /* Space for exit button */
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

/* ========== EXIT TO MAIN MENU BUTTON ========== */
.exit-menu-btn {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1000;
    padding: 12px 24px;
    background: linear-gradient(135deg, var(--accent-danger), #c0392b);
    color: white;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-radius: 8px;
    font-size: 1rem;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: var(--shadow-lg);
}

.exit-menu-btn:hover {
    background: linear-gradient(135deg, #c0392b, var(--accent-danger));
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
}

/* ========== LEFT PANEL ========== */
#left-panel {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 20px;
    box-shadow: var(--shadow-lg);
    backdrop-filter: blur(10px);
}

.panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 2px solid var(--border-color-bright);
}

.panel-header h2 {
    margin: 0;
    font-size: 1.5rem;
    background: linear-gradient(135deg, #88ddff, #aaddff);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.era-badge {
    background: linear-gradient(135deg, var(--accent-purple), var(--accent-primary));
    color: white;
    padding: 6px 14px;
    border-radius: 20px;
    font-size: 0.85rem;
    font-weight: bold;
    box-shadow: var(--glow-primary);
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.8; }
}

/* Settlement Image */
#settlement-image-container {
    position: relative;
    margin-bottom: 20px;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: var(--shadow-md);
}

#settlement-image {
    width: 100%;
    display: block;
    border-radius: 8px;
    min-height: 200px;
    background: linear-gradient(135deg, #1a1a2e, #16213e);
}

.image-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
    padding: 15px;
    color: white;
    font-weight: bold;
    font-size: 1.2rem;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
}

/* Leader Portrait - In Profile Section */
.leader-portrait-overlay {
    width: 100%;
    margin: 15px 0;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.6), 0 0 20px rgba(52, 152, 219, 0.4);
    border: 3px solid rgba(52, 152, 219, 0.6);
    transition: all 0.3s ease;
}

.leader-portrait-overlay:hover {
    transform: scale(1.02);
    box-shadow: 0 6px 24px rgba(0, 0, 0, 0.8), 0 0 30px rgba(52, 152, 219, 0.6);
    border-color: var(--accent-primary);
}

.leader-portrait-overlay img {
    width: 100%;
    height: auto;
    display: block;
    object-fit: cover;
    aspect-ratio: 3/4;
}

/* Quick Stats Bar (Horizontal at top of middle panel) */
#quick-stats-bar {
    display: flex;
    gap: 15px;
    padding: 15px 20px;
    background: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 10px;
    margin-bottom: 20px;
    box-shadow: var(--shadow-md);
    justify-content: space-around;
}

.stat-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px 12px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 8px;
    transition: all 0.3s ease;
    flex: 1;
    min-width: 0;
}

.stat-item:hover {
    background: rgba(255, 255, 255, 0.08);
    transform: translateY(-2px);
    box-shadow: var(--shadow-sm);
}

.stat-item .stat-icon {
    font-size: 1.8rem;
    filter: drop-shadow(0 0 6px rgba(255, 255, 255, 0.3));
    flex-shrink: 0;
}

.stat-item .stat-content {
    flex: 1;
    min-width: 0;
}

.stat-item .stat-label {
    font-size: 0.75rem;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    white-space: nowrap;
}

.stat-item .stat-value {
    font-size: 1.3rem;
    font-weight: bold;
    color: var(--text-accent);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

@keyframes numberChange {
    0% { transform: scale(1.2); color: var(--accent-gold); }
    100% { transform: scale(1); }
}

/* Leader Profile */
#leader-profile {
    background: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 15px;
}

#leader-profile h3 {
    margin-top: 0;
    font-size: 1.1rem;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 10px;
}

.leader-info {
    margin-top: 15px;
}

.leader-name {
    font-size: 1.3rem;
    font-weight: bold;
    color: var(--accent-gold);
    text-shadow: var(--glow-gold);
}

.leader-role {
    font-size: 0.9rem;
    color: var(--text-muted);
    font-style: italic;
    margin-bottom: 10px;
}

.leader-stats {
    display: flex;
    justify-content: space-between;
    margin: 15px 0;
    font-size: 0.9rem;
}

.leader-progress {
    margin: 15px 0;
}

.progress-label {
    font-size: 0.85rem;
    color: var(--text-muted);
    margin-bottom: 5px;
}

.progress-bar {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    height: 8px;
    overflow: hidden;
    margin: 8px 0;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--accent-success), var(--accent-primary));
    transition: width 0.5s ease;
    box-shadow: var(--glow-primary);
}

.progress-text {
    font-size: 0.8rem;
    color: var(--text-secondary);
    text-align: center;
}

.leader-traits {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 10px;
}

.trait-badge {
    background: linear-gradient(135deg, rgba(155, 89, 182, 0.3), rgba(52, 152, 219, 0.3));
    border: 1px solid var(--accent-purple);
    color: var(--text-primary);
    padding: 4px 12px;
    border-radius: 15px;
    font-size: 0.8rem;
    font-weight: 600;
}

/* ========== MIDDLE PANEL (EVENT LOG - CENTER) ========== */
#middle-panel {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 25px;
    box-shadow: var(--shadow-lg);
    backdrop-filter: blur(10px);
    display: flex;
    flex-direction: column;
    min-width: 600px;
}

.event-log-title {
    margin-top: 0;
    margin-bottom: 20px;
    font-size: 2rem;
    text-align: center;
    background: linear-gradient(135deg, #88ddff, #aaddff);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-transform: uppercase;
    letter-spacing: 2px;
    font-weight: bold;
}

/* Tab Navigation */
.tab-navigation {
    display: flex;
    gap: 8px;
    margin-bottom: 20px;
    border-bottom: 2px solid var(--border-color);
    overflow-x: auto;
}

.tab-btn {
    background: transparent;
    border: none;
    color: var(--text-secondary);
    padding: 12px 20px;
    font-size: 0.95rem;
    cursor: pointer;
    border-bottom: 3px solid transparent;
    transition: all 0.3s ease;
    white-space: nowrap;
}

.tab-btn:hover {
    color: var(--text-accent);
    background: rgba(255, 255, 255, 0.05);
}

.tab-btn.active {
    color: var(--text-accent);
    border-bottom-color: var(--accent-primary);
    background: rgba(52, 152, 219, 0.1);
    font-weight: bold;
}

/* Tab Content */
.tab-content-container {
    flex: 1;
    min-height: 0;
    overflow-y: auto;
    padding-right: 5px;
}

.tab-content {
    display: none;
    animation: fadeIn 0.3s ease;
}

.tab-content.active {
    display: block;
}

/* Overview Grid */
.overview-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 15px;
}

.info-card {
    background: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 15px;
    transition: all 0.3s ease;
}

.info-card:hover {
    border-color: var(--border-color-bright);
    box-shadow: var(--shadow-md);
    transform: translateY(-2px);
}

.info-card h4 {
    margin-top: 0;
    margin-bottom: 15px;
    font-size: 1rem;
    color: var(--text-accent);
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 8px;
}

.info-item {
    display: flex;
    justify-content: space-between;
    margin: 10px 0;
    padding: 8px 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.info-item:last-child {
    border-bottom: none;
}

.info-label {
    color: var(--text-muted);
    font-size: 0.9rem;
}

.info-value {
    color: var(--text-primary);
    font-weight: bold;
    text-align: right;
}

/* Culture Tab */
.culture-section, .religion-section, .tech-section {
    margin-bottom: 25px;
    padding: 15px;
    background: var(--bg-card);
    border-radius: 8px;
    border: 1px solid var(--border-color);
}

.culture-section h4, .religion-section h4, .tech-section h4 {
    margin-top: 0;
    margin-bottom: 12px;
    color: var(--text-accent);
}

.tag-list {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}

.tag {
    padding: 6px 14px;
    border-radius: 20px;
    font-size: 0.85rem;
    font-weight: 500;
    transition: all 0.3s ease;
    cursor: default;
}

.tag-value {
    background: linear-gradient(135deg, rgba(46, 204, 113, 0.2), rgba(52, 152, 219, 0.2));
    border: 1px solid var(--accent-success);
    color: var(--accent-success);
}

.tag-tradition {
    background: linear-gradient(135deg, rgba(241, 196, 15, 0.2), rgba(243, 156, 18, 0.2));
    border: 1px solid var(--accent-gold);
    color: var(--accent-gold);
}

.tag-taboo {
    background: linear-gradient(135deg, rgba(231, 76, 60, 0.2), rgba(192, 57, 43, 0.2));
    border: 1px solid var(--accent-danger);
    color: var(--accent-danger);
}

.tag-practice {
    background: linear-gradient(135deg, rgba(155, 89, 182, 0.2), rgba(142, 68, 173, 0.2));
    border: 1px solid var(--accent-purple);
    color: var(--accent-purple);
}

.tag:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

.change-list {
    list-style: none;
    padding: 0;
}

.change-list li {
    padding: 8px 12px;
    margin: 8px 0;
    background: rgba(255, 255, 255, 0.05);
    border-left: 3px solid var(--accent-primary);
    border-radius: 4px;
}

.empty-state {
    color: var(--text-muted);
    font-style: italic;
    padding: 10px;
    text-align: center;
}

/* Religion Tab */
.religion-header {
    text-align: center;
    margin-bottom: 20px;
    padding: 15px;
    background: var(--bg-card);
    border-radius: 8px;
    border: 1px solid var(--border-color);
}

.religion-header h3 {
    margin: 0 0 8px 0;
    font-size: 1.5rem;
    color: var(--accent-gold);
    text-shadow: var(--glow-gold);
}

.religion-type {
    font-size: 0.9rem;
    color: var(--text-muted);
    font-style: italic;
}

.deity-name {
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--accent-gold);
    text-align: center;
    padding: 10px;
    background: rgba(241, 196, 15, 0.1);
    border-radius: 8px;
}

.tenet-list {
    list-style: none;
    padding: 0;
}

.tenet-list li {
    padding: 10px 15px;
    margin: 8px 0;
    background: rgba(255, 255, 255, 0.05);
    border-left: 3px solid var(--accent-purple);
    border-radius: 4px;
    position: relative;
}

.tenet-list li:before {
    content: "‚ú¶";
    position: absolute;
    left: -12px;
    color: var(--accent-purple);
}

.holy-sites-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.holy-site {
    padding: 10px 15px;
    background: linear-gradient(135deg, rgba(52, 152, 219, 0.1), rgba(155, 89, 182, 0.1));
    border: 1px solid var(--accent-primary);
    border-radius: 8px;
    font-weight: 500;
}

.influence-indicator {
    text-align: center;
}

.influence-badge {
    display: inline-block;
    padding: 10px 20px;
    border-radius: 20px;
    font-weight: bold;
    text-transform: uppercase;
    font-size: 0.9rem;
}

.influence-dominant {
    background: linear-gradient(135deg, var(--accent-success), var(--accent-primary));
    color: white;
    box-shadow: var(--glow-success);
}

.influence-strong {
    background: linear-gradient(135deg, var(--accent-primary), var(--accent-purple));
    color: white;
}

.influence-moderate {
    background: linear-gradient(135deg, var(--accent-warning), var(--accent-gold));
    color: white;
}

.influence-weak {
    background: rgba(150, 150, 150, 0.3);
    border: 1px solid var(--text-muted);
    color: var(--text-muted);
}

/* Technology Tab */
.tech-header {
    text-align: center;
    margin-bottom: 20px;
    padding: 15px;
    background: var(--bg-card);
    border-radius: 8px;
    border: 1px solid var(--border-color);
}

.tech-header h4 {
    margin: 0;
}

#tech-tier {
    color: var(--accent-primary);
    text-transform: capitalize;
}

.tech-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 10px;
}

.tech-item {
    padding: 10px 12px;
    border-radius: 6px;
    font-size: 0.9rem;
    transition: all 0.3s ease;
    cursor: default;
}

.tech-discovered {
    background: linear-gradient(135deg, rgba(46, 204, 113, 0.2), rgba(39, 174, 96, 0.2));
    border: 1px solid var(--accent-success);
    color: var(--accent-success);
}

.tech-progress {
    background: linear-gradient(135deg, rgba(241, 196, 15, 0.2), rgba(243, 156, 18, 0.2));
    border: 1px solid var(--accent-warning);
    color: var(--accent-warning);
    animation: pulse 2s infinite;
}

.tech-infrastructure {
    background: linear-gradient(135deg, rgba(52, 152, 219, 0.2), rgba(41, 128, 185, 0.2));
    border: 1px solid var(--accent-primary);
    color: var(--accent-primary);
}

.tech-item:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
}

/* History Tab */
.timeline {
    position: relative;
    padding-left: 30px;
}

.timeline:before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 2px;
    background: linear-gradient(to bottom, var(--accent-primary), var(--accent-purple));
}

.timeline-event {
    position: relative;
    margin-bottom: 25px;
    padding: 15px;
    background: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    transition: all 0.3s ease;
}

.timeline-event:hover {
    border-color: var(--border-color-bright);
    box-shadow: var(--shadow-md);
    transform: translateX(5px);
}

.timeline-event:before {
    content: '';
    position: absolute;
    left: -38px;
    top: 20px;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: var(--accent-primary);
    border: 3px solid var(--bg-secondary);
    box-shadow: var(--glow-primary);
}

.timeline-year {
    font-size: 0.85rem;
    color: var(--accent-gold);
    font-weight: bold;
    margin-bottom: 8px;
}

.timeline-content strong {
    color: var(--text-accent);
    display: block;
    margin-bottom: 5px;
}

.timeline-content p {
    color: var(--text-secondary);
    margin: 0;
    font-size: 0.9rem;
}

/* ========== RIGHT PANEL (COLLAPSIBLE DASHBOARD) ========== */
#right-panel {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 20px;
    box-shadow: var(--shadow-lg);
    backdrop-filter: blur(10px);
    display: flex;
    flex-direction: column;
    position: relative;
    width: 400px;
    transition: all 0.4s ease;
}

#right-panel.collapsed {
    width: 80px;
    padding: 15px 10px;
}

/* Dashboard Toggle Button */
.dashboard-toggle {
    position: absolute;
    left: -15px;
    top: 50%;
    transform: translateY(-50%);
    width: 30px;
    height: 60px;
    background: linear-gradient(135deg, var(--accent-primary), var(--accent-purple));
    border: 1px solid var(--border-color-bright);
    border-radius: 8px 0 0 8px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 1.2rem;
    transition: all 0.3s ease;
    z-index: 10;
}

.dashboard-toggle:hover {
    background: linear-gradient(135deg, var(--accent-purple), var(--accent-primary));
    box-shadow: var(--glow-primary);
    left: -18px;
}

.toggle-icon {
    transition: transform 0.3s ease;
}

/* Abbreviated Dashboard (Collapsed State) */
.dashboard-abbreviated {
    display: none;
    animation: fadeIn 0.3s ease;
}

#right-panel.collapsed .dashboard-abbreviated {
    display: block;
}

#right-panel.collapsed .dashboard-full {
    display: none;
}

.abbreviated-header {
    text-align: center;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 2px solid var(--border-color);
}

.abbreviated-header h3 {
    font-size: 0.85rem;
    margin: 0;
    color: var(--text-accent);
    font-weight: bold;
    letter-spacing: 2px;
}

.abbreviated-tabs {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.tab-icon-btn {
    background: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.tab-icon-btn:hover {
    background: var(--bg-card-hover);
    border-color: var(--accent-primary);
    transform: scale(1.1);
    box-shadow: var(--glow-primary);
}

.tab-icon-btn:active {
    transform: scale(1.05);
}

.tab-emoji {
    font-size: 1.8rem;
    filter: drop-shadow(0 0 4px rgba(255, 255, 255, 0.3));
}

/* Full Dashboard (Expanded State) */
.dashboard-full {
    display: flex;
    flex-direction: column;
    flex: 1;
    min-height: 0;
    animation: fadeIn 0.3s ease;
}

#right-panel.collapsed .dashboard-full {
    display: none;
}

#event-log {
    flex: 1;
    min-height: 500px;
    max-height: 65vh;
    overflow-y: auto;
    padding: 20px;
    margin-bottom: 20px;
    background: rgba(15, 12, 41, 0.5);
    border: 1px solid var(--border-color-bright);
    border-radius: 10px;
    box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.5);
}

/* Scrollbar Styling */
#event-log::-webkit-scrollbar,
.tab-content-container::-webkit-scrollbar {
    width: 8px;
}

#event-log::-webkit-scrollbar-track,
.tab-content-container::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 10px;
}

#event-log::-webkit-scrollbar-thumb,
.tab-content-container::-webkit-scrollbar-thumb {
    background: var(--accent-primary);
    border-radius: 10px;
}

#event-log::-webkit-scrollbar-thumb:hover,
.tab-content-container::-webkit-scrollbar-thumb:hover {
    background: var(--accent-purple);
}

.event-card {
    background: var(--bg-card);
    border: 1px solid var(--border-color-bright);
    border-radius: 10px;
    padding: 20px;
    margin-bottom: 20px;
    box-shadow: var(--shadow-md);
    animation: slideIn 0.5s ease;
}

@keyframes slideIn {
    from { opacity: 0; transform: translateY(-20px); }
    to { opacity: 1; transform: translateY(0); }
}

.event-card h3 {
    color: var(--text-accent);
    margin-top: 0;
    margin-bottom: 15px;
    font-size: 1.4rem;
    text-align: center;
}

.event-card p {
    color: var(--text-secondary);
    line-height: 1.8;
    font-size: 1.05rem;
}

.player-action {
    margin-top: 15px;
    padding: 12px;
    background: linear-gradient(135deg, rgba(52, 152, 219, 0.2), rgba(41, 128, 185, 0.2));
    border-left: 4px solid var(--accent-primary);
    border-radius: 4px;
    font-style: italic;
    color: var(--text-accent);
}

.outcome-narrative {
    margin-top: 10px;
    padding: 12px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 4px;
    border-left: 4px solid var(--accent-success);
}

/* Interaction Area */
#interaction-area {
    margin-top: auto;
}

#action-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
    margin-bottom: 15px;
}

.action-btn {
    padding: 12px 16px;
    font-size: 0.95rem;
    background: var(--bg-card);
    color: var(--text-primary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: 500;
}

.action-btn:hover {
    background: var(--bg-card-hover);
    border-color: var(--accent-primary);
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
    color: var(--text-accent);
}

.action-btn:active {
    transform: translateY(0);
}

.action-btn.selected {
    background: linear-gradient(135deg, var(--accent-primary), #2980b9);
    border-color: var(--accent-primary);
    color: white;
    box-shadow: var(--glow-primary);
}

.action-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none !important;
}

.loading-indicator {
    margin-top: 15px;
    padding: 15px;
    background: rgba(52, 152, 219, 0.1);
    border: 1px solid var(--accent-primary);
    border-radius: 8px;
    text-align: center;
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
}

#player-input-area {
    display: flex;
    gap: 0;
    margin-bottom: 15px;
}

#player-input {
    flex: 1;
    padding: 12px 16px;
    border: 1px solid var(--border-color);
    background: rgba(255, 255, 255, 0.05);
    color: var(--text-primary);
    border-radius: 8px 0 0 8px;
    font-size: 1rem;
    transition: all 0.3s ease;
}

#player-input:focus {
    outline: none;
    border-color: var(--accent-primary);
    background: rgba(255, 255, 255, 0.08);
    box-shadow: var(--glow-primary);
}

#submit-action {
    padding: 12px 24px;
    border: 1px solid var(--border-color);
    background: linear-gradient(135deg, var(--accent-primary), var(--accent-purple));
    color: white;
    cursor: pointer;
    border-radius: 0 8px 8px 0;
    font-size: 1rem;
    font-weight: bold;
    transition: all 0.3s ease;
}

#submit-action:hover {
    background: linear-gradient(135deg, var(--accent-purple), var(--accent-primary));
    box-shadow: var(--glow-primary);
}

#continue-btn {
    width: 100%;
    padding: 15px 20px;
    border: none;
    background: linear-gradient(135deg, var(--accent-success), #27ae60);
    color: white;
    cursor: pointer;
    border-radius: 8px;
    font-size: 1.1rem;
    font-weight: bold;
    transition: all 0.3s ease;
    margin-bottom: 15px;
    box-shadow: var(--glow-success);
}

#continue-btn:hover {
    background: linear-gradient(135deg, #27ae60, var(--accent-success));
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(46, 204, 113, 0.4);
}

#game-controls {
    display: flex;
    gap: 10px;
    padding-top: 15px;
    border-top: 1px solid var(--border-color);
}

.game-control-btn {
    flex: 1;
    padding: 12px 20px;
    border: 1px solid var(--border-color);
    background: linear-gradient(135deg, rgba(243, 156, 18, 0.3), rgba(241, 196, 15, 0.3));
    color: var(--accent-gold);
    cursor: pointer;
    border-radius: 8px;
    font-size: 1rem;
    font-weight: bold;
    transition: all 0.3s ease;
}

.game-control-btn:hover {
    background: linear-gradient(135deg, var(--accent-warning), var(--accent-gold));
    color: white;
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
}

.hidden {
    display: none !important;
}

/* ========== RESPONSIVE DESIGN ========== */
@media (max-width: 1400px) {
    #game-container {
        grid-template-columns: 300px 1fr auto;
    }

    #middle-panel {
        min-width: 500px;
    }
}

@media (max-width: 1200px) {
    #game-container {
        grid-template-columns: 1fr;
        padding-top: 70px;
    }

    #left-panel, #middle-panel, #right-panel {
        max-width: 100%;
        width: 100%;
    }

    #right-panel.collapsed {
        width: 100%;
        height: auto;
    }

    .abbreviated-tabs {
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: center;
    }

    .tab-icon-btn {
        flex: 0 0 auto;
    }

    .dashboard-toggle {
        left: 50%;
        top: -15px;
        transform: translateX(-50%);
        width: 60px;
        height: 30px;
        border-radius: 0 0 8px 8px;
    }

    .dashboard-toggle:hover {
        top: -18px;
        left: 50%;
    }
}

/* ========== UTILITY CLASSES ========== */
.error {
    color: var(--accent-danger);
    font-weight: bold;
}

/* ========== PLAYER TENDENCY DISPLAY ========== */
.tendency-display {
    padding: 10px;
    text-align: center;
}

.tendency-badge {
    display: inline-block;
    padding: 8px 16px;
    border-radius: 20px;
    font-size: 0.9rem;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 10px;
    box-shadow: var(--shadow-sm);
}

.tendency-badge.tendency-expansion {
    background: linear-gradient(135deg, #e74c3c, #c0392b);
    color: white;
}

.tendency-badge.tendency-survival {
    background: linear-gradient(135deg, #27ae60, #229954);
    color: white;
}

.tendency-badge.tendency-religion {
    background: linear-gradient(135deg, #9b59b6, #8e44ad);
    color: white;
}

.tendency-badge.tendency-exploration {
    background: linear-gradient(135deg, #3498db, #2980b9);
    color: white;
}

.tendency-badge.tendency-balanced {
    background: linear-gradient(135deg, #95a5a6, #7f8c8d);
    color: white;
}

.tendency-description {
    font-size: 0.85rem;
    color: var(--text-secondary);
    font-style: italic;
}

/* ========== ACTIVE POLICY DISPLAY ========== */
.policy-display {
    padding: 10px;
    text-align: center;
}

.policy-badge {
    display: inline-block;
    padding: 8px 16px;
    border-radius: 20px;
    font-size: 0.9rem;
    font-weight: bold;
    text-transform: capitalize;
    letter-spacing: 1px;
    margin-bottom: 10px;
    box-shadow: var(--shadow-sm);
}

.policy-badge.policy-military_expansion {
    background: linear-gradient(135deg, #e74c3c, #c0392b);
    color: white;
}

.policy-badge.policy-economic_growth {
    background: linear-gradient(135deg, #f39c12, #d68910);
    color: white;
}

.policy-badge.policy-religious_devotion {
    background: linear-gradient(135deg, #9b59b6, #8e44ad);
    color: white;
}

.policy-badge.policy-scientific_advancement {
    background: linear-gradient(135deg, #3498db, #2980b9);
    color: white;
}

.policy-badge.policy-cultural_development {
    background: linear-gradient(135deg, #e91e63, #c2185b);
    color: white;
}

.policy-badge.policy-territorial_expansion {
    background: linear-gradient(135deg, #00bcd4, #0097a7);
    color: white;
}

.policy-badge.policy-exploration {
    background: linear-gradient(135deg, #009688, #00796b);
    color: white;
}

.policy-badge.policy-general_governance {
    background: linear-gradient(135deg, #95a5a6, #7f8c8d);
    color: white;
}

.policy-description {
    font-size: 0.85rem;
    color: var(--text-secondary);
    font-style: italic;
}

/* ========== RESOURCE CHANGE ANIMATIONS ========== */
@keyframes statIncrease {
    0% {
        transform: scale(1);
        color: var(--text-accent);
    }
    50% {
        transform: scale(1.15);
        color: var(--accent-success);
        text-shadow: 0 0 10px var(--accent-success);
    }
    100% {
        transform: scale(1);
        color: var(--text-accent);
    }
}

@keyframes statDecrease {
    0% {
        transform: scale(1);
        color: var(--text-accent);
    }
    50% {
        transform: scale(1.15);
        color: var(--accent-danger);
        text-shadow: 0 0 10px var(--accent-danger);
    }
    100% {
        transform: scale(1);
        color: var(--text-accent);
    }
}

.stat-value.increased {
    animation: statIncrease 0.6s ease;
}

.stat-value.decreased {
    animation: statDecrease 0.6s ease;
}

/* ========== DASHBOARD CHANGE HIGHLIGHTS ========== */
@keyframes highlightPulse {
    0% {
        box-shadow: 0 0 0 0 rgba(241, 196, 15, 0.7);
        transform: scale(1);
    }
    50% {
        box-shadow: 0 0 20px 8px rgba(241, 196, 15, 0.3);
        transform: scale(1.05);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(241, 196, 15, 0);
        transform: scale(1);
    }
}

@keyframes glowBorder {
    0%, 100% {
        border-color: var(--accent-gold);
        box-shadow: 0 0 10px rgba(241, 196, 15, 0.5);
    }
    50% {
        border-color: var(--accent-warning);
        box-shadow: 0 0 20px rgba(243, 156, 18, 0.7);
    }
}

.highlight-new {
    animation: highlightPulse 1s ease-out 3, glowBorder 0.8s ease-in-out 5;
    background: linear-gradient(135deg, rgba(241, 196, 15, 0.3), rgba(243, 156, 18, 0.3)) !important;
    border-color: var(--accent-gold) !important;
}

.highlight-changed {
    animation: highlightPulse 1s ease-out 2;
    background: linear-gradient(135deg, rgba(52, 152, 219, 0.3), rgba(41, 128, 185, 0.3)) !important;
    border-color: var(--accent-primary) !important;
}

.fade-out {
    transition: all 0.5s ease-out;
    opacity: 0.6;
}

/* ========== IMPACT SUMMARY ========== */
.impact-summary {
    margin-top: 15px;
    padding: 15px;
    background: linear-gradient(135deg, rgba(46, 204, 113, 0.15), rgba(52, 152, 219, 0.15));
    border: 2px solid var(--accent-success);
    border-radius: 8px;
    animation: slideIn 0.4s ease-out;
}

.impact-summary h4 {
    margin: 0 0 10px 0;
    color: var(--accent-success);
    font-size: 1rem;
    text-align: center;
}

.impact-items {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: center;
}

.impact-tag {
    padding: 6px 12px;
    background: linear-gradient(135deg, rgba(46, 204, 113, 0.3), rgba(39, 174, 96, 0.3));
    border: 1px solid var(--accent-success);
    border-radius: 15px;
    font-size: 0.85rem;
    font-weight: 600;
    color: var(--accent-success);
    animation: popIn 0.3s ease-out;
}

.impact-tag:nth-child(1) { animation-delay: 0.1s; }
.impact-tag:nth-child(2) { animation-delay: 0.2s; }
.impact-tag:nth-child(3) { animation-delay: 0.3s; }
.impact-tag:nth-child(4) { animation-delay: 0.4s; }
.impact-tag:nth-child(5) { animation-delay: 0.5s; }

@keyframes popIn {
    0% {
        opacity: 0;
        transform: scale(0.5);
    }
    60% {
        transform: scale(1.1);
    }
    100% {
        opacity: 1;
        transform: scale(1);
    }
}

/* ========== RESOURCE WARNING STYLES ========== */
.resource-warnings {
    margin: 15px 0;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.resource-warning {
    padding: 12px 16px;
    border-radius: 8px;
    font-weight: 600;
    font-size: 0.95rem;
    border-left: 4px solid;
    animation: warningPulse 0.5s ease-out;
}

.warning-famine_critical {
    background: linear-gradient(135deg, rgba(231, 76, 60, 0.2), rgba(192, 57, 43, 0.2));
    border-color: #e74c3c;
    color: #ff6b6b;
}

.warning-famine_warning {
    background: linear-gradient(135deg, rgba(243, 156, 18, 0.2), rgba(211, 84, 0, 0.2));
    border-color: #f39c12;
    color: #f39c12;
}

.warning-food_low {
    background: linear-gradient(135deg, rgba(241, 196, 15, 0.15), rgba(243, 156, 18, 0.15));
    border-color: #f1c40f;
    color: #f1c40f;
}

.warning-bankruptcy {
    background: linear-gradient(135deg, rgba(231, 76, 60, 0.2), rgba(192, 57, 43, 0.2));
    border-color: #e74c3c;
    color: #ff6b6b;
}

.warning-wealth_low {
    background: linear-gradient(135deg, rgba(243, 156, 18, 0.15), rgba(211, 84, 0, 0.15));
    border-color: #f39c12;
    color: #f39c12;
}

@keyframes warningPulse {
    0% {
        opacity: 0;
        transform: translateX(-20px);
    }
    50% {
        transform: translateX(5px);
    }
    100% {
        opacity: 1;
        transform: translateX(0);
    }
}

/* ========== CRISIS EVENT STYLES ========== */
.crisis-event {
    border: 2px solid #e74c3c !important;
    background: linear-gradient(135deg, rgba(231, 76, 60, 0.15), rgba(192, 57, 43, 0.1)) !important;
    box-shadow: 0 0 30px rgba(231, 76, 60, 0.3), var(--shadow-lg);
    animation: crisisPulse 2s infinite;
}

.crisis-badge {
    display: inline-block;
    padding: 4px 12px;
    background: linear-gradient(135deg, #e74c3c, #c0392b);
    color: white;
    border-radius: 6px;
    font-size: 0.85rem;
    font-weight: bold;
    margin-left: 10px;
    animation: badgePulse 1.5s infinite;
}

@keyframes crisisPulse {
    0%, 100% {
        box-shadow: 0 0 30px rgba(231, 76, 60, 0.3), var(--shadow-lg);
    }
    50% {
        box-shadow: 0 0 50px rgba(231, 76, 60, 0.5), var(--shadow-lg);
    }
}

@keyframes badgePulse {
    0%, 100% {
        opacity: 1;
        transform: scale(1);
    }
    50% {
        opacity: 0.8;
        transform: scale(1.05);
    }
}

/* ========== GAME OVER STYLES ========== */
.game-over-card {
    padding: 40px;
    text-align: center;
    border-radius: 16px;
    animation: gameOverReveal 1s ease-out;
}

.game-over-card.victory {
    background: linear-gradient(135deg, rgba(46, 204, 113, 0.2), rgba(39, 174, 96, 0.15));
    border: 3px solid #2ecc71;
    box-shadow: 0 0 60px rgba(46, 204, 113, 0.4);
}

.game-over-card.defeat {
    background: linear-gradient(135deg, rgba(231, 76, 60, 0.2), rgba(192, 57, 43, 0.15));
    border: 3px solid #e74c3c;
    box-shadow: 0 0 60px rgba(231, 76, 60, 0.4);
}

.game-over-icon {
    font-size: 120px;
    margin-bottom: 20px;
    animation: iconBounce 1.5s ease-in-out;
}

.game-over-card h2 {
    font-size: 2.5rem;
    margin: 20px 0;
    background: linear-gradient(135deg, var(--text-header), var(--text-accent));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

.game-over-narrative {
    font-size: 1.2rem;
    line-height: 1.8;
    margin: 30px 0;
    color: var(--text-primary);
}

.game-over-actions {
    margin-top: 40px;
}

.game-over-btn {
    padding: 16px 40px;
    font-size: 1.1rem;
    background: linear-gradient(135deg, var(--accent-primary), #2980b9);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.game-over-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(52, 152, 219, 0.4);
}

@keyframes gameOverReveal {
    0% {
        opacity: 0;
        transform: scale(0.8);
    }
    100% {
        opacity: 1;
        transform: scale(1);
    }
}

@keyframes iconBounce {
    0%, 100% {
        transform: translateY(0);
    }
    50% {
        transform: translateY(-20px);
    }
}

/* ========== SUCCESSOR SELECTION STYLES ========== */
.succession-event {
    padding: 30px;
}

.succession-event h3 {
    text-align: center;
    font-size: 2rem;
    margin-bottom: 20px;
    color: var(--text-header);
}

.succession-summary {
    text-align: center;
    font-size: 1.1rem;
    margin-bottom: 30px;
    color: var(--text-secondary);
    padding: 15px;
    background: rgba(52, 152, 219, 0.1);
    border-radius: 8px;
}

.succession-candidates {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 20px;
    margin-top: 30px;
}

.successor-card {
    background: var(--bg-card);
    border: 2px solid var(--border-color);
    border-radius: 12px;
    padding: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.successor-card:hover {
    border-color: var(--accent-primary);
    background: var(--bg-card-hover);
    transform: translateY(-5px);
    box-shadow: 0 8px 24px rgba(52, 152, 219, 0.3);
}

.successor-card h4 {
    color: var(--text-header);
    font-size: 1.5rem;
    margin-bottom: 10px;
}

.successor-type {
    display: inline-block;
    padding: 4px 12px;
    background: linear-gradient(135deg, var(--accent-primary), #2980b9);
    color: white;
    border-radius: 6px;
    font-size: 0.85rem;
    margin-bottom: 10px;
}

.successor-age {
    color: var(--text-muted);
    font-size: 0.9rem;
    margin-bottom: 15px;
}

.successor-traits {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin: 15px 0;
}

.successor-traits .trait-badge {
    padding: 4px 10px;
    background: rgba(155, 89, 182, 0.2);
    border: 1px solid rgba(155, 89, 182, 0.4);
    border-radius: 4px;
    font-size: 0.8rem;
    color: var(--accent-purple);
}

.successor-desc {
    color: var(--text-secondary);
    font-size: 0.95rem;
    margin-top: 10px;
    font-style: italic;
}

.legacy-text {
    color: var(--accent-gold);
    font-style: italic;
    margin: 20px 0;
    padding: 15px;
    background: rgba(241, 196, 15, 0.1);
    border-left: 3px solid var(--accent-gold);
    border-radius: 4px;
}

.legacy-bonuses {
    margin-top: 20px;
    padding: 15px;
    background: rgba(46, 204, 113, 0.1);
    border-radius: 8px;
}

.legacy-bonuses h4 {
    color: var(--accent-success);
    margin-bottom: 10px;
}

.legacy-bonuses ul {
    list-style: none;
    padding: 0;
}

.legacy-bonuses li {
    color: var(--text-secondary);
    padding: 5px 0;
    padding-left: 20px;
    position: relative;
}

.legacy-bonuses li::before {
    content: "‚úì";
    position: absolute;
    left: 0;
    color: var(--accent-success);
    font-weight: bold;
}

/* ========== VISUAL ENHANCEMENTS - LEADER PORTRAITS ========== */
.leader-portrait-container {
    width: 100%;
    margin-bottom: 15px;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: var(--shadow-md);
    background: var(--bg-card);
}

.leader-portrait-container img {
    width: 100%;
    height: auto;
    display: block;
    aspect-ratio: 3/4;
    object-fit: cover;
}

/* Successor candidate portraits */
.successor-portrait {
    width: 100%;
    height: 180px;
    margin-bottom: 12px;
    border-radius: 8px;
    overflow: hidden;
    background: var(--bg-card);
    box-shadow: var(--shadow-sm);
}

.successor-portrait img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
}

.successor-card {
    cursor: pointer;
    transition: all 0.3s ease;
    border: 2px solid transparent;
}

.successor-card:hover {
    transform: translateY(-5px);
    border-color: var(--accent-primary);
    box-shadow: var(--glow-primary);
}

/* ========== CRISIS EVENT VISUALS ========== */
.crisis-visual {
    width: 100%;
    max-height: 250px;
    margin-bottom: 15px;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: var(--shadow-md);
}

.crisis-visual img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
}

.crisis-event .crisis-visual {
    border: 2px solid var(--accent-danger);
    box-shadow: 0 0 20px rgba(231, 76, 60, 0.4);
}

/* ========== INNER CIRCLE STYLES ========== */

/* Overview Tab - Simplified Inner Circle Display */
.inner-circle-summary {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 10px;
}

.member-name-tag {
    padding: 6px 14px;
    background: linear-gradient(135deg, rgba(241, 196, 15, 0.2), rgba(243, 156, 18, 0.2));
    border: 1px solid var(--accent-gold);
    border-radius: 15px;
    font-size: 0.85rem;
    font-weight: 600;
    color: var(--accent-gold);
    transition: all 0.3s ease;
}

.member-name-tag:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 8px rgba(241, 196, 15, 0.3);
}

.inner-circle-hint {
    font-size: 0.8rem;
    color: var(--text-muted);
    font-style: italic;
    text-align: center;
    margin-top: 8px;
}

/* Inner Circle Tab - Detailed Information Briefs */
#inner-circle-briefs {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.inner-circle-brief {
    background: var(--bg-card);
    border: 2px solid var(--border-color);
    border-radius: 12px;
    padding: 20px;
    transition: all 0.3s ease;
    animation: slideIn 0.4s ease-out;
}

.inner-circle-brief:hover {
    border-color: var(--accent-gold);
    box-shadow: 0 8px 24px rgba(241, 196, 15, 0.2);
    transform: translateY(-2px);
}

.brief-header {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    align-items: flex-start;
    gap: 15px;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 2px solid var(--border-color);
}

.brief-name-section {
    flex: 1;
    min-width: 120px;
    overflow: hidden;
}

/* Advisor Portrait Thumbnail (Inner Circle Tab) */
.advisor-portrait-thumbnail {
    width: 80px;
    height: 80px;
    object-fit: cover;
    border-radius: 8px;
    border: 2px solid var(--border-color);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    transition: all 0.3s ease;
    flex-shrink: 0;
}

.advisor-portrait-thumbnail:hover {
    border-color: var(--accent-gold);
    box-shadow: 0 4px 12px rgba(241, 196, 15, 0.3);
    transform: scale(1.05);
}

.brief-name {
    margin: 0 0 5px 0;
    font-size: 1.4rem;
    color: var(--accent-gold);
    text-shadow: 0 0 10px rgba(241, 196, 15, 0.3);
}

.brief-role {
    display: block;
    font-size: 0.9rem;
    color: var(--text-muted);
    font-style: italic;
}

.brief-faction {
    padding: 6px 12px;
    background: linear-gradient(135deg, rgba(52, 152, 219, 0.2), rgba(41, 128, 185, 0.2));
    border: 1px solid var(--accent-primary);
    border-radius: 8px;
    font-size: 0.85rem;
    color: var(--accent-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 150px;
    flex-shrink: 0;
}

.brief-metrics {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-bottom: 20px;
}

.metric-row {
    display: grid;
    grid-template-columns: 100px 1fr 50px;
    align-items: center;
    gap: 12px;
}

.metric-label {
    font-size: 0.9rem;
    color: var(--text-secondary);
    font-weight: 600;
}

.metric-bar-container {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    height: 12px;
    overflow: hidden;
    position: relative;
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
}

.metric-bar {
    height: 100%;
    border-radius: 10px;
    transition: width 0.5s ease, background-color 0.3s ease;
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    position: relative;
    overflow: hidden;
}

.metric-bar::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    animation: shimmer 2s infinite;
}

@keyframes shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
}

.metric-value {
    font-size: 0.95rem;
    font-weight: bold;
    color: var(--text-accent);
    text-align: right;
}

.brief-history {
    background: rgba(52, 152, 219, 0.1);
    border-left: 3px solid var(--accent-primary);
    border-radius: 4px;
    padding: 12px 15px;
    margin-bottom: 15px;
}

.history-label {
    font-size: 0.85rem;
    color: var(--accent-primary);
    font-weight: 600;
    margin-bottom: 6px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.history-text {
    font-size: 0.9rem;
    color: var(--text-secondary);
    line-height: 1.6;
    font-style: italic;
}

.audience-btn {
    width: 100%;
    padding: 12px 20px;
    background: linear-gradient(135deg, var(--accent-primary), #2980b9);
    border: 2px solid var(--accent-primary);
    border-radius: 8px;
    color: white;
    font-size: 1rem;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
}

.audience-btn:hover {
    background: linear-gradient(135deg, #2980b9, var(--accent-primary));
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
}

.audience-btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
}

/* Advisor Portrait Display (Request Audience) */
.advisor-portrait-display {
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 20px 0;
    animation: fadeIn 0.5s ease-in;
}

.advisor-portrait-large {
    width: 250px;
    height: 333px;
    object-fit: cover;
    border-radius: 12px;
    border: 3px solid var(--accent-gold);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4), 0 0 20px rgba(241, 196, 15, 0.2);
    transition: all 0.3s ease;
}

.advisor-portrait-large:hover {
    box-shadow: 0 12px 32px rgba(0, 0, 0, 0.5), 0 0 30px rgba(241, 196, 15, 0.3);
    transform: scale(1.02);
}

/* ========== SETTLEMENT GALLERY ========== */
.settlement-gallery {
    margin-top: 20px;
    padding: 15px;
    background: var(--bg-card);
    border-radius: 8px;
    border: 1px solid var(--border-color);
}

.settlement-gallery h4 {
    margin-bottom: 15px;
    color: var(--text-header);
    font-size: 1.1rem;
}

.gallery-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 12px;
}

.gallery-item {
    cursor: pointer;
    border-radius: 6px;
    overflow: hidden;
    background: var(--bg-secondary);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    border: 2px solid transparent;
}

.gallery-item:hover {
    transform: scale(1.05);
    border-color: var(--accent-primary);
    box-shadow: var(--glow-primary);
}

.gallery-item img {
    width: 100%;
    height: 120px;
    object-fit: cover;
    display: block;
}

.gallery-item-info {
    padding: 8px;
    text-align: center;
    font-size: 0.85rem;
}

.gallery-year {
    color: var(--text-accent);
    font-weight: bold;
}

.gallery-era {
    color: var(--text-secondary);
    font-size: 0.75rem;
    text-transform: capitalize;
}

/* ========== FACTION CARDS ========== */
#faction-cards-container {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

.faction-card {
    background: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 20px;
    transition: all 0.3s ease;
    box-shadow: var(--shadow-sm);
}

.faction-card:hover {
    background: var(--bg-card-hover);
    border-color: var(--border-color-bright);
    box-shadow: var(--shadow-md);
    transform: translateY(-2px);
}

.faction-card-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 16px;
    padding-bottom: 12px;
    border-bottom: 2px solid var(--border-color);
}

.faction-name-section {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.faction-name {
    color: var(--text-header);
    font-size: 1.2rem;
    margin: 0;
    font-weight: bold;
}

.faction-leader {
    color: var(--text-secondary);
    font-size: 0.9rem;
    font-style: italic;
}

.faction-status {
    padding: 6px 12px;
    border-radius: 6px;
    color: white;
    font-size: 0.85rem;
    font-weight: bold;
    text-transform: uppercase;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.faction-metrics {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-bottom: 16px;
}

.metric-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.metric-label-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    color: var(--text-secondary);
    font-size: 0.9rem;
}

.metric-value-text {
    color: var(--text-accent);
    font-weight: bold;
    font-size: 1rem;
}

.approval-bar-container {
    width: 100%;
    height: 12px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 6px;
    overflow: hidden;
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
}

.approval-bar-fill {
    height: 100%;
    transition: width 0.5s ease, background-color 0.5s ease;
    border-radius: 6px;
    box-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
}

.faction-effects {
    background: rgba(52, 152, 219, 0.1);
    padding: 12px;
    border-radius: 8px;
    margin-bottom: 12px;
    border-left: 3px solid var(--accent-primary);
}

.effects-label {
    color: var(--text-accent);
    font-weight: bold;
    font-size: 0.9rem;
    margin-bottom: 8px;
}

.effect-item {
    color: var(--text-primary);
    padding: 6px 0;
    font-size: 0.95rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.effect-item:last-child {
    border-bottom: none;
}

.effect-item.no-effect {
    color: var(--text-muted);
    font-style: italic;
}

.faction-history {
    background: rgba(155, 89, 182, 0.1);
    padding: 12px;
    border-radius: 8px;
    border-left: 3px solid var(--accent-purple);
}

.history-label {
    color: var(--accent-purple);
    font-weight: bold;
    font-size: 0.9rem;
    margin-bottom: 8px;
}

.history-list {
    max-height: 150px;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: var(--accent-purple) rgba(255, 255, 255, 0.1);
}

.history-entry {
    color: var(--text-secondary);
    padding: 6px 0;
    font-size: 0.85rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    line-height: 1.4;
}

.history-entry:last-child {
    border-bottom: none;
}

/* Scrollbar styling for history */
.history-list::-webkit-scrollbar {
    width: 6px;
}

.history-list::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 3px;
}

.history-list::-webkit-scrollbar-thumb {
    background: var(--accent-purple);
    border-radius: 3px;
}

.history-list::-webkit-scrollbar-thumb:hover {
    background: #b47fcd;
}



################################################################################
# FILE: old_codebase\templates\custom_world.html
# Size: 37377 bytes
################################################################################

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom World Creation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #f1f1f1;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            color: #c9a961;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            margin-bottom: 10px;
        }

        .header p {
            color: #a8a8a8;
            font-style: italic;
        }

        .progress-bar {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 5px;
            margin-bottom: 30px;
        }

        .progress-fill {
            background: linear-gradient(90deg, #c9a961 0%, #d4b56f 100%);
            height: 10px;
            border-radius: 5px;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            margin-top: 10px;
            color: #c9a961;
            font-size: 0.9em;
        }

        .form-container {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #c9a961;
            border-radius: 10px;
            padding: 40px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .step {
            display: none;
        }

        .step.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .step-title {
            font-size: 1.8em;
            color: #c9a961;
            margin-bottom: 20px;
            text-align: center;
        }

        .step-description {
            text-align: center;
            color: #a8a8a8;
            margin-bottom: 30px;
            font-size: 0.95em;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 10px;
            color: #c9a961;
            font-weight: bold;
        }

        .form-group input[type="text"],
        .form-group input[type="number"] {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #c9a961;
            border-radius: 5px;
            color: #f1f1f1;
            font-size: 1em;
            font-family: 'Georgia', serif;
        }

        .form-group input::placeholder {
            color: #a8a8a8;
        }

        .option-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }

        .option-card {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid transparent;
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .option-card:hover {
            background: rgba(201, 169, 97, 0.1);
            border-color: #c9a961;
        }

        .option-card.selected {
            background: rgba(201, 169, 97, 0.2);
            border-color: #c9a961;
            box-shadow: 0 0 20px rgba(201, 169, 97, 0.3);
        }

        .option-card .option-icon {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .option-card .option-title {
            font-weight: bold;
            color: #f1f1f1;
            margin-bottom: 5px;
        }

        .option-card .option-desc {
            font-size: 0.85em;
            color: #a8a8a8;
        }

        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }

        .btn {
            flex: 1;
            padding: 15px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Georgia', serif;
        }

        .btn-primary {
            background: linear-gradient(135deg, #c9a961 0%, #a08040 100%);
            color: #1a1a2e;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #d4b56f 0%, #b89550 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            color: #e2e8f0;
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #5a6678 0%, #3d4758 100%);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .randomize-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .randomize-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .review-section {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #c9a961;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .review-section h3 {
            color: #c9a961;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .review-section p {
            margin: 5px 0;
            color: #d1d1d1;
        }

        .review-section strong {
            color: #c9a961;
        }

        .error-message {
            background: rgba(220, 38, 38, 0.2);
            border: 1px solid #dc2626;
            color: #fca5a5;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }

        .loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .loading-overlay.active {
            display: flex;
        }

        .spinner {
            border: 4px solid rgba(201, 169, 97, 0.3);
            border-top: 4px solid #c9a961;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: #c9a961;
            font-size: 1.2em;
        }

        .back-to-menu {
            text-align: center;
            margin-top: 20px;
        }

        .back-to-menu a {
            color: #c9a961;
            text-decoration: none;
            font-size: 0.95em;
        }

        .back-to-menu a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Create Your World</h1>
            <p>Shape the destiny of your civilization</p>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
            <div class="progress-text" id="progress-text">Step 1 of 7</div>
        </div>

        <div class="form-container">
            <div id="error-message" class="error-message"></div>

            <!-- Step 1: Era Selection -->
            <div class="step active" id="step-1">
                <h2 class="step-title">Choose Your Starting Era</h2>
                <p class="step-description">The era determines your initial technology and societal development</p>

                <div class="option-grid">
                    <div class="option-card" data-value="stone_age" onclick="selectOption('era', 'stone_age', this)">
                        <div class="option-icon">ü™®</div>
                        <div class="option-title">Stone Age</div>
                        <div class="option-desc">Primitive tools, hunter-gatherer society</div>
                    </div>
                    <div class="option-card" data-value="bronze_age" onclick="selectOption('era', 'bronze_age', this)">
                        <div class="option-icon">‚öíÔ∏è</div>
                        <div class="option-title">Bronze Age</div>
                        <div class="option-desc">Basic metallurgy, early agriculture</div>
                    </div>
                    <div class="option-card" data-value="iron_age" onclick="selectOption('era', 'iron_age', this)">
                        <div class="option-icon">‚öîÔ∏è</div>
                        <div class="option-title">Iron Age</div>
                        <div class="option-desc">Advanced tools, established settlements</div>
                    </div>
                    <div class="option-card" data-value="classical" onclick="selectOption('era', 'classical', this)">
                        <div class="option-icon">üèõÔ∏è</div>
                        <div class="option-title">Classical Era</div>
                        <div class="option-desc">Organized society, trade networks</div>
                    </div>
                </div>
            </div>

            <!-- Step 2: Geography -->
            <div class="step" id="step-2">
                <h2 class="step-title">Select Your Geography</h2>
                <p class="step-description">Your environment shapes available resources and challenges</p>

                <div class="option-grid">
                    <div class="option-card" data-value="coastal" onclick="selectOption('terrain', 'coastal', this)">
                        <div class="option-icon">üåä</div>
                        <div class="option-title">Coastal</div>
                        <div class="option-desc">Beaches, fishing, maritime trade</div>
                    </div>
                    <div class="option-card" data-value="forest" onclick="selectOption('terrain', 'forest', this)">
                        <div class="option-icon">üå≤</div>
                        <div class="option-title">Forest</div>
                        <div class="option-desc">Dense woods, hunting, timber</div>
                    </div>
                    <div class="option-card" data-value="mountain" onclick="selectOption('terrain', 'mountain', this)">
                        <div class="option-icon">‚õ∞Ô∏è</div>
                        <div class="option-title">Mountain</div>
                        <div class="option-desc">Highlands, stone, defensible terrain</div>
                    </div>
                    <div class="option-card" data-value="desert" onclick="selectOption('terrain', 'desert', this)">
                        <div class="option-icon">üèúÔ∏è</div>
                        <div class="option-title">Desert</div>
                        <div class="option-desc">Arid land, oases, harsh conditions</div>
                    </div>
                    <div class="option-card" data-value="plains" onclick="selectOption('terrain', 'plains', this)">
                        <div class="option-icon">üåæ</div>
                        <div class="option-title">Plains</div>
                        <div class="option-desc">Grasslands, agriculture, open spaces</div>
                    </div>
                    <div class="option-card" data-value="river_valley" onclick="selectOption('terrain', 'river_valley', this)">
                        <div class="option-icon">üèûÔ∏è</div>
                        <div class="option-title">River Valley</div>
                        <div class="option-desc">Fertile land, fresh water, fishing</div>
                    </div>
                    <div class="option-card" data-value="island" onclick="selectOption('terrain', 'island', this)">
                        <div class="option-icon">üèùÔ∏è</div>
                        <div class="option-title">Island</div>
                        <div class="option-desc">Isolated, unique resources, limited space</div>
                    </div>
                </div>

                <div class="form-group" style="margin-top: 25px;">
                    <label>Resource Abundance</label>
                    <div class="option-grid">
                        <div class="option-card" data-value="scarce" onclick="selectOption('resource_abundance', 'scarce', this)">
                            <div class="option-title">Scarce</div>
                            <div class="option-desc">Limited resources, harder survival</div>
                        </div>
                        <div class="option-card" data-value="moderate" onclick="selectOption('resource_abundance', 'moderate', this)">
                            <div class="option-title">Moderate</div>
                            <div class="option-desc">Balanced resources</div>
                        </div>
                        <div class="option-card" data-value="abundant" onclick="selectOption('resource_abundance', 'abundant', this)">
                            <div class="option-title">Abundant</div>
                            <div class="option-desc">Rich resources, easier growth</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Step 3: Civilization Identity -->
            <div class="step" id="step-3">
                <h2 class="step-title">Name Your Civilization</h2>
                <p class="step-description">Give your people an identity and choose your leader</p>

                <button class="randomize-btn" onclick="randomizeCivName()">üé≤ Randomize Name</button>
                <div class="form-group">
                    <label>Civilization Name</label>
                    <input type="text" id="civilization-name" placeholder="The People of..." maxlength="50">
                </div>

                <div class="form-group">
                    <label>Starting Population</label>
                    <div class="option-grid">
                        <div class="option-card" data-value="small" onclick="selectOption('population_size', 'small', this)">
                            <div class="option-title">Small</div>
                            <div class="option-desc">100-500 people</div>
                        </div>
                        <div class="option-card" data-value="medium" onclick="selectOption('population_size', 'medium', this)">
                            <div class="option-title">Medium</div>
                            <div class="option-desc">500-2000 people</div>
                        </div>
                        <div class="option-card" data-value="large" onclick="selectOption('population_size', 'large', this)">
                            <div class="option-title">Large</div>
                            <div class="option-desc">2000-5000 people</div>
                        </div>
                    </div>
                </div>

                <button class="randomize-btn" onclick="randomizeLeaderName()">üé≤ Randomize Leader</button>
                <div class="form-group">
                    <label>Leader Name (Optional - leave blank for random)</label>
                    <input type="text" id="leader-name" placeholder="Your leader's name..." maxlength="50">
                </div>
            </div>

            <!-- Step 4: Cultural Foundation -->
            <div class="step" id="step-4">
                <h2 class="step-title">Define Your Culture</h2>
                <p class="step-description">Choose the values and structure that define your people</p>

                <div class="form-group">
                    <label>Primary Cultural Focus</label>
                    <div class="option-grid">
                        <div class="option-card" data-value="martial" onclick="selectOption('cultural_focus', 'martial', this)">
                            <div class="option-icon">‚öîÔ∏è</div>
                            <div class="option-title">Martial</div>
                            <div class="option-desc">Strength, honor, warfare</div>
                        </div>
                        <div class="option-card" data-value="spiritual" onclick="selectOption('cultural_focus', 'spiritual', this)">
                            <div class="option-icon">‚ú®</div>
                            <div class="option-title">Spiritual</div>
                            <div class="option-desc">Wisdom, devotion, mysticism</div>
                        </div>
                        <div class="option-card" data-value="agricultural" onclick="selectOption('cultural_focus', 'agricultural', this)">
                            <div class="option-icon">üåæ</div>
                            <div class="option-title">Agricultural</div>
                            <div class="option-desc">Farming, community, sustainability</div>
                        </div>
                        <div class="option-card" data-value="mercantile" onclick="selectOption('cultural_focus', 'mercantile', this)">
                            <div class="option-icon">üí∞</div>
                            <div class="option-title">Mercantile</div>
                            <div class="option-desc">Trade, prosperity, diplomacy</div>
                        </div>
                        <div class="option-card" data-value="scholarly" onclick="selectOption('cultural_focus', 'scholarly', this)">
                            <div class="option-icon">üìö</div>
                            <div class="option-title">Scholarly</div>
                            <div class="option-desc">Knowledge, innovation, learning</div>
                        </div>
                        <div class="option-card" data-value="artistic" onclick="selectOption('cultural_focus', 'artistic', this)">
                            <div class="option-icon">üé®</div>
                            <div class="option-title">Artistic</div>
                            <div class="option-desc">Beauty, creativity, expression</div>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label>Social Structure</label>
                    <div class="option-grid">
                        <div class="option-card" data-value="egalitarian" onclick="selectOption('social_structure', 'egalitarian', this)">
                            <div class="option-title">Egalitarian</div>
                            <div class="option-desc">Collective decisions, equality</div>
                        </div>
                        <div class="option-card" data-value="hierarchical" onclick="selectOption('social_structure', 'hierarchical', this)">
                            <div class="option-title">Hierarchical</div>
                            <div class="option-desc">Clear social ranks</div>
                        </div>
                        <div class="option-card" data-value="tribal_council" onclick="selectOption('social_structure', 'tribal_council', this)">
                            <div class="option-title">Tribal Council</div>
                            <div class="option-desc">Elders and leaders govern</div>
                        </div>
                        <div class="option-card" data-value="monarchy" onclick="selectOption('social_structure', 'monarchy', this)">
                            <div class="option-title">Monarchy</div>
                            <div class="option-desc">Hereditary rulership</div>
                        </div>
                        <div class="option-card" data-value="theocracy" onclick="selectOption('social_structure', 'theocracy', this)">
                            <div class="option-title">Theocracy</div>
                            <div class="option-desc">Religious leadership</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Step 5: Religious Beliefs -->
            <div class="step" id="step-5">
                <h2 class="step-title">Choose Your Beliefs</h2>
                <p class="step-description">What spiritual or philosophical path do your people follow?</p>

                <div class="option-grid">
                    <div class="option-card" data-value="animism" onclick="selectOption('religion_type', 'animism', this)">
                        <div class="option-icon">üåø</div>
                        <div class="option-title">Animism</div>
                        <div class="option-desc">Spirit worship, nature reverence</div>
                    </div>
                    <div class="option-card" data-value="polytheism" onclick="selectOption('religion_type', 'polytheism', this)">
                        <div class="option-icon">‚ö°</div>
                        <div class="option-title">Polytheism</div>
                        <div class="option-desc">Multiple deities, diverse pantheon</div>
                    </div>
                    <div class="option-card" data-value="monotheism" onclick="selectOption('religion_type', 'monotheism', this)">
                        <div class="option-icon">‚òÄÔ∏è</div>
                        <div class="option-title">Monotheism</div>
                        <div class="option-desc">Single supreme deity</div>
                    </div>
                    <div class="option-card" data-value="ancestor_worship" onclick="selectOption('religion_type', 'ancestor_worship', this)">
                        <div class="option-icon">üëª</div>
                        <div class="option-title">Ancestor Worship</div>
                        <div class="option-desc">Veneration of the dead</div>
                    </div>
                    <div class="option-card" data-value="nature_worship" onclick="selectOption('religion_type', 'nature_worship', this)">
                        <div class="option-icon">üå≥</div>
                        <div class="option-title">Nature Worship</div>
                        <div class="option-desc">Earth and natural forces</div>
                    </div>
                    <div class="option-card" data-value="none" onclick="selectOption('religion_type', 'none', this)">
                        <div class="option-icon">ü§î</div>
                        <div class="option-title">Secular</div>
                        <div class="option-desc">No dominant religion</div>
                    </div>
                </div>
            </div>

            <!-- Step 6: World Challenges -->
            <div class="step" id="step-6">
                <h2 class="step-title">Set the Challenge</h2>
                <p class="step-description">How harsh will your world be?</p>

                <div class="form-group">
                    <label>Difficulty Level</label>
                    <div class="option-grid">
                        <div class="option-card" data-value="peaceful" onclick="selectOption('difficulty', 'peaceful', this)">
                            <div class="option-icon">üïäÔ∏è</div>
                            <div class="option-title">Peaceful</div>
                            <div class="option-desc">Fewer threats, friendly neighbors</div>
                        </div>
                        <div class="option-card" data-value="balanced" onclick="selectOption('difficulty', 'balanced', this)">
                            <div class="option-icon">‚öñÔ∏è</div>
                            <div class="option-title">Balanced</div>
                            <div class="option-desc">Moderate challenges</div>
                        </div>
                        <div class="option-card" data-value="challenging" onclick="selectOption('difficulty', 'challenging', this)">
                            <div class="option-icon">üíÄ</div>
                            <div class="option-title">Challenging</div>
                            <div class="option-desc">Hostile world, many threats</div>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label>Known Neighbors</label>
                    <div class="option-grid">
                        <div class="option-card" data-value="none" onclick="selectOption('neighbor_count', 'none', this)">
                            <div class="option-title">Isolated</div>
                            <div class="option-desc">No known neighbors</div>
                        </div>
                        <div class="option-card" data-value="few" onclick="selectOption('neighbor_count', 'few', this)">
                            <div class="option-title">Few</div>
                            <div class="option-desc">1-2 neighboring groups</div>
                        </div>
                        <div class="option-card" data-value="several" onclick="selectOption('neighbor_count', 'several', this)">
                            <div class="option-title">Several</div>
                            <div class="option-desc">3-4 neighboring groups</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Step 7: Review and Confirm -->
            <div class="step" id="step-7">
                <h2 class="step-title">Review Your World</h2>
                <p class="step-description">Confirm your choices and begin your journey</p>

                <div id="review-content">
                    <!-- Review content will be populated by JavaScript -->
                </div>
            </div>

            <!-- Navigation Buttons -->
            <div class="button-group">
                <button class="btn btn-secondary" id="back-btn" onclick="previousStep()" style="display: none;">‚Üê Back</button>
                <button class="btn btn-primary" id="next-btn" onclick="nextStep()">Next ‚Üí</button>
                <button class="btn btn-primary" id="create-btn" onclick="createWorld()" style="display: none;">Create World</button>
            </div>

            <div class="back-to-menu">
                <a href="/">‚Üê Return to Main Menu</a>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="spinner"></div>
        <div class="loading-text">Generating your world...</div>
    </div>

    <script>
        // Configuration state
        const config = {
            era: 'bronze_age',
            terrain: 'forest',
            civilization_name: '',
            population_size: 'medium',
            leader_name: '',
            cultural_focus: 'spiritual',
            social_structure: 'egalitarian',
            religion_type: 'animism',
            difficulty: 'balanced',
            neighbor_count: 'few',
            resource_abundance: 'moderate'
        };

        let currentStep = 1;
        const totalSteps = 7;

        // Civilization names for randomization
        const civNamePrefixes = ['The', 'The Ancient', 'The Noble', 'The Free', 'The Proud', 'The Wise'];
        const civNameSuffixes = ['People', 'Tribes', 'Clans', 'Kingdom', 'Confederation', 'Alliance', 'Nation', 'Folk'];
        const civNameMiddle = ['River', 'Mountain', 'Forest', 'Desert', 'Coastal', 'Valley', 'Highland', 'Plains', 'Island', 'Stone', 'Iron', 'Bronze', 'Sun', 'Moon', 'Star', 'Wind'];

        // Leader names for randomization
        const leaderNames = [
            'Anya, the Wise', 'Kael, the Bold', 'Theron, the Just', 'Lyra, the Strong',
            'Darius, the Seer', 'Mira, the Builder', 'Orin, the Diplomat', 'Sera, the Warrior',
            'Aldric, the Keeper', 'Elara, the Guide', 'Bran, the Brave', 'Nyx, the Cunning',
            'Finn, the Scholar', 'Rhea, the Healer', 'Cassius, the Strategist', 'Aria, the Visionary'
        ];

        function selectOption(key, value, element) {
            config[key] = value;

            // Visual feedback - deselect all siblings
            const siblings = element.parentElement.querySelectorAll('.option-card');
            siblings.forEach(card => card.classList.remove('selected'));
            element.classList.add('selected');
        }

        function randomizeCivName() {
            const prefix = civNamePrefixes[Math.floor(Math.random() * civNamePrefixes.length)];
            const middle = civNameMiddle[Math.floor(Math.random() * civNameMiddle.length)];
            const suffix = civNameSuffixes[Math.floor(Math.random() * civNameSuffixes.length)];
            document.getElementById('civilization-name').value = `${prefix} ${middle} ${suffix}`;
        }

        function randomizeLeaderName() {
            const name = leaderNames[Math.floor(Math.random() * leaderNames.length)];
            document.getElementById('leader-name').value = name;
        }

        function updateProgress() {
            const progress = (currentStep / totalSteps) * 100;
            document.getElementById('progress-fill').style.width = progress + '%';
            document.getElementById('progress-text').textContent = `Step ${currentStep} of ${totalSteps}`;
        }

        function showStep(step) {
            document.querySelectorAll('.step').forEach(s => s.classList.remove('active'));
            document.getElementById(`step-${step}`).classList.add('active');

            // Update button visibility
            document.getElementById('back-btn').style.display = step > 1 ? 'block' : 'none';
            document.getElementById('next-btn').style.display = step < totalSteps ? 'block' : 'none';
            document.getElementById('create-btn').style.display = step === totalSteps ? 'block' : 'none';

            // If on review step, populate review content
            if (step === totalSteps) {
                populateReview();
            }
        }

        function nextStep() {
            // Validate current step
            if (currentStep === 3) {
                config.civilization_name = document.getElementById('civilization-name').value.trim();
                if (!config.civilization_name) {
                    showError('Please enter a civilization name');
                    return;
                }
                config.leader_name = document.getElementById('leader-name').value.trim();
            }

            if (currentStep < totalSteps) {
                currentStep++;
                showStep(currentStep);
                updateProgress();
            }
        }

        function previousStep() {
            if (currentStep > 1) {
                currentStep--;
                showStep(currentStep);
                updateProgress();
            }
        }

        function populateReview() {
            const eraNames = {
                'stone_age': 'Stone Age',
                'bronze_age': 'Bronze Age',
                'iron_age': 'Iron Age',
                'classical': 'Classical Era'
            };

            const terrainNames = {
                'coastal': 'Coastal', 'forest': 'Forest', 'mountain': 'Mountain',
                'desert': 'Desert', 'plains': 'Plains', 'river_valley': 'River Valley', 'island': 'Island'
            };

            const focusNames = {
                'martial': 'Martial', 'spiritual': 'Spiritual', 'agricultural': 'Agricultural',
                'mercantile': 'Mercantile', 'scholarly': 'Scholarly', 'artistic': 'Artistic'
            };

            const religionNames = {
                'animism': 'Animism', 'polytheism': 'Polytheism', 'monotheism': 'Monotheism',
                'ancestor_worship': 'Ancestor Worship', 'nature_worship': 'Nature Worship', 'none': 'Secular/No Religion'
            };

            const reviewHTML = `
                <div class="review-section">
                    <h3>Civilization</h3>
                    <p><strong>Name:</strong> ${config.civilization_name}</p>
                    <p><strong>Era:</strong> ${eraNames[config.era]}</p>
                    <p><strong>Population:</strong> ${config.population_size.charAt(0).toUpperCase() + config.population_size.slice(1)}</p>
                    <p><strong>Leader:</strong> ${config.leader_name || 'Random'}</p>
                </div>
                <div class="review-section">
                    <h3>Geography</h3>
                    <p><strong>Terrain:</strong> ${terrainNames[config.terrain]}</p>
                    <p><strong>Resources:</strong> ${config.resource_abundance.charAt(0).toUpperCase() + config.resource_abundance.slice(1)}</p>
                </div>
                <div class="review-section">
                    <h3>Culture & Religion</h3>
                    <p><strong>Focus:</strong> ${focusNames[config.cultural_focus]}</p>
                    <p><strong>Structure:</strong> ${config.social_structure.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())}</p>
                    <p><strong>Religion:</strong> ${religionNames[config.religion_type]}</p>
                </div>
                <div class="review-section">
                    <h3>World Settings</h3>
                    <p><strong>Difficulty:</strong> ${config.difficulty.charAt(0).toUpperCase() + config.difficulty.slice(1)}</p>
                    <p><strong>Neighbors:</strong> ${config.neighbor_count.charAt(0).toUpperCase() + config.neighbor_count.slice(1)}</p>
                </div>
            `;

            document.getElementById('review-content').innerHTML = reviewHTML;
        }

        async function createWorld() {
            // Show loading overlay
            document.getElementById('loading-overlay').classList.add('active');

            try {
                const response = await fetch('/api/custom_game', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(config)
                });

                const data = await response.json();

                if (data.status === 'success') {
                    // World created successfully, redirect to game
                    window.location.href = '/game';
                } else {
                    showError('Failed to create world: ' + (data.message || 'Unknown error'));
                    document.getElementById('loading-overlay').classList.remove('active');
                }
            } catch (error) {
                console.error('Error creating world:', error);
                showError('Failed to create world. Check console for details.');
                document.getElementById('loading-overlay').classList.remove('active');
            }
        }

        function showError(message) {
            const errorEl = document.getElementById('error-message');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
            setTimeout(() => {
                errorEl.style.display = 'none';
            }, 5000);
        }

        // Initialize
        updateProgress();

        // Set initial selections
        document.addEventListener('DOMContentLoaded', () => {
            // Select default options visually
            document.querySelector('[data-value="bronze_age"]').classList.add('selected');
            document.querySelector('[data-value="forest"]').classList.add('selected');
            document.querySelector('[data-value="moderate"]').classList.add('selected');
            // Step 3 defaults will be set when navigating to that step
        });
    </script>
</body>
</html>



################################################################################
# FILE: old_codebase\templates\index.html
# Size: 92573 bytes
################################################################################

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Civilization Simulation</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <style>
    .council-meeting .advisor-reports {
        margin-top: 15px;
    }
    .council-meeting .report {
        margin-bottom: 10px;
        padding-left: 15px;
        border-left: 3px solid #555;
    }
    .faction-audience .petitions-container {
        display: flex;
        justify-content: space-around;
        gap: 20px;
        margin-top: 15px;
    }
    .faction-audience .petition {
        flex: 1;
        padding: 15px;
        border: 1px solid #444;
        border-radius: 5px;
        background-color: #2a2a2a;
    }
    </style>
</head>
<body>
    <!-- Exit to Main Menu Button (Top Right) -->
    <button id="exit-menu-btn" class="exit-menu-btn" onclick="returnToMenu()">üè† Main Menu</button>

    <div id="game-container">
        <!-- LEFT PANEL: Settlement Image & Quick Stats -->
        <div id="left-panel" class="side-panel">
            <div class="panel-header">
                <h2 id="civ-name">Your Settlement</h2>
                <span id="era-badge" class="era-badge">Ancient Era</span>
            </div>

            <div id="leader-profile">
                <h3>Current Leader</h3>
                <div class="leader-info">
                    <div class="leader-name" id="leader-name">Unknown</div>
                    <div class="leader-role" id="leader-role">Chieftain</div>
                    <div class="leader-portrait-overlay">
                        <img id="leader-portrait" src="{{ url_for('static', filename='placeholder.png') }}" alt="Leader Portrait">
                    </div>
                    <div class="leader-stats">
                        <span>Age: <strong id="leader-age">0</strong></span>
                        <span>Ruled: <strong id="years-ruled">0</strong> years</span>
                    </div>
                    <div class="leader-progress">
                        <div class="progress-label">Life Progress</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="leader-life-progress"></div>
                        </div>
                        <div class="progress-text"><span id="leader-age-text">0</span> / <span id="leader-life-exp">0</span></div>
                    </div>
                    <div class="leader-traits" id="leader-traits">
                        <!-- Traits will be added dynamically -->
                    </div>
                </div>
            </div>

            <div id="settlement-image-container">
                <img id="settlement-image" src="{{ url_for('static', filename='placeholder.png') }}" alt="Settlement Image">
                <div class="image-overlay">
                    <span id="year-overlay">Year 0</span>
                </div>
            </div>
        </div>

        <!-- MIDDLE PANEL: Event Log & Interaction (CENTER) -->
        <div id="middle-panel" class="center-panel">
            <!-- Quick Stats Bar -->
            <div id="quick-stats-bar">
                <div class="stat-item">
                    <span class="stat-icon">üë•</span>
                    <div class="stat-content">
                        <div class="stat-label">Population</div>
                        <div class="stat-value" id="population-stat">0</div>
                    </div>
                </div>
                <div class="stat-item">
                    <span class="stat-icon">üåæ</span>
                    <div class="stat-content">
                        <div class="stat-label">Food</div>
                        <div class="stat-value" id="food-stat">0</div>
                    </div>
                </div>
                <div class="stat-item">
                    <span class="stat-icon">üí∞</span>
                    <div class="stat-content">
                        <div class="stat-label">Wealth</div>
                        <div class="stat-value" id="wealth-stat">0</div>
                    </div>
                </div>
                <div class="stat-item">
                    <span class="stat-icon">üìÖ</span>
                    <div class="stat-content">
                        <div class="stat-label">Year</div>
                        <div class="stat-value" id="year-stat">0</div>
                    </div>
                </div>
                <div class="stat-item">
                    <span class="stat-icon">üòä</span>
                    <div class="stat-content">
                        <div class="stat-label">Happiness</div>
                        <div class="stat-value" id="happiness-stat">0%</div>
                    </div>
                </div>
                <div class="stat-item">
                    <span class="stat-icon">üî¨</span>
                    <div class="stat-content">
                        <div class="stat-label">Science</div>
                        <div class="stat-value" id="science-stat">+0</div>
                    </div>
                </div>
                <div class="stat-item">
                    <span class="stat-icon">üé≠</span>
                    <div class="stat-content">
                        <div class="stat-label">Culture</div>
                        <div class="stat-value" id="culture-stat">+0</div>
                    </div>
                </div>
            </div>
            <div id="event-log">
                <!-- Events appear here -->
            </div>
            <div id="interaction-area">
                <div id="action-grid">
                    <!-- Action buttons appear here -->
                </div>
                <div id="player-input-area">
                    <input type="text" id="player-input" placeholder="Or type your own response...">
                    <button id="submit-investigate" class="submit-investigate">Ask/Investigate</button>
                    <button id="submit-decide" class="submit-decide">Make Decision</button>
                </div>
                <button id="continue-btn" class="hidden">Continue</button>
                <div id="game-controls">
                    <button id="timeskip-btn" class="game-control-btn">‚è≠Ô∏è 500-Year Timeskip</button>
                    <button id="abdicate-btn" class="game-control-btn">üëë Abdicate</button>
                </div>
            </div>
        </div>

        <!-- RIGHT PANEL: Civilization Dashboard (Collapsible) -->
        <div id="right-panel" class="collapsed">
            <!-- Toggle Button -->
            <button id="dashboard-toggle" class="dashboard-toggle" aria-label="Toggle Dashboard">
                <span class="toggle-icon">‚óÄ</span>
            </button>

            <!-- Abbreviated Info (Visible when collapsed) -->
            <div class="dashboard-abbreviated">
                <div class="abbreviated-header">
                    <h3>INFO</h3>
                </div>
                <div class="abbreviated-tabs">
                    <button class="tab-icon-btn" data-tab="overview" title="Overview">
                        <span class="tab-emoji">üìä</span>
                    </button>
                    <button class="tab-icon-btn" data-tab="inner-circle" title="Inner Circle">
                        <span class="tab-emoji">üëë</span>
                    </button>
                    <button class="tab-icon-btn" data-tab="culture" title="Culture">
                        <span class="tab-emoji">üé≠</span>
                    </button>
                    <button class="tab-icon-btn" data-tab="religion" title="Religion">
                        <span class="tab-emoji">‚õ™</span>
                    </button>
                    <button class="tab-icon-btn" data-tab="technology" title="Technology">
                        <span class="tab-emoji">üî¨</span>
                    </button>
                    <button class="tab-icon-btn" data-tab="history" title="History">
                        <span class="tab-emoji">üìú</span>
                    </button>
                    <button class="tab-icon-btn" data-tab="factions" title="Factions">
                        <span class="tab-emoji">ü§ù</span>
                    </button>
                </div>
            </div>

            <!-- Full Dashboard Content (Visible when expanded) -->
            <div class="dashboard-full">
                <div class="panel-header">
                    <h2>Civilization Dashboard</h2>
                </div>

            <div class="tab-navigation">
                <button class="tab-btn active" data-tab="overview">üìä Overview</button>
                <button class="tab-btn" data-tab="inner-circle">üëë Inner Circle</button>
                <button class="tab-btn" data-tab="culture">üé≠ Culture</button>
                <button class="tab-btn" data-tab="religion">‚õ™ Religion</button>
                <button class="tab-btn" data-tab="technology">üî¨ Technology</button>
                <button class="tab-btn" data-tab="history">üìú History</button>
                <button class="tab-btn" data-tab="factions">ü§ù Factions</button>
            </div>

            <div class="tab-content-container">
                <!-- OVERVIEW TAB -->
                <div class="tab-content active" id="overview-tab">
                    <div class="overview-grid">
                        <div class="info-card">
                            <h4>üèõÔ∏è Civilization Info</h4>
                            <div class="info-item">
                                <span class="info-label">Name:</span>
                                <span class="info-value" id="overview-civ-name">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Current Year:</span>
                                <span class="info-value" id="overview-year">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Era:</span>
                                <span class="info-value" id="overview-era">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Founded:</span>
                                <span class="info-value" id="overview-founded">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Civilization Age:</span>
                                <span class="info-value" id="overview-age">-</span>
                            </div>
                        </div>

                        <div class="info-card">
                            <h4>üéØ Player Tendency</h4>
                            <div class="tendency-display">
                                <div class="tendency-badge" id="tendency-primary">-</div>
                                <div class="tendency-description" id="tendency-description">Analyzing your decisions...</div>
                            </div>
                        </div>

                        <div class="info-card">
                            <h4>üìú Active Policy</h4>
                            <div class="policy-display">
                                <div class="policy-badge" id="active-policy-badge">General Governance</div>
                                <div class="policy-description" id="active-policy-description">Balanced approach to civilization management</div>
                            </div>
                        </div>

                        <div class="info-card">
                            <h4>üìà Demographics</h4>
                            <div class="info-item">
                                <span class="info-label">Population:</span>
                                <span class="info-value" id="overview-population">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Social Structure:</span>
                                <span class="info-value" id="overview-social">-</span>
                            </div>
                        </div>

                        <div class="info-card">
                            <h4>üíé Resources</h4>
                            <div class="info-item">
                                <span class="info-label">Food Stores:</span>
                                <span class="info-value" id="overview-food">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Wealth:</span>
                                <span class="info-value" id="overview-wealth">-</span>
                            </div>
                            <div class="info-item">
                                <span class="info-label">Tech Tier:</span>
                                <span class="info-value" id="overview-tech-tier">-</span>
                            </div>
                        </div>

                        <div class="info-card full-width">
                            <h4>üëë Inner Circle</h4>
                            <div id="inner-circle-list" class="inner-circle-list">
                                <!-- Inner circle members will be added dynamically -->
                                <span class="empty-state">No trusted advisors yet.</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- INNER CIRCLE TAB -->
                <div class="tab-content" id="inner-circle-tab">
                    <h4>üëë Your Trusted Advisors</h4>
                    <div id="inner-circle-briefs">
                        <!-- Inner circle character briefs will be added dynamically -->
                        <div class="empty-state">No trusted advisors have emerged yet.</div>
                    </div>
                </div>

                <!-- CULTURE TAB -->
                <div class="tab-content" id="culture-tab">
                    <div class="culture-section">
                        <h4>üí´ Core Values</h4>
                        <div class="tag-list" id="culture-values">
                            <!-- Values will be added dynamically -->
                        </div>
                    </div>

                    <div class="culture-section">
                        <h4>üéâ Traditions</h4>
                        <div class="tag-list" id="culture-traditions">
                            <!-- Traditions will be added dynamically -->
                        </div>
                    </div>

                    <div class="culture-section">
                        <h4>üö´ Taboos</h4>
                        <div class="tag-list" id="culture-taboos">
                            <!-- Taboos will be added dynamically -->
                        </div>
                    </div>

                    <div class="culture-section">
                        <h4>üì∞ Recent Cultural Changes</h4>
                        <ul class="change-list" id="culture-changes">
                            <!-- Changes will be added dynamically -->
                        </ul>
                    </div>
                </div>

                <!-- RELIGION TAB -->
                <div class="tab-content" id="religion-tab">
                    <div class="religion-header">
                        <h3 id="religion-name">Unknown Religion</h3>
                        <span class="religion-type" id="religion-type">Type Unknown</span>
                    </div>

                    <div class="religion-section">
                        <h4>‚ú® Primary Deity</h4>
                        <p class="deity-name" id="religion-deity">-</p>
                    </div>

                    <div class="religion-section">
                        <h4>üìñ Core Tenets</h4>
                        <ul class="tenet-list" id="religion-tenets">
                            <!-- Tenets will be added dynamically -->
                        </ul>
                    </div>

                    <div class="religion-section">
                        <h4>üïØÔ∏è Religious Practices</h4>
                        <div class="tag-list" id="religion-practices">
                            <!-- Practices will be added dynamically -->
                        </div>
                    </div>

                    <div class="religion-section">
                        <h4>üèîÔ∏è Holy Sites</h4>
                        <div class="holy-sites-list" id="religion-sites">
                            <!-- Sites will be added dynamically -->
                        </div>
                    </div>

                    <div class="religion-section">
                        <h4>üìä Religious Influence</h4>
                        <div class="influence-indicator">
                            <span class="influence-badge" id="religion-influence">Unknown</span>
                        </div>
                    </div>
                </div>

                <!-- TECHNOLOGY TAB -->
                <div class="tab-content" id="technology-tab">
                    <div class="tech-header">
                        <h4>Current Technological Tier: <span id="tech-tier">Unknown</span></h4>
                    </div>

                    <div class="tech-section">
                        <h4>‚úÖ Discovered Technologies</h4>
                        <div class="tech-grid" id="tech-discoveries">
                            <!-- Discoveries will be added dynamically -->
                        </div>
                    </div>

                    <div class="tech-section" id="tech-in-progress-section">
                        <h4>üîÑ Research In Progress</h4>
                        <div class="tech-grid" id="tech-in-progress">
                            <!-- In-progress tech will be added dynamically -->
                        </div>
                    </div>

                    <div class="tech-section">
                        <h4>üèóÔ∏è Infrastructure</h4>
                        <div class="tech-grid" id="tech-infrastructure">
                            <!-- Infrastructure will be added dynamically -->
                        </div>
                    </div>
                </div>

                <!-- HISTORY TAB -->
                <div class="tab-content" id="history-tab">
                    <h4>üìú Recent Events</h4>
                    <div class="timeline" id="history-timeline">
                        <!-- History events will be added dynamically -->
                    </div>
                </div>

                <!-- FACTIONS TAB -->
                <div class="tab-content" id="factions-tab">
                    <h4>ü§ù Factions & Power Blocs</h4>
                    <div id="faction-cards-container">
                        <!-- Faction cards will be added dynamically -->
                        <div class="empty-state">No organized factions have emerged yet.</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
    // --- Markdown Rendering Utility ---
    function markdownToHTML(text) {
        if (!text) return '';

        // Convert bold: **text** ‚Üí <strong>text</strong>
        text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');

        // Convert italics: *text* ‚Üí <em>text</em> (but not ** that was already processed)
        text = text.replace(/(?<!\*)\*([^*]+?)\*(?!\*)/g, '<em>$1</em>');

        // Convert line breaks: \n ‚Üí <br>
        text = text.replace(/\n/g, '<br>');

        // Convert bullet lists: - item ‚Üí <li>item</li>
        // First, identify lines starting with "- "
        text = text.replace(/^- (.+)$/gm, '<li>$1</li>');
        // Then wrap consecutive <li> tags in <ul>
        text = text.replace(/(<li>.*?<\/li>(?:<br>)?)+/g, match => {
            const items = match.replace(/<br>/g, '');
            return '<ul>' + items + '</ul>';
        });

        return text;
    }

    // --- Global Functions (accessible to inline onclick) ---
    function returnToMenu() {
        if (confirm('Return to main menu? Your progress will be saved.')) {
            window.location.href = '/';
        }
    }

    async function chooseSuccessor(candidate) { // Changed from 'index'
        try {
            const response = await fetch('/api/choose_successor', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ successor: candidate }) // Send the whole object
            });

            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const result = await response.json();

            const legacyHTML = `
                <div class="event-card">
                    <h3>A New Era Begins</h3>
                    <p><strong>${result.new_leader.name}</strong> takes the throne at age ${result.new_leader.age}.</p>
                    <p>Traits: ${result.new_leader.traits.join(', ')}</p>
                    ${result.legacy.narrative ? `<p class="legacy-text">${result.legacy.narrative}</p>` : ''}
                    ${result.legacy.bonuses_applied.length > 0 ? `
                        <div class="legacy-bonuses">
                            <h4>Legacy Bonuses:</h4>
                            <ul>
                                ${result.legacy.bonuses_applied.map(bonus => `<li>${bonus}</li>`).join('')}
                            </ul>
                        </div>
                    ` : ''}
                </div>
            `;

            const eventLog = document.getElementById('event-log');
            eventLog.innerHTML = legacyHTML;

            // Dispatch custom event so the main code can handle UI updates
            window.dispatchEvent(new CustomEvent('successorChosen'));
        } catch (error) {
            console.error("Error choosing successor:", error);
            alert("Failed to choose successor. Please try again.");
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        // --- State ---
        let onContinue = getNewEvent;
        let currentTab = 'overview';
        let previousStats = {
            population: 0,
            food: 0,
            wealth: 0
        };
        let currentEventStage = 0;
        let eventConversationHistory = [];
        let isInvestigating = false;

        // --- Dashboard Change Tracking ---
        let previousDashboardState = {
            culture: { values: [], traditions: [], taboos: [], recent_changes: [] },
            religion: { core_tenets: [], practices: [], holy_sites: [] },
            technology: { discoveries: [], in_progress: [], infrastructure: [] },
            civilization: { population: 0, resources: { food: 0, wealth: 0, tech_tier: '' } }
        };

        // --- Element Selectors ---
        const yearEl = document.getElementById('year-overlay');
        const yearStatEl = document.getElementById('year-stat');
        const populationEl = document.getElementById('population-stat');
        const foodEl = document.getElementById('food-stat');
        const wealthEl = document.getElementById('wealth-stat');
        const leaderNameEl = document.getElementById('leader-name');
        const leaderAgeEl = document.getElementById('leader-age');
        const leaderAgeTextEl = document.getElementById('leader-age-text');
        const leaderLifeExpEl = document.getElementById('leader-life-exp');
        const leaderRoleEl = document.getElementById('leader-role');
        const yearsRuledEl = document.getElementById('years-ruled');
        const leaderLifeProgressEl = document.getElementById('leader-life-progress');
        const leaderTraitsEl = document.getElementById('leader-traits');
        const leaderPortraitEl = document.getElementById('leader-portrait');
        const civNameEl = document.getElementById('civ-name');
        const eraBadgeEl = document.getElementById('era-badge');
        const eventLog = document.getElementById('event-log');
        const playerInput = document.getElementById('player-input');
        const submitInvestigateBtn = document.getElementById('submit-investigate');
        const submitDecideBtn = document.getElementById('submit-decide');
        const continueBtn = document.getElementById('continue-btn');
        const playerInputArea = document.getElementById('player-input-area');
        const actionGrid = document.getElementById('action-grid');
        const settlementImageEl = document.getElementById('settlement-image');
        const timeskipBtn = document.getElementById('timeskip-btn');
        const abdicateBtn = document.getElementById('abdicate-btn');

        // --- Tab Switching ---
        const tabBtns = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');

        tabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const tabName = btn.dataset.tab;
                switchTab(tabName);
            });
        });

        function switchTab(tabName) {
            tabBtns.forEach(btn => btn.classList.remove('active'));
            tabContents.forEach(content => content.classList.remove('active'));

            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            document.getElementById(`${tabName}-tab`).classList.add('active');
            currentTab = tabName;
        }

        // --- Core Functions ---

        function detectChanges(previous, current) {
            const changes = {
                stats: {},
                culture: { values: [], traditions: [], taboos: [] },
                religion: { tenets: [], practices: [], sites: [] },
                technology: { discoveries: [], infrastructure: [] }
            };

            // Detect stat changes
            if (current.civilization.population !== previous.civilization.population) {
                changes.stats.population = current.civilization.population - previous.civilization.population;
            }
            if (current.civilization.resources.food !== previous.civilization.resources.food) {
                changes.stats.food = current.civilization.resources.food - previous.civilization.resources.food;
            }
            if (current.civilization.resources.wealth !== previous.civilization.resources.wealth) {
                changes.stats.wealth = current.civilization.resources.wealth - previous.civilization.resources.wealth;
            }
            if (current.civilization.resources.tech_tier !== previous.civilization.resources.tech_tier) {
                changes.stats.tech_tier = current.civilization.resources.tech_tier;
            }

            // Detect new culture values
            current.culture.values.forEach(val => {
                if (!previous.culture.values.includes(val)) {
                    changes.culture.values.push(val);
                }
            });

            // Detect new traditions
            current.culture.traditions.forEach(trad => {
                if (!previous.culture.traditions.includes(trad)) {
                    changes.culture.traditions.push(trad);
                }
            });

            // Detect new taboos
            current.culture.taboos.forEach(tab => {
                if (!previous.culture.taboos.includes(tab)) {
                    changes.culture.taboos.push(tab);
                }
            });

            // Detect new religious tenets
            current.religion.core_tenets.forEach(tenet => {
                if (!previous.religion.core_tenets.includes(tenet)) {
                    changes.religion.tenets.push(tenet);
                }
            });

            // Detect new practices
            current.religion.practices.forEach(prac => {
                if (!previous.religion.practices.includes(prac)) {
                    changes.religion.practices.push(prac);
                }
            });

            // Detect new holy sites
            current.religion.holy_sites.forEach(site => {
                if (!previous.religion.holy_sites.includes(site)) {
                    changes.religion.sites.push(site);
                }
            });

            // Detect new discoveries
            current.technology.discoveries.forEach(disc => {
                if (!previous.technology.discoveries.includes(disc)) {
                    changes.technology.discoveries.push(disc);
                }
            });

            // Detect new infrastructure
            current.technology.infrastructure.forEach(infra => {
                if (!previous.technology.infrastructure.includes(infra)) {
                    changes.technology.infrastructure.push(infra);
                }
            });

            return changes;
        }

        function highlightChangedElements(changes) {
            // Clear previous highlights
            document.querySelectorAll('.highlight-new, .highlight-changed').forEach(el => {
                el.classList.remove('highlight-new', 'highlight-changed');
            });

            // Highlight new culture values
            changes.culture.values.forEach(value => {
                const tags = document.querySelectorAll('#culture-values .tag');
                tags.forEach(tag => {
                    if (tag.textContent === value) {
                        tag.classList.add('highlight-new');
                    }
                });
            });

            // Highlight new traditions
            changes.culture.traditions.forEach(tradition => {
                const tags = document.querySelectorAll('#culture-traditions .tag');
                tags.forEach(tag => {
                    if (tag.textContent === tradition) {
                        tag.classList.add('highlight-new');
                    }
                });
            });

            // Highlight new taboos
            changes.culture.taboos.forEach(taboo => {
                const tags = document.querySelectorAll('#culture-taboos .tag');
                tags.forEach(tag => {
                    if (tag.textContent === taboo) {
                        tag.classList.add('highlight-new');
                    }
                });
            });

            // Highlight new discoveries
            changes.technology.discoveries.forEach(discovery => {
                const items = document.querySelectorAll('#tech-discoveries .tech-item');
                items.forEach(item => {
                    if (item.textContent.includes(discovery)) {
                        item.classList.add('highlight-new');
                    }
                });
            });

            // Highlight new infrastructure
            changes.technology.infrastructure.forEach(infra => {
                const items = document.querySelectorAll('#tech-infrastructure .tech-item');
                items.forEach(item => {
                    if (item.textContent.includes(infra)) {
                        item.classList.add('highlight-new');
                    }
                });
            });

            // Highlight new religion elements
            changes.religion.practices.forEach(practice => {
                const tags = document.querySelectorAll('#religion-practices .tag');
                tags.forEach(tag => {
                    if (tag.textContent === practice) {
                        tag.classList.add('highlight-new');
                    }
                });
            });

            changes.religion.sites.forEach(site => {
                const sites = document.querySelectorAll('#religion-sites .holy-site');
                sites.forEach(siteEl => {
                    if (siteEl.textContent.includes(site)) {
                        siteEl.classList.add('highlight-new');
                    }
                });
            });

            // Auto-remove highlights after 5 seconds
            setTimeout(() => {
                document.querySelectorAll('.highlight-new, .highlight-changed').forEach(el => {
                    el.classList.add('fade-out');
                    setTimeout(() => {
                        el.classList.remove('highlight-new', 'highlight-changed', 'fade-out');
                    }, 500);
                });
            }, 5000);
        }

        async function updateGameStateUI() {
            try {
                const response = await fetch('/api/game_state');
                const state = await response.json();

                // Update quick stats with animations
                const year = state.civilization.meta.year;
                yearEl.textContent = `Year ${year}`;
                yearStatEl.textContent = year;

                // Animate stat changes
                animateStatChange(populationEl, previousStats.population, state.civilization.population);
                animateStatChange(foodEl, previousStats.food, state.civilization.resources.food);
                animateStatChange(wealthEl, previousStats.wealth, state.civilization.resources.wealth);

                // Update previous stats
                previousStats.population = state.civilization.population;
                previousStats.food = state.civilization.resources.food;
                previousStats.wealth = state.civilization.resources.wealth;

                populationEl.textContent = state.civilization.population.toLocaleString();
                foodEl.textContent = state.civilization.resources.food.toLocaleString();
                wealthEl.textContent = state.civilization.resources.wealth.toLocaleString();

                // Update leader info
                const leader = state.civilization.leader || {};
                leaderNameEl.textContent = leader.name || state.civilization?.leader?.name || 'Unknown';
                leaderRoleEl.textContent = leader.role || 'Leader';
                leaderAgeEl.textContent = leader.age || 0;
                leaderAgeTextEl.textContent = leader.age || 0;
                leaderLifeExpEl.textContent = leader.life_expectancy || 60;
                yearsRuledEl.textContent = leader.years_ruled || 0;

                // Update leader life progress bar
                const lifePercent = ((leader.age || 0) / (leader.life_expectancy || 60)) * 100;
                leaderLifeProgressEl.style.width = `${Math.min(lifePercent, 100)}%`;

                // Update progress bar color based on age
                leaderLifeProgressEl.className = 'progress-fill';
                if (lifePercent > 90) {
                    leaderLifeProgressEl.style.backgroundColor = '#e74c3c'; // Red for very old
                } else if (lifePercent > 70) {
                    leaderLifeProgressEl.style.backgroundColor = '#f39c12'; // Orange for old
                } else {
                    leaderLifeProgressEl.style.backgroundColor = '#3498db'; // Blue for healthy
                }

                // Update leader traits
                leaderTraitsEl.innerHTML = leader.traits.map(trait =>
                    `<span class="trait-badge">${trait}</span>`
                ).join('');

                // Update leader portrait
                const portraitFilename = leader.portrait || 'placeholder.png';
                const portraitPath = portraitFilename.startsWith('leader_')
                    ? `{{ url_for('static', filename='') }}images/leaders/${portraitFilename}`
                    : `{{ url_for('static', filename='') }}${portraitFilename}`;
                leaderPortraitEl.src = `${portraitPath}?v=${new Date().getTime()}`;

                // Update civilization name and era
                civNameEl.textContent = state.civilization.meta.name;
                eraBadgeEl.textContent = state.civilization.meta.era;

                // Update settlement image
                const newSrc = `{{ url_for('static', filename='settlement.png') }}?v=${new Date().getTime()}`;
                settlementImageEl.src = newSrc;

                // Update dashboard
                await updateDashboard();

            } catch (error) {
                console.error("Failed to update game state:", error);
            }
        }

        async function updateDashboard() {
            try {
                const response = await fetch('/api/dashboard');
                const data = await response.json();

                // Detect changes before updating UI
                const changes = detectChanges(previousDashboardState, data);

                // Update Overview Tab
                document.getElementById('overview-civ-name').textContent = data.civilization.name;
                document.getElementById('overview-year').textContent = data.civilization.year;
                document.getElementById('overview-era').textContent = data.civilization.era;
                document.getElementById('overview-founded').textContent = data.civilization.founding_date;
                document.getElementById('overview-age').textContent = `${data.history.age} years`;
                document.getElementById('overview-population').textContent = data.civilization.population.toLocaleString();
                document.getElementById('overview-social').textContent = data.culture.social_structure;
                document.getElementById('overview-food').textContent = data.civilization.resources.food.toLocaleString();
                document.getElementById('overview-wealth').textContent = data.civilization.resources.wealth.toLocaleString();
                document.getElementById('overview-tech-tier').textContent = data.civilization.resources.tech_tier.replace('_', ' ');

                // Update Inner Circle - Simplified version for Overview tab
                const innerCircleContainer = document.getElementById('inner-circle-list');
                if (data.inner_circle && data.inner_circle.length > 0) {
                    innerCircleContainer.innerHTML = `
                        <div class="inner-circle-summary">
                            ${data.inner_circle.map(char => `<span class="member-name-tag">${char.name}</span>`).join('')}
                        </div>
                        <p class="inner-circle-hint">View full details in the üëë Inner Circle tab</p>
                    `;
                } else {
                    innerCircleContainer.innerHTML = '<span class="empty-state">No trusted advisors yet.</span>';
                }

                // Update Inner Circle Tab - Detailed briefs
                const innerCircleBriefs = document.getElementById('inner-circle-briefs');
                if (data.inner_circle && data.inner_circle.length > 0) {
                    innerCircleBriefs.innerHTML = data.inner_circle.map(char => {
                        // Calculate metric percentages - handle both direct metrics and nested metrics object
                        const metrics = char.metrics || {};
                        const loyaltyPercent = Math.min(Math.max(char.loyalty || metrics.loyalty || 50, 0), 100);
                        const influencePercent = Math.min(Math.max(char.influence || metrics.influence || 50, 0), 100);
                        const relationshipPercent = Math.min(Math.max(char.relationship || metrics.relationship || 50, 0), 100);

                        // Get color based on value
                        const getBarColor = (value) => {
                            if (value >= 70) return '#2ecc71';
                            if (value >= 40) return '#f39c12';
                            return '#e74c3c';
                        };

                        // Get most recent history entry
                        const recentHistory = char.history && char.history.length > 0
                            ? char.history[char.history.length - 1]
                            : null;

                        // Get portrait path (check if exists, fallback to placeholder)
                        const portraitPath = char.portrait && char.portrait !== 'placeholder.png'
                            ? `{{ url_for('static', filename='') }}images/advisors/${char.portrait}`
                            : `{{ url_for('static', filename='placeholder.png') }}`;

                        return `
                            <div class="inner-circle-brief">
                                <div class="brief-header">
                                    <div class="brief-name-section">
                                        <h4 class="brief-name">${char.name}</h4>
                                        <span class="brief-role">${char.role}</span>
                                    </div>
                                    <img src="${portraitPath}?v=${new Date().getTime()}" alt="${char.name}" class="advisor-portrait-thumbnail" onerror="this.src='{{ url_for('static', filename='placeholder.png') }}';">
                                    ${char.faction_link ? `<span class="brief-faction">ü§ù ${char.faction_link}</span>` : ''}
                                </div>

                                <div class="brief-metrics">
                                    <div class="metric-row">
                                        <span class="metric-label">Loyalty</span>
                                        <div class="metric-bar-container">
                                            <div class="metric-bar" style="width: ${loyaltyPercent}%; background-color: ${getBarColor(loyaltyPercent)};"></div>
                                        </div>
                                        <span class="metric-value">${loyaltyPercent}</span>
                                    </div>
                                    <div class="metric-row">
                                        <span class="metric-label">Influence</span>
                                        <div class="metric-bar-container">
                                            <div class="metric-bar" style="width: ${influencePercent}%; background-color: ${getBarColor(influencePercent)};"></div>
                                        </div>
                                        <span class="metric-value">${influencePercent}</span>
                                    </div>
                                    <div class="metric-row">
                                        <span class="metric-label">Relationship</span>
                                        <div class="metric-bar-container">
                                            <div class="metric-bar" style="width: ${relationshipPercent}%; background-color: ${getBarColor(relationshipPercent)};"></div>
                                        </div>
                                        <span class="metric-value">${relationshipPercent}</span>
                                    </div>
                                </div>

                                ${recentHistory ? `
                                    <div class="brief-history">
                                        <div class="history-label">Recent Activity:</div>
                                        <div class="history-text">${recentHistory}</div>
                                    </div>
                                ` : ''}

                                <button class="audience-btn" data-character-name="${char.name}">
                                    üí¨ Request Audience
                                </button>
                            </div>
                        `;
                    }).join('');
                } else {
                    innerCircleBriefs.innerHTML = '<div class="empty-state">No trusted advisors have emerged yet.</div>';
                }


                // Update Player Tendency
                if (data.player_tendency) {
                    const tendencyBadge = document.getElementById('tendency-primary');
                    const tendencyDesc = document.getElementById('tendency-description');
                    tendencyBadge.textContent = data.player_tendency.primary.toUpperCase();
                    tendencyBadge.className = `tendency-badge tendency-${data.player_tendency.primary}`;
                    tendencyDesc.textContent = data.player_tendency.description;
                }

                // Update Active Policy
                if (data.active_policy) {
                    const policyDescriptions = {
                        'military_expansion': 'Focus on building a strong military and expanding through conquest',
                        'economic_growth': 'Prioritize trade, wealth generation, and economic prosperity',
                        'religious_devotion': 'Strengthen faith, build temples, and honor the divine',
                        'scientific_advancement': 'Pursue knowledge, research, and technological progress',
                        'cultural_development': 'Foster arts, traditions, and cultural identity',
                        'territorial_expansion': 'Expand borders and establish new settlements',
                        'exploration': 'Discover new lands and uncover mysteries',
                        'general_governance': 'Balanced approach to civilization management'
                    };

                    const policyBadge = document.getElementById('active-policy-badge');
                    const policyDesc = document.getElementById('active-policy-description');
                    const policyDisplay = data.active_policy.replace(/_/g, ' ');

                    policyBadge.textContent = policyDisplay.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
                    policyBadge.className = `policy-badge policy-${data.active_policy}`;
                    policyDesc.textContent = policyDescriptions[data.active_policy] || 'No active policy set';
                }

                // Update Culture Tab
                const valuesContainer = document.getElementById('culture-values');
                valuesContainer.innerHTML = data.culture.values.map(v =>
                    `<span class="tag tag-value">${v}</span>`
                ).join('');

                const traditionsContainer = document.getElementById('culture-traditions');
                traditionsContainer.innerHTML = data.culture.traditions.map(t =>
                    `<span class="tag tag-tradition">${t}</span>`
                ).join('');

                const taboosContainer = document.getElementById('culture-taboos');
                taboosContainer.innerHTML = data.culture.taboos.length > 0
                    ? data.culture.taboos.map(t => `<span class="tag tag-taboo">${t}</span>`).join('')
                    : '<span class="empty-state">No taboos established</span>';

                const changesContainer = document.getElementById('culture-changes');
                changesContainer.innerHTML = data.culture.recent_changes.length > 0
                    ? data.culture.recent_changes.map(c => `<li>${c}</li>`).join('')
                    : '<li class="empty-state">No recent changes</li>';

                // Update Religion Tab
                document.getElementById('religion-name').textContent = data.religion.name;
                document.getElementById('religion-type').textContent = data.religion.type;
                document.getElementById('religion-deity').textContent = data.religion.primary_deity;

                const tenetsContainer = document.getElementById('religion-tenets');
                tenetsContainer.innerHTML = data.religion.core_tenets.map(t =>
                    `<li>${t}</li>`
                ).join('');

                const practicesContainer = document.getElementById('religion-practices');
                practicesContainer.innerHTML = data.religion.practices.map(p =>
                    `<span class="tag tag-practice">${p}</span>`
                ).join('');

                const sitesContainer = document.getElementById('religion-sites');
                sitesContainer.innerHTML = data.religion.holy_sites.length > 0
                    ? data.religion.holy_sites.map(s => `<div class="holy-site">‚õ∞Ô∏è ${s}</div>`).join('')
                    : '<span class="empty-state">No holy sites established</span>';

                document.getElementById('religion-influence').textContent = data.religion.influence;
                document.getElementById('religion-influence').className = `influence-badge influence-${data.religion.influence}`;

                // Update Technology Tab
                document.getElementById('tech-tier').textContent = data.technology.current_tier.replace('_', ' ');

                const discoveriesContainer = document.getElementById('tech-discoveries');
                discoveriesContainer.innerHTML = data.technology.discoveries.map(d =>
                    `<div class="tech-item tech-discovered">‚úÖ ${d}</div>`
                ).join('');

                const inProgressContainer = document.getElementById('tech-in-progress');
                const inProgressSection = document.getElementById('tech-in-progress-section');
                if (data.technology.in_progress.length > 0) {
                    inProgressSection.style.display = 'block';
                    inProgressContainer.innerHTML = data.technology.in_progress.map(t =>
                        `<div class="tech-item tech-progress">üîÑ ${t}</div>`
                    ).join('');
                } else {
                    inProgressSection.style.display = 'none';
                }

                const infrastructureContainer = document.getElementById('tech-infrastructure');
                infrastructureContainer.innerHTML = data.technology.infrastructure.map(i =>
                    `<div class="tech-item tech-infrastructure">üèóÔ∏è ${i}</div>`
                ).join('');

                // Update History Tab
                const timelineContainer = document.getElementById('history-timeline');
                if (data.history.recent_events.length > 0) {
                    timelineContainer.innerHTML = data.history.recent_events.map(event => `
                        <div class="timeline-event">
                            <div class="timeline-year">${event.year || 'Unknown'}</div>
                            <div class="timeline-content">
                                <strong>${event.title || 'Event'}</strong>
                                <p>${event.description || event.narrative || ''}</p>
                            </div>
                        </div>
                    `).join('');
                } else {
                    timelineContainer.innerHTML = '<div class="empty-state">No recorded history yet. Your story begins now...</div>';
                }

                // Update Factions Tab - Redesigned with detailed cards
                const factionsContainer = document.getElementById('faction-cards-container');
                if (data.factions && data.factions.length > 0) {
                    // Helper to format faction bonuses
                    const getFactionEffects = (factionId, bonuses) => {
                        const effects = [];

                        // Check if this faction has active effects based on its ID
                        if (factionId.includes('merchant') && bonuses.wealth_multiplier) {
                            const percent = ((bonuses.wealth_multiplier - 1.0) * 100).toFixed(0);
                            if (percent > 0) {
                                effects.push(`üí∞ +${percent}% Wealth Generation`);
                            } else if (percent < 0) {
                                effects.push(`üí∞ ${percent}% Wealth Generation`);
                            }
                        }

                        if ((factionId.includes('warrior') || factionId.includes('military')) && bonuses.military_effectiveness) {
                            const percent = ((bonuses.military_effectiveness - 1.0) * 100).toFixed(0);
                            if (percent > 0) {
                                effects.push(`‚öîÔ∏è +${percent}% Military Effectiveness`);
                            } else if (percent < 0) {
                                effects.push(`‚öîÔ∏è ${percent}% Military Effectiveness`);
                            }
                        }

                        if ((factionId.includes('priest') || factionId.includes('religious')) && bonuses.happiness_modifier) {
                            const value = bonuses.happiness_modifier;
                            if (value > 0) {
                                effects.push(`üòä +${value} Happiness`);
                            } else if (value < 0) {
                                effects.push(`üòä ${value} Happiness`);
                            }
                        }

                        return effects;
                    };

                    factionsContainer.innerHTML = data.factions.map(f => {
                        const approval = f.approval || 50;
                        const approvalColor = approval < 30 ? '#e74c3c' : approval < 70 ? '#f39c12' : '#2ecc71';
                        const approvalStatus = approval >= 75 ? 'Loyal' : approval >= 50 ? 'Pleased' : approval >= 25 ? 'Discontent' : 'Hostile';

                        // Get faction effects
                        const effects = getFactionEffects(f.id || '', data.faction_bonuses || {});
                        const effectsHTML = effects.length > 0
                            ? `<div class="faction-effects">
                                   <div class="effects-label">Active Effects:</div>
                                   ${effects.map(effect => `<div class="effect-item">${effect}</div>`).join('')}
                               </div>`
                            : '<div class="faction-effects"><div class="effect-item no-effect">No active bonuses or penalties</div></div>';

                        // Get history
                        const history = f.history || [];
                        const historyHTML = history.length > 0
                            ? `<div class="faction-history">
                                   <div class="history-label">Recent History:</div>
                                   <div class="history-list">
                                       ${history.slice(-5).reverse().map(entry =>
                                           `<div class="history-entry">${entry}</div>`
                                       ).join('')}
                                   </div>
                               </div>`
                            : '<div class="faction-history"><div class="history-entry">No recorded history yet</div></div>';

                        return `
                            <div class="faction-card">
                                <div class="faction-card-header">
                                    <div class="faction-name-section">
                                        <h5 class="faction-name">${f.name}</h5>
                                        <span class="faction-leader">Led by ${f.leader}</span>
                                    </div>
                                    <span class="faction-status" style="background-color: ${approvalColor};">${approvalStatus}</span>
                                </div>

                                <div class="faction-metrics">
                                    <div class="metric-group">
                                        <div class="metric-label-row">
                                            <span>Approval</span>
                                            <span class="metric-value-text">${approval}%</span>
                                        </div>
                                        <div class="approval-bar-container">
                                            <div class="approval-bar-fill" style="width: ${approval}%; background-color: ${approvalColor};"></div>
                                        </div>
                                    </div>
                                    <div class="metric-group">
                                        <div class="metric-label-row">
                                            <span>Population Support</span>
                                            <span class="metric-value-text">${f.support_percentage}%</span>
                                        </div>
                                    </div>
                                </div>

                                ${effectsHTML}
                                ${historyHTML}
                            </div>
                        `;
                    }).join('');
                } else {
                    factionsContainer.innerHTML = '<div class="empty-state">No organized factions have emerged yet.</div>';
                }

                // Update new stats in quick-stats-bar
                // Happiness (as percentage)
                const happinessEl = document.getElementById('happiness-stat');
                if (happinessEl && data.population_happiness !== undefined) {
                    happinessEl.textContent = `${data.population_happiness}%`;
                }

                // Science (as signed integer rate)
                const scienceEl = document.getElementById('science-stat');
                if (scienceEl && data.active_bonuses && data.active_bonuses.science_per_turn) {
                    const scienceRate = data.active_bonuses.science_per_turn.total || 0;
                    scienceEl.textContent = scienceRate >= 0 ? `+${scienceRate}` : `${scienceRate}`;
                }

                // Culture (as signed integer rate)
                const cultureEl = document.getElementById('culture-stat');
                if (cultureEl && data.active_bonuses && data.active_bonuses.culture_per_turn) {
                    const cultureRate = data.active_bonuses.culture_per_turn.total || 0;
                    cultureEl.textContent = cultureRate >= 0 ? `+${cultureRate}` : `${cultureRate}`;
                }

                // Abbreviated dashboard no longer needs updates (static tab icons)

                // Apply highlights to changed elements
                highlightChangedElements(changes);

                // Update previous state for next comparison
                previousDashboardState = {
                    culture: {
                        values: [...data.culture.values],
                        traditions: [...data.culture.traditions],
                        taboos: [...data.culture.taboos],
                        recent_changes: [...data.culture.recent_changes]
                    },
                    religion: {
                        core_tenets: [...data.religion.core_tenets],
                        practices: [...data.religion.practices],
                        holy_sites: [...data.religion.holy_sites]
                    },
                    technology: {
                        discoveries: [...data.technology.discoveries],
                        in_progress: [...data.technology.in_progress],
                        infrastructure: [...data.technology.infrastructure]
                    },
                    civilization: {
                        population: data.civilization.population,
                        resources: {
                            food: data.civilization.resources.food,
                            wealth: data.civilization.resources.wealth,
                            tech_tier: data.civilization.resources.tech_tier
                        }
                    }
                };

            } catch (error) {
                console.error("Failed to update dashboard:", error);
            }
        }

        function showActionUI() {
            actionGrid.classList.remove('hidden');
            playerInputArea.classList.remove('hidden');
            document.getElementById('game-controls').classList.remove('hidden');
            continueBtn.classList.add('hidden');
            playerInput.placeholder = "Or type your own response...";
            playerInput.focus();
        }

        function showContinueUI(continueText = "Continue to Next Event", nextAction = getNewEvent) {
            actionGrid.innerHTML = '';
            actionGrid.classList.add('hidden');
            playerInputArea.classList.add('hidden');
            document.getElementById('game-controls').classList.add('hidden');

            continueBtn.textContent = continueText;
            onContinue = nextAction;

            continueBtn.classList.remove('hidden');
            continueBtn.focus();
        }

        function displayEvent(event) {
            // Validate event structure
            if (!event || typeof event !== 'object') {
                console.error('Invalid event object:', event);
                eventLog.innerHTML = '<p class="error">‚ö†Ô∏è Error: Invalid event data received. Please try again.</p>';
                showContinueUI("Try Again", getNewEvent);
                return;
            }

            // Ensure required fields exist
            if (!event.title || !event.narrative) {
                console.error('Event missing required fields (title/narrative):', event);
                eventLog.innerHTML = '<p class="error">‚ö†Ô∏è Error: Event is missing essential information. Please try again.</p>';
                showContinueUI("Try Again", getNewEvent);
                return;
            }

            // Validate and fix options arrays
            if (!Array.isArray(event.investigation_options)) {
                console.warn('investigation_options is not an array, fixing:', event.investigation_options);
                event.investigation_options = [];
            }

            if (!Array.isArray(event.decision_options)) {
                console.warn('decision_options is not an array, fixing:', event.decision_options);
                event.decision_options = [];
            }

            // Ensure we have at least some options
            if (event.investigation_options.length === 0 && event.decision_options.length === 0) {
                console.error('Event has no options:', event);
                // Add fallback options
                event.investigation_options = ['Ask for more information', 'Consult with advisors'];
                event.decision_options = ['Proceed cautiously', 'Act decisively'];
            }

            // Escape HTML entities for data attributes
            const escapeHtml = (text) => {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            };

            // Reset event state
            currentEventStage = 0;
            eventConversationHistory = [];
            isInvestigating = false;


            // Check if this is a crisis event
            const isCrisis = event.is_crisis || false;
            const crisisClass = isCrisis ? 'crisis-event' : '';
            const crisisBadge = isCrisis ? `<span class="crisis-badge">‚ö†Ô∏è CRISIS</span>` : '';

            // Add crisis visual if available
            let crisisVisual = '';
            if (isCrisis && event.crisis_image) {
                const crisisImagePath = event.crisis_image.startsWith('crisis_')
                    ? `{{ url_for('static', filename='') }}images/crises/${event.crisis_image}`
                    : `{{ url_for('static', filename='') }}${event.crisis_image}`;
                crisisVisual = `
                    <div class="crisis-visual">
                        <img src="${crisisImagePath}?v=${new Date().getTime()}" alt="Crisis">
                    </div>
                `;
            }

            // Add advisor portrait if this is a character vignette
            let advisorPortrait = '';
            if (event.event_type === 'character_vignette' && event.character_name) {
                // Find the character in inner_circle to get their portrait
                const character = previousDashboardState?.inner_circle?.find(c => c.name === event.character_name);
                if (character && character.portrait && character.portrait !== 'placeholder.png') {
                    const portraitPath = `{{ url_for('static', filename='') }}images/advisors/${character.portrait}`;
                    advisorPortrait = `
                        <div class="advisor-portrait-display">
                            <img src="${portraitPath}" alt="${event.character_name}" class="advisor-portrait-large" onerror="this.style.display='none';">
                        </div>
                    `;
                }
            }

            const stageIndicator = `<div class="stage-indicator">Stage ${currentEventStage + 1} - Initial Situation</div>`;
            const progressBar = `
                <div class="event-progress">
                    <div class="progress-dots">
                        <span class="dot active"></span>
                        <span class="dot"></span>
                        <span class="dot"></span>
                        <span class="dot"></span>
                        <span class="dot"></span>
                    </div>
                    <div class="progress-label">Investigation Depth</div>
                </div>
            `;
            const eventHTML = `
                <div class="event-card ${crisisClass}" data-event-title="${escapeHtml(event.title)}" data-event-narrative="${escapeHtml(event.narrative)}">
                    ${crisisVisual}
                    <h3>${event.title} ${crisisBadge}</h3>
                    <div class="event-header-meta">
                        ${stageIndicator}
                        ${progressBar}
                    </div>
                    ${advisorPortrait}
                    <p>${markdownToHTML(event.narrative)}</p>
                    <div class="conversation-history"></div>
                </div>
            `;
            eventLog.innerHTML = eventHTML;

            renderActionButtons(
                event.investigation_options || [],
                event.decision_options || []
            );
            showActionUI();
        }

        function renderActionButtons(investigationOptions, decisionOptions) {
            actionGrid.innerHTML = '';

            // Ensure we have arrays and sanitize input
            const investigations = Array.isArray(investigationOptions) ? investigationOptions : [];
            const decisions = Array.isArray(decisionOptions) ? decisionOptions : [];

            // Helper function to validate and sanitize action text
            const sanitizeActionText = (text, index, type) => {
                if (typeof text === 'string' && text.trim().length > 0) {
                    return text.trim();
                }

                // Handle non-string or invalid types
                console.warn(`Invalid ${type} option at index ${index}:`, text);

                // Try to extract text from object
                if (text && typeof text === 'object') {
                    if (text.text) return String(text.text);
                    if (text.action) return String(text.action);
                    if (text.description) return String(text.description);
                }

                // Last resort: return fallback text
                return `${type === 'investigation' ? 'Investigate' : 'Decide'} Option ${index + 1}`;
            };

            // Top row: 2 investigation buttons
            investigations.slice(0, 2).forEach((rawText, index) => {
                const actionText = sanitizeActionText(rawText, index, 'investigation');

                const button = document.createElement('button');
                button.innerHTML = `<span class="btn-icon">?</span> ${actionText}`;
                button.className = 'action-btn action-investigate';
                button.dataset.action = actionText;
                button.dataset.isFinal = 'false';

                button.onclick = function(e) {
                    e.preventDefault();
                    document.querySelectorAll('.action-btn').forEach(btn => btn.classList.remove('selected'));
                    this.classList.add('selected');
                    playerInput.value = actionText;
                    handleEventInteraction(actionText);
                };
                actionGrid.appendChild(button);
            });

            // Bottom row: 2 decision buttons
            decisions.slice(0, 2).forEach((rawText, index) => {
                const actionText = sanitizeActionText(rawText, index, 'decision');

                const button = document.createElement('button');
                button.innerHTML = `<span class="btn-icon">‚ö°</span> ${actionText}`;
                button.className = 'action-btn action-decision';
                button.dataset.action = actionText;
                button.dataset.isFinal = 'true';

                button.onclick = function(e) {
                    e.preventDefault();
                    document.querySelectorAll('.action-btn').forEach(btn => btn.classList.remove('selected'));
                    this.classList.add('selected');
                    playerInput.value = actionText;
                    handlePlayerAction();
                };
                actionGrid.appendChild(button);
            });
        }

        function displayOutcome(playerAction, outcome) {
            // Build impact summary from changes
            let impactHTML = '';
            const changes = [];

            // Check for stat changes in the outcome
            if (outcome.updates) {
                Object.keys(outcome.updates).forEach(key => {
                    const value = outcome.updates[key];

                    if (key.includes('population')) {
                        changes.push(`Population ${value > 0 ? '+' : ''}${value}`);
                    } else if (key.includes('food')) {
                        changes.push(`Food ${value > 0 ? '+' : ''}${value}`);
                    } else if (key.includes('wealth')) {
                        changes.push(`Wealth ${value > 0 ? '+' : ''}${value}`);
                    } else if (key.includes('.append')) {
                        const category = key.split('.')[1];
                        if (category === 'discoveries') {
                            changes.push(`New Discovery: ${value}`);
                        } else if (category === 'traditions') {
                            changes.push(`New Tradition: ${value}`);
                        } else if (category === 'infrastructure') {
                            changes.push(`New Infrastructure: ${value}`);
                        } else if (category === 'values') {
                            changes.push(`New Value: ${value}`);
                        }
                    }
                });
            }

            // Add resource warnings
            let warningsHTML = '';
            if (outcome.resource_warnings && outcome.resource_warnings.length > 0) {
                const warningMessages = {
                    'FAMINE_CRITICAL': '‚ò†Ô∏è CRITICAL FAMINE - People are starving!',
                    'FAMINE_WARNING': '‚ö†Ô∏è Food shortage approaching',
                    'FOOD_LOW': 'üåæ Food supplies running low',
                    'BANKRUPTCY': 'üí∏ BANKRUPTCY - Infrastructure collapsing!',
                    'WEALTH_LOW': 'üí∞ Wealth reserves depleted'
                };

                const warnings = outcome.resource_warnings.map(w =>
                    `<div class="resource-warning warning-${w.toLowerCase()}">${warningMessages[w] || w}</div>`
                ).join('');

                warningsHTML = `<div class="resource-warnings">${warnings}</div>`;
            }

            // Add consumption effects
            if (outcome.consumption_effects) {
                if (outcome.consumption_effects.population_loss) {
                    changes.push(`‚ò†Ô∏è Deaths from starvation: -${outcome.consumption_effects.population_loss}`);
                }
                if (outcome.consumption_effects.infrastructure_lost) {
                    outcome.consumption_effects.infrastructure_lost.forEach(infra => {
                        changes.push(`üèöÔ∏è Lost: ${infra}`);
                    });
                }
            }

            if (changes.length > 0) {
                impactHTML = `
                    <div class="impact-summary">
                        <h4>üìä Impact</h4>
                        <div class="impact-items">
                            ${changes.map(change => `<span class="impact-tag">${change}</span>`).join('')}
                        </div>
                    </div>
                `;
            }

            const outcomeHTML = `
                <div class="player-action">
                    <strong>&gt; ${playerAction}</strong>
                </div>
                <div class="outcome-narrative">
                    <p>${markdownToHTML(outcome.narrative)}</p>
                </div>
                ${warningsHTML}
                ${impactHTML}
            `;
            const eventCard = eventLog.querySelector('.event-card');
            if(eventCard) eventCard.innerHTML += outcomeHTML;
            showContinueUI("Continue to Next Event", getNewEvent);
        }

        async function handleEventInteraction(playerResponse) {
            if (!playerResponse.trim()) {
                alert('Please select an action or type your response.');
                return;
            }

            isInvestigating = true;
            const eventCard = eventLog.querySelector('.event-card');
            const conversationHistoryEl = eventCard.querySelector('.conversation-history');

            // Show loading state
            const loadingEl = document.createElement('div');
            loadingEl.className = 'loading-indicator';
            loadingEl.innerHTML = '<p><em>Investigating...</em></p>';
            conversationHistoryEl.appendChild(loadingEl);

            // Disable inputs
            document.querySelectorAll('#interaction-area button').forEach(b => b.disabled = true);
            playerInput.disabled = true;

            try {
                const response = await fetch('/api/event_interaction', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ response: playerResponse })
                });

                if (!response.ok) {
                    throw new Error(`Server error: ${response.status}`);
                }

                const result = await response.json();

                if (result.status === 'error') {
                    alert(`Error: ${result.message}`);
                    loadingEl.remove();
                    return;
                }

                // Remove loading indicator
                loadingEl.remove();

                // Update stage
                currentEventStage = result.stage;

                // Update progress dots
                const progressDots = eventCard.querySelectorAll('.progress-dots .dot');
                progressDots.forEach((dot, index) => {
                    if (index <= currentEventStage) {
                        dot.classList.add('active');
                    }
                });

                // Add conversation exchange
                const exchangeHTML = `
                    <div class="conversation-exchange">
                        <div class="player-query"><strong>&gt; ${playerResponse}</strong></div>
                        <div class="ai-response">${markdownToHTML(result.response.narrative)}</div>
                    </div>
                `;
                conversationHistoryEl.insertAdjacentHTML('beforeend', exchangeHTML);

                // Update stage indicator
                const stageIndicator = eventCard.querySelector('.stage-indicator');
                if (stageIndicator) {
                    stageIndicator.textContent = `Stage ${currentEventStage + 1} - Investigation`;
                }

                // Render new 2x2 button grid
                renderActionButtons(
                    result.response.investigation_options || [],
                    result.response.decision_options || []
                );

                // Clear input
                playerInput.value = '';

            } catch (error) {
                console.error("Error in event interaction:", error);
                alert(`Failed to process interaction: ${error.message}`);
                loadingEl.remove();
            } finally {
                document.querySelectorAll('#interaction-area button').forEach(b => b.disabled = false);
                playerInput.disabled = false;
                isInvestigating = false;
            }
        }

        async function getNewEvent() {
            try {
                eventLog.innerHTML = "<p><em>The spirits are whispering a new story...</em></p>";
                const response = await fetch('/api/event');
                const event = await response.json();

                // Check for game over
                if (event.game_over) {
                    displayGameOver(event);
                    return;
                }

                displayEvent(event);
            } catch (error) {
                console.error("Failed to fetch new event:", error);
                eventLog.innerHTML = "<p class='error'>Failed to receive a story from the spirits. Check the console.</p>";
            }
        }

        function displayGameOver(gameOverData) {
            const isVictory = gameOverData.outcome === 'victory';
            const outcomeClass = isVictory ? 'victory' : 'defeat';
            const outcomeIcon = isVictory ? 'üèÜ' : 'üíÄ';

            const gameOverHTML = `
                <div class="game-over-card ${outcomeClass}">
                    <div class="game-over-icon">${outcomeIcon}</div>
                    <h2>${gameOverData.title}</h2>
                    <p class="game-over-narrative">${markdownToHTML(gameOverData.narrative)}</p>
                    <div class="game-over-actions">
                        <button onclick="returnToMenu()" class="game-over-btn">Return to Menu</button>
                    </div>
                </div>
            `;

            eventLog.innerHTML = gameOverHTML;

            // Hide interaction controls
            actionGrid.classList.add('hidden');
            playerInputArea.classList.add('hidden');
            document.getElementById('game-controls').classList.add('hidden');
            continueBtn.classList.add('hidden');
        }

        async function handlePlayerAction() {
            const actionText = playerInput.value.trim();
            if (!actionText) {
                alert('Please select an action or type your response.');
                return;
            }

            const currentEventCard = eventLog.querySelector('.event-card');
            if (!currentEventCard) {
                console.error('No event card found');
                return;
            }

            const eventTitle = currentEventCard.dataset.eventTitle;
            const eventNarrative = currentEventCard.dataset.eventNarrative;

            // Show loading state
            const originalContent = eventLog.innerHTML;
            eventLog.innerHTML += '<div class="loading-indicator"><p><em>Processing your decision...</em></p></div>';

            document.querySelectorAll('#interaction-area button').forEach(b => b.disabled = true);
            playerInput.disabled = true;

            try {
                const response = await fetch('/api/action', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: actionText, event_title: eventTitle, event_narrative: eventNarrative }),
                });

                if (!response.ok) {
                    throw new Error(`Server error: ${response.status}`);
                }

                const result = await response.json();

                if (result.status === 'error') {
                    alert(`Error: ${result.message || 'Failed to process action'}`);
                    eventLog.innerHTML = originalContent;
                    return;
                }

                // Remove loading indicator
                const loadingIndicator = eventLog.querySelector('.loading-indicator');
                if (loadingIndicator) loadingIndicator.remove();

                displayOutcome(actionText, result.outcome);
                await updateGameStateUI();
            } catch (error) {
                console.error("Error submitting action:", error);
                alert(`Failed to process your action: ${error.message}. Please try again.`);
                eventLog.innerHTML = originalContent;
            } finally {
                document.querySelectorAll('#interaction-area button').forEach(b => b.disabled = false);
                playerInput.value = '';
                playerInput.disabled = false;
            }
        }

        async function handleTimeskip() {
            eventLog.innerHTML = "<p><em>The years begin to flow, seasons turn to decades, decades to centuries...</em></p>";
            document.querySelectorAll('#interaction-area button').forEach(b => b.disabled = true);
            playerInput.disabled = true;

            try {
                const response = await fetch('/api/timeskip', { method: 'POST' });
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const result = await response.json();

                const timeskipHTML = `
                    <div class="event-card">
                        <h3>An Era Passes</h3>
                        <p>${markdownToHTML(result.narrative)}</p>
                    </div>
                `;
                eventLog.innerHTML = timeskipHTML;
                await updateGameStateUI();
                showContinueUI("Begin the New Era", getNewEvent);
            } catch (error) {
                console.error("Error during timeskip:", error);
                eventLog.innerHTML = "<p class='error'>Time stands still. The timeskip failed. Check the console.</p>";
                showContinueUI("Try Again", getNewEvent);
            } finally {
                 document.querySelectorAll('#interaction-area button').forEach(b => b.disabled = false);
                 playerInput.disabled = false;
            }
        }

        async function handleAbdication() {
            try {
                const response = await fetch('/api/die', { method: 'POST' });
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const result = await response.json();

                if (result.requires_choice && result.candidates) {
                    displaySuccessorChoice(result.summary, result.candidates);
                } else {
                    // Fallback to old behavior
                    const summaryHTML = `
                        <div class="event-card">
                            <h3>A Leader's End</h3>
                            <p>${result.summary}</p>
                        </div>
                    `;
                    eventLog.innerHTML = summaryHTML;
                    showContinueUI("Start the Next Generation's Story", handleTimeskip);
                }
            } catch (error) {
                console.error("Error during abdication:", error);
            }
        }

        function displaySuccessorChoice(summary, candidates) {
            const candidatesHTML = candidates.map((candidate, index) => {
                const portraitFilename = candidate.portrait || 'placeholder.png';
                const portraitPath = portraitFilename.startsWith('leader_')
                    ? `{{ url_for('static', filename='') }}images/leaders/${portraitFilename}`
                    : `{{ url_for('static', filename='') }}${portraitFilename}`;

                return `
                <div class="successor-card" onclick='chooseSuccessor(${JSON.stringify(candidate)})'>
                    <div class="successor-portrait">
                        <img src="${portraitPath}?v=${new Date().getTime()}" alt="${candidate.name}">
                    </div>
                    <h4>${candidate.name}</h4>
                    <div class="successor-type">${candidate.type} Leader</div>
                    <div class="successor-age">Age: ${candidate.age}</div>
                    <div class="successor-traits">
                        ${candidate.traits.map(trait => `<span class="trait-badge">${trait}</span>`).join('')}
                    </div>
                    <p class="successor-desc">${candidate.description}</p>
                </div>
            `}).join('');

            const successionHTML = `
                <div class="succession-event">
                    <h3>üëë Choose Your Successor</h3>
                    <p class="succession-summary">${summary}</p>
                    <div class="succession-candidates">
                        ${candidatesHTML}
                    </div>
                </div>
            `;

            eventLog.innerHTML = successionHTML;

            // Hide controls
            actionGrid.classList.add('hidden');
            playerInputArea.classList.add('hidden');
            document.getElementById('game-controls').classList.add('hidden');
            continueBtn.classList.add('hidden');
        }

        function animateStatChange(element, oldValue, newValue) {
            if (oldValue === 0) return; // Skip animation on first load

            element.classList.remove('increased', 'decreased');

            if (newValue > oldValue) {
                element.classList.add('increased');
            } else if (newValue < oldValue) {
                element.classList.add('decreased');
            }

            // Remove animation class after it completes
            setTimeout(() => {
                element.classList.remove('increased', 'decreased');
            }, 600);
        }

        async function startCharacterVignette(characterName) {
            try {
                eventLog.innerHTML = `<p><em>Requesting an audience with ${characterName}...</em></p>`;
                const response = await fetch('/api/start_character_vignette', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ character_name: characterName })
                });
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const event = await response.json();
                displayEvent(event);
            } catch (error) {
                console.error("Failed to start character vignette:", error);
                eventLog.innerHTML = `<p class='error'>${characterName} is unavailable. Check the console.</p>`;
            }
        }

        // --- Event Listeners & Initial Load ---
        // Use event delegation for audience buttons since they are dynamic
        document.getElementById('right-panel').addEventListener('click', function(e) {
            if (e.target && e.target.classList.contains('audience-btn')) {
                const characterName = e.target.dataset.characterName;
                startCharacterVignette(characterName);
            }
        });

        submitInvestigateBtn.addEventListener('click', () => {
            const actionText = playerInput.value.trim();
            if (!actionText) {
                alert('Please type your question or action.');
                return;
            }
            handleEventInteraction(actionText);
        });

        submitDecideBtn.addEventListener('click', () => {
            const actionText = playerInput.value.trim();
            if (!actionText) {
                alert('Please type your final decision.');
                return;
            }
            handlePlayerAction();
        });

        playerInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                // Default to investigation on Enter
                const actionText = playerInput.value.trim();
                if (!actionText) return;
                handleEventInteraction(actionText);
            }
        });

        continueBtn.addEventListener('click', () => onContinue());
        timeskipBtn.addEventListener('click', handleTimeskip);
        abdicateBtn.addEventListener('click', handleAbdication);

        // Dashboard toggle functionality
        const dashboardToggle = document.getElementById('dashboard-toggle');
        const rightPanel = document.getElementById('right-panel');

        function toggleDashboard() {
            rightPanel.classList.toggle('collapsed');
            const toggleIcon = dashboardToggle.querySelector('.toggle-icon');
            toggleIcon.textContent = rightPanel.classList.contains('collapsed') ? '‚óÄ' : '‚ñ∂';
        }

        dashboardToggle.addEventListener('click', toggleDashboard);

        // Tab icon buttons - expand and switch to tab
        const tabIconButtons = document.querySelectorAll('.tab-icon-btn');
        tabIconButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const tabName = btn.dataset.tab;

                // If collapsed, expand first
                if (rightPanel.classList.contains('collapsed')) {
                    rightPanel.classList.remove('collapsed');
                    const toggleIcon = dashboardToggle.querySelector('.toggle-icon');
                    toggleIcon.textContent = '‚ñ∂';
                }

                // Switch to the selected tab
                switchTab(tabName);
            });
        });

        // Listen for successor choice event from global function
        window.addEventListener('successorChosen', async () => {
            await updateGameStateUI();
            showContinueUI("Begin New Reign", getNewEvent);
        });

        // Initial game start
        updateGameStateUI();
        getNewEvent();
    });
</script>
</body>
</html>



################################################################################
# FILE: old_codebase\templates\menu.html
# Size: 7603 bytes
################################################################################

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Civilization Simulation - Main Menu</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #f1f1f1;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .menu-container {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #c9a961;
            border-radius: 10px;
            padding: 50px;
            max-width: 600px;
            width: 100%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        h1 {
            text-align: center;
            font-size: 3em;
            margin-bottom: 20px;
            color: #c9a961;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        }

        .subtitle {
            text-align: center;
            font-size: 1.2em;
            margin-bottom: 40px;
            color: #a8a8a8;
            font-style: italic;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .menu-btn {
            background: linear-gradient(135deg, #c9a961 0%, #a08040 100%);
            border: none;
            color: #1a1a2e;
            padding: 20px 30px;
            font-size: 1.3em;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .menu-btn:hover {
            background: linear-gradient(135deg, #d4b56f 0%, #b89550 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .menu-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .menu-btn.secondary {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            color: #e2e8f0;
        }

        .menu-btn.secondary:hover {
            background: linear-gradient(135deg, #5a6678 0%, #3d4758 100%);
        }

        .save-info {
            background: rgba(201, 169, 97, 0.1);
            border: 1px solid #c9a961;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .save-info p {
            margin: 5px 0;
        }

        .save-info strong {
            color: #c9a961;
        }

        .no-save {
            color: #a8a8a8;
            font-style: italic;
            text-align: center;
            padding: 20px;
        }

        .error {
            background: rgba(220, 38, 38, 0.2);
            border: 1px solid #dc2626;
            color: #fca5a5;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            text-align: center;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #c9a961;
        }
    </style>
</head>
<body>
    <div class="menu-container">
        <h1>Civilization</h1>
        <p class="subtitle">Guide your people through the ages</p>

        <div id="error-message" class="error" style="display: none;"></div>

        <div id="menu-content" class="loading">
            <p>Loading...</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const menuContent = document.getElementById('menu-content');
            const errorMessage = document.getElementById('error-message');

            try {
                // Check if there's a saved game
                const response = await fetch('/api/check_save');
                const data = await response.json();

                let buttonsHTML = '';

                if (data.has_save) {
                    // Show save info and resume/new game options
                    buttonsHTML = `
                        <div class="save-info">
                            <p><strong>Saved Game Found</strong></p>
                            <p>Civilization: ${data.save_info.civilization_name}</p>
                            <p>Year: ${data.save_info.year}</p>
                            <p>Era: ${data.save_info.era}</p>
                            <p>Leader: ${data.save_info.leader_name}</p>
                        </div>
                        <div class="menu-buttons">
                            <button class="menu-btn" onclick="resumeGame()">Resume Game</button>
                            <button class="menu-btn secondary" onclick="confirmNewGame()">Start New Game</button>
                            <button class="menu-btn secondary" onclick="customWorld()">Custom World</button>
                        </div>
                    `;
                } else {
                    // No save found, show new game and custom world options
                    buttonsHTML = `
                        <p class="no-save">No saved game found</p>
                        <div class="menu-buttons">
                            <button class="menu-btn" onclick="startNewGame()">Start New Game</button>
                            <button class="menu-btn secondary" onclick="customWorld()">Custom World</button>
                        </div>
                    `;
                }

                menuContent.innerHTML = buttonsHTML;

            } catch (error) {
                console.error('Error loading menu:', error);
                errorMessage.textContent = 'Failed to load menu. Please refresh the page.';
                errorMessage.style.display = 'block';
                menuContent.innerHTML = '';
            }
        });

        function resumeGame() {
            window.location.href = '/game';
        }

        function startNewGame() {
            fetch('/api/new_game', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        window.location.href = '/game';
                    } else {
                        showError('Failed to start new game: ' + (data.message || 'Unknown error'));
                    }
                })
                .catch(error => {
                    console.error('Error starting new game:', error);
                    showError('Failed to start new game. Check console for details.');
                });
        }

        function confirmNewGame() {
            if (confirm('Starting a new game will overwrite your current save. Are you sure?')) {
                startNewGame();
            }
        }

        function customWorld() {
            window.location.href = '/custom';
        }

        function showError(message) {
            const errorMessage = document.getElementById('error-message');
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
        }
    </script>
</body>
</html>



################################################################################
# FILE: old_codebase\test_balance_changes.py
# Size: 12288 bytes
################################################################################

"""
BALANCE_OVERHAUL Test Suite
Tests all balance changes implemented across resource, crisis, faction, and leader systems.
"""

import sys
import os

# Configure stdout encoding for Windows
if sys.platform == 'win32':
    import codecs
    sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'strict')

# Add project root to path
sys.path.insert(0, os.path.dirname(__file__))

from game_state import GameState
from engines.resource_engine import calculate_consumption, apply_consumption, apply_passive_generation
from engines.crisis_engine import detect_crisis
from engines.leader_engine import TRAIT_EFFECTS, get_trait_bonus, calculate_leader_effectiveness


def test_phase1_resource_pressure():
    """Test Phase 1: Resource Pressure Foundation"""
    print("\n" + "="*60)
    print("TESTING PHASE 1: RESOURCE PRESSURE FOUNDATION")
    print("="*60)

    game_state = GameState()

    # Test 1.1: Tightened food consumption ratios (UPDATED for 2025-01 balance changes)
    print("\n[Test 1.1] Food Consumption Ratios")
    game_state.civilization['population'] = 100
    game_state.civilization['meta']['era'] = 'stone_age'

    consumption = calculate_consumption(game_state)
    expected_food = int((100 // 4) * 2.0)  # NEW: pop/4 instead of pop/10, 2.0 instead of 1.8
    actual_food = consumption['food']

    print(f"  Stone Age (100 pop): Expected {expected_food}, Got {actual_food}")
    assert actual_food == expected_food, f"Food consumption mismatch: {actual_food} != {expected_food}"
    print("  ‚úì Stone age food consumption increased correctly (1.8 ‚Üí 2.0, pop/10 ‚Üí pop/4)")

    # Test 1.2: Flat consumption (UPDATED for 2025-01 balance changes - removed tiering)
    print("\n[Test 1.2] Flat Population Consumption (pop/4)")

    # Clear infrastructure to get base consumption
    infrastructure_count = len(game_state.technology.get('infrastructure', []))
    game_state.technology['infrastructure'] = []

    test_cases = [
        (500, 1.2, "Classical era 500 pop"),
        (1000, 1.2, "Classical era 1000 pop"),
        (2000, 1.2, "Classical era 2000 pop"),
        (5000, 1.2, "Classical era 5000 pop")
    ]

    for pop, era_mult, tier_name in test_cases:
        game_state.civilization['population'] = pop
        game_state.civilization['meta']['era'] = 'classical'  # 1.2 multiplier (was 1.1)
        consumption = calculate_consumption(game_state)
        # New formula: (pop // 4) * era_efficiency * infrastructure_scaling
        # infrastructure_scaling = 1 + (0 * 0.005) = 1.0 (no buildings)
        expected = int((pop // 4) * era_mult * 1.0)
        actual = consumption['food']
        print(f"  {tier_name}: Expected {expected}, Got {actual}")
        assert actual == expected, f"{tier_name} consumption mismatch: {actual} != {expected}"

    print("  ‚úì Flat consumption formula works correctly (pop/4 * era_efficiency)")

    # Test 1.3: Exponential infrastructure maintenance (UPDATED for 2025-01 balance changes)
    print("\n[Test 1.3] Exponential Infrastructure Maintenance")

    # Clear existing buildings and set clean state
    if hasattr(game_state, 'buildings'):
        game_state.buildings['constructed_buildings'] = []
    game_state.technology['infrastructure'] = ['building_granary_001'] * 10  # 10 granaries

    consumption = calculate_consumption(game_state)
    # NEW formula: total_base_maintenance * (1 + count * 0.05)
    # 10 granaries @ 8 each = 80 base * 1.5 scaling = 120
    expected_wealth = int(10 * 8 * 1.5)
    actual_wealth = consumption['wealth']

    print(f"  10 granaries: Expected {expected_wealth}, Got {actual_wealth}")
    assert actual_wealth == expected_wealth, f"Infrastructure cost mismatch: {actual_wealth} != {expected_wealth}"
    print("  ‚úì Exponential scaling works (10 granaries @ 8 each * 1.5 = 120)")

    # Test 1.4: Food stockpile decay
    print("\n[Test 1.4] Food Stockpile Decay")
    game_state.civilization['resources']['food'] = 600  # Above 500 threshold
    initial_food = 600

    apply_consumption(game_state)

    # Should have 10% decay for > 500 food
    expected_after_decay = initial_food - consumption['food'] - int(initial_food * 0.10)
    actual_after = game_state.civilization['resources']['food']

    print(f"  Initial: {initial_food}, After consumption & decay: {actual_after}")
    print(f"  Expected: {expected_after_decay}")
    assert actual_after <= initial_food * 0.9, "Food decay not applied correctly"
    print("  ‚úì Food decay applied (10% for stockpiles > 500)")

    print("\n" + "‚úì"*30 + " PHASE 1 TESTS PASSED " + "‚úì"*30)


def test_phase2_crisis_escalation():
    """Test Phase 2: Crisis Escalation & Cascading"""
    print("\n" + "="*60)
    print("TESTING PHASE 2: CRISIS ESCALATION & CASCADING")
    print("="*60)

    game_state = GameState()

    # Test 2.1: Tightened crisis thresholds
    print("\n[Test 2.1] Tightened Crisis Thresholds")

    # Initialize crisis momentum tracking
    game_state.crisis_momentum = 0
    game_state.crisis_recovery_timer = 0

    test_scenarios = [
        (100, 0.4, 0, "famine"),
        (100, 0.7, 1000, "severe_food_shortage"),
        (100, 1.5, 1000, "food_shortage"),
        (100, 2.0, 250, "economic_warning"),
        (100, 2.0, 50, "economic_crisis")
    ]

    for pop, food_per_capita, wealth, expected_crisis in test_scenarios:
        game_state.civilization['population'] = pop
        game_state.civilization['resources']['food'] = int(pop * food_per_capita)
        game_state.civilization['resources']['wealth'] = wealth

        crisis = detect_crisis(game_state)
        print(f"  Food/capita: {food_per_capita:.1f}, Wealth: {wealth} ‚Üí Crisis: {crisis}")
        assert crisis == expected_crisis, f"Expected {expected_crisis}, got {crisis}"

    print("  ‚úì All crisis thresholds trigger correctly")

    # Test 2.2: Crisis cascading
    print("\n[Test 2.2] Crisis Cascading")
    game_state.civilization['population'] = 1000
    game_state.civilization['resources']['food'] = 1500  # 1.5 per capita - food crisis
    game_state.civilization['resources']['wealth'] = 250  # Economic crisis
    game_state.population_happiness = 35  # Happiness crisis

    # Run detection multiple times to test probabilistic cascading
    cascade_detected = False
    for _ in range(20):  # 20 attempts should trigger cascade
        crisis = detect_crisis(game_state)
        if crisis in ['economic_crisis', 'food_shortage', 'compound_crisis']:
            cascade_detected = True
            print(f"  Multiple crises detected ‚Üí Cascade triggered: {crisis}")
            break

    assert cascade_detected, "Crisis cascading failed to trigger"
    print("  ‚úì Crisis cascading system works")

    # Test 2.3: Crisis momentum tracking
    print("\n[Test 2.3] Crisis Momentum Tracking")
    game_state.crisis_momentum = 0
    game_state.civilization['resources']['food'] = 50  # Famine
    game_state.civilization['resources']['wealth'] = 1000

    initial_momentum = game_state.crisis_momentum
    detect_crisis(game_state)
    assert game_state.crisis_momentum == initial_momentum + 1, "Crisis momentum not incremented"
    print(f"  Crisis momentum: {initial_momentum} ‚Üí {game_state.crisis_momentum}")
    print("  ‚úì Crisis momentum tracking works")

    print("\n" + "‚úì"*30 + " PHASE 2 TESTS PASSED " + "‚úì"*30)


def test_phase3_faction_consequences():
    """Test Phase 3: Faction Mechanical Consequences"""
    print("\n" + "="*60)
    print("TESTING PHASE 3: FACTION MECHANICAL CONSEQUENCES")
    print("="*60)

    game_state = GameState()

    # Test 3.1: Faction bonuses
    print("\n[Test 3.1] Faction Approval Bonuses")

    if hasattr(game_state, 'faction_manager') and len(game_state.faction_manager) > 0:
        # Set a merchant faction to low approval
        for faction in game_state.faction_manager.get_all():
            if 'merchant' in faction.get('id', '').lower():
                faction['approval'] = 20  # Below 25 threshold
                break

        bonuses = game_state.faction_manager.get_faction_bonuses(game_state)

        print(f"  Wealth multiplier with angry merchants: {bonuses['wealth_multiplier']}")
        assert bonuses['wealth_multiplier'] <= 0.75, "Low merchant approval should reduce wealth"
        print("  ‚úì Faction approval affects wealth multiplier")
    else:
        print("  ‚ö† No factions available to test")

    print("\n" + "‚úì"*30 + " PHASE 3 TESTS PASSED " + "‚úì"*30)


def test_phase4_leader_tradeoffs():
    """Test Phase 4: Leader Trade-offs & Succession"""
    print("\n" + "="*60)
    print("TESTING PHASE 4: LEADER TRADE-OFFS & SUCCESSION")
    print("="*60)

    # Test 4.1: Leader trait penalties
    print("\n[Test 4.1] Leader Trait Penalties")

    # Test Ruthless trait (has both bonuses and penalties)
    ruthless_trait = TRAIT_EFFECTS['Ruthless']
    print(f"  Ruthless trait:")
    print(f"    Bonuses: {ruthless_trait['bonuses']}")
    print(f"    Penalties: {ruthless_trait['penalties']}")

    assert 'penalties' in ruthless_trait, "Ruthless trait missing penalties"
    assert 'diplomatic_reputation' in ruthless_trait['penalties'], "Missing diplomatic penalty"
    print("  ‚úì Traits have penalties defined")

    # Test get_trait_bonus with penalties
    test_leader = {'traits': ['Ruthless']}
    mil_bonus = get_trait_bonus(test_leader, 'military_reputation')
    dip_bonus = get_trait_bonus(test_leader, 'diplomatic_reputation')

    print(f"  Ruthless leader: Military +{mil_bonus}, Diplomatic {dip_bonus}")
    assert mil_bonus > 0, "Military bonus not applied"
    assert dip_bonus < 0, "Diplomatic penalty not applied"
    print("  ‚úì Bonus calculation handles penalties correctly")

    # Test 4.2: Aggressive age-based decline
    print("\n[Test 4.2] Aggressive Age-Based Decline")

    test_cases = [
        (15, 60, 0.90, "Youth"),       # 25% of life_exp
        (40, 60, 1.10, "Prime"),       # 67% of life_exp
        (45, 60, 1.05, "Aging"),       # 75% of life_exp
        (50, 60, 0.95, "Elderly"),     # 83% of life_exp
        (55, 60, 0.80, "Ancient"),     # 92% of life_exp
        (65, 60, 0.70, "Death's door") # 108% of life_exp
    ]

    for age, life_exp, expected_mult, age_group in test_cases:
        leader = {'age': age, 'life_expectancy': life_exp, 'traits': []}
        effectiveness = calculate_leader_effectiveness(leader, None)

        age_percent = (age / life_exp) * 100
        print(f"  {age_group} ({age_percent:.0f}%): Effectiveness {effectiveness:.2f} (expected ~{expected_mult:.2f})")

        # Allow 10% tolerance for trait bonuses
        assert abs(effectiveness - expected_mult) < 0.15, f"Age modifier incorrect for {age_group}"

    print("  ‚úì Age-based decline curve works correctly")

    print("\n" + "‚úì"*30 + " PHASE 4 TESTS PASSED " + "‚úì"*30)


def run_all_tests():
    """Run all balance change tests"""
    print("\n" + "="*60)
    print("GAME BALANCE OVERHAUL - COMPREHENSIVE TEST SUITE")
    print("="*60)

    try:
        test_phase1_resource_pressure()
        test_phase2_crisis_escalation()
        test_phase3_faction_consequences()
        test_phase4_leader_tradeoffs()

        print("\n" + "="*60)
        print("üéâ ALL TESTS PASSED! BALANCE OVERHAUL SUCCESSFUL! üéâ")
        print("="*60)
        print("\n‚úÖ Resource pressure: Food consumption increased, decay added")
        print("‚úÖ Crisis escalation: Tighter thresholds, cascading implemented")
        print("‚úÖ Faction consequences: Approval affects economy/military/happiness")
        print("‚úÖ Leader trade-offs: Traits have penalties, age decline aggressive")
        print("\n" + "="*60)

        return True

    except AssertionError as e:
        print(f"\n‚ùå TEST FAILED: {e}")
        return False
    except Exception as e:
        print(f"\n‚ùå ERROR: {e}")
        import traceback
        traceback.print_exc()
        return False


if __name__ == "__main__":
    success = run_all_tests()
    sys.exit(0 if success else 1)



################################################################################
# FILE: old_codebase\test_bonus_engine.py
# Size: 4337 bytes
################################################################################

#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Test script for BonusEngine - Verify bonus calculations match expected behavior.
"""

import sys
import os
import io

# Force UTF-8 encoding for Windows
if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

# Add parent directory to path
sys.path.insert(0, os.path.dirname(__file__))

from game_state import GameState
from engines.bonus_engine import BonusEngine
from engines.bonus_definitions import BonusType

print("=" * 60)
print("TESTING BONUS ENGINE")
print("=" * 60)

# Load actual game state
print("\n1. Loading game state...")
game = GameState()
print("   ‚úì Game state loaded successfully")

# Create bonus engine
print("\n2. Initializing BonusEngine...")
engine = BonusEngine()
print("   ‚úì BonusEngine initialized")

# Test science bonuses (should find Scholar in inner circle)
print("\n3. Testing Science Bonuses...")
science = engine.calculate_bonuses(game, BonusType.SCIENCE_PER_TURN)
print(f"   Total science bonus: +{science['total']}")
if science['sources']:
    for source_type, source_name, value in science['sources']:
        print(f"     +{value} from {source_type}: {source_name}")
else:
    print("     (No science bonuses found)")

# Test culture bonuses (should find Artisan in inner circle)
print("\n4. Testing Culture Bonuses...")
culture = engine.calculate_bonuses(game, BonusType.CULTURE_PER_TURN)
print(f"   Total culture bonus: +{culture['total']}")
if culture['sources']:
    for source_type, source_name, value in culture['sources']:
        print(f"     +{value} from {source_type}: {source_name}")
else:
    print("     (No culture bonuses found)")

# Test food bonuses (should be 0 currently)
print("\n5. Testing Food Bonuses...")
food = engine.calculate_bonuses(game, BonusType.FOOD_PER_TURN)
print(f"   Total food bonus: +{food['total']}")
if food['sources']:
    for source_type, source_name, value in food['sources']:
        print(f"     +{value} from {source_type}: {source_name}")
else:
    print("     (No food bonuses found - expected)")

# Test full summary
print("\n6. Full Bonus Summary:")
print("=" * 60)
summary = engine.format_bonus_summary(game)
print(summary)
print("=" * 60)

# Verify against world_turns_engine current logic
print("\n7. Verification Against Expected Values:")
print("   Expected science: 5 per Scholar in inner circle")
print(f"   Actual science: {science['total']}")
print("   Expected culture: 5 per Artisan in inner circle")
print(f"   Actual culture: {culture['total']}")

# Check if we found the expected bonuses
success = True
scholar_found = any(role == 'Scholar' for char in game.inner_circle_manager for role in [char.get('role')])
artisan_found = any(role == 'Artisan' for char in game.inner_circle_manager for role in [char.get('role')])

print("\n8. Inner Circle Analysis:")
print(f"   Total characters: {len(game.inner_circle_manager)}")
for char in game.inner_circle_manager:
    print(f"     - {char.get('name')}: {char.get('role', 'No role')}")

print("\n9. Test Results:")
if scholar_found and science['total'] >= 5:
    print("   ‚úì Science bonus working correctly (Scholar found)")
elif not scholar_found and science['total'] == 0:
    print("   ‚úì Science bonus working correctly (no Scholar present)")
else:
    print("   ‚ö† Science bonus mismatch")
    success = False

if artisan_found and culture['total'] >= 5:
    print("   ‚úì Culture bonus working correctly (Artisan found)")
elif not artisan_found and culture['total'] == 0:
    print("   ‚úì Culture bonus working correctly (no Artisan present)")
else:
    print("   ‚ö† Culture bonus mismatch")
    success = False

# Test invalid bonus type handling
print("\n10. Testing Invalid Bonus Type Handling...")
invalid = engine.calculate_bonuses(game, 'invalid_bonus_type')
if invalid['total'] == 0 and not invalid['sources']:
    print("   ‚úì Invalid bonus type handled gracefully")
else:
    print("   ‚ö† Invalid bonus type not handled properly")
    success = False

print("\n" + "=" * 60)
if success:
    print("‚úÖ ALL BONUS ENGINE TESTS PASSED!")
else:
    print("‚ö† SOME TESTS FAILED - CHECK OUTPUT ABOVE")
print("=" * 60)

sys.exit(0 if success else 1)



################################################################################
# FILE: old_codebase\test_council_meeting.py
# Size: 4305 bytes
################################################################################

"""
Test script for dynamic council meeting implementation.
Verifies the new central dilemma structure and advisor stances.
"""

import json
import sys
import io

# Fix encoding issues on Windows
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

from game_state import GameState
from engines.council_engine import generate_council_meeting

def test_council_meeting():
    print("=" * 60)
    print("TESTING DYNAMIC COUNCIL MEETING IMPLEMENTATION")
    print("=" * 60)

    # Load game state
    game_state = GameState()

    print("\n1. Testing Inner Circle Manager")
    print("-" * 60)
    if hasattr(game_state, 'inner_circle_manager'):
        advisors = game_state.inner_circle_manager.get_all()
        print(f"‚úì Found {len(advisors)} advisors:")
        for advisor in advisors:
            print(f"  - {advisor['name']} ({advisor['role']})")
            print(f"    Personality: {', '.join(advisor.get('personality_traits', []))}")
            print(f"    Loyalty: {advisor.get('metrics', {}).get('loyalty', 50)}")
            print(f"    Relationship: {advisor.get('metrics', {}).get('relationship', 50)}")
    else:
        print("‚úó No inner circle manager found!")
        return False

    print("\n2. Generating Council Meeting")
    print("-" * 60)

    council_data = generate_council_meeting(game_state)

    if not council_data:
        print("‚úó Failed to generate council meeting!")
        return False

    print("‚úì Council meeting generated successfully!")

    print("\n3. Verifying JSON Structure")
    print("-" * 60)

    # Check required fields
    required_fields = ['event_type', 'title', 'narrative', 'central_dilemma', 'advisor_stances']
    for field in required_fields:
        if field in council_data:
            print(f"‚úì '{field}' present")
        else:
            print(f"‚úó '{field}' MISSING!")
            return False

    print("\n4. Council Meeting Details")
    print("-" * 60)
    print(f"Event Type: {council_data.get('event_type')}")
    print(f"Title: {council_data.get('title')}")
    print(f"\nNarrative:\n{council_data.get('narrative')}")
    print(f"\nCentral Dilemma:\n{council_data.get('central_dilemma')}")

    print("\n5. Advisor Stances")
    print("-" * 60)
    advisor_stances = council_data.get('advisor_stances', [])
    if len(advisor_stances) >= 2:
        print(f"‚úì Found {len(advisor_stances)} advisor stances (minimum 2)")
        for i, stance in enumerate(advisor_stances, 1):
            print(f"\nAdvisor {i}:")
            print(f"  Name: {stance.get('name')}")
            print(f"  Role: {stance.get('role')}")
            print(f"  Position: {stance.get('position')}")
            print(f"  Reasoning: {stance.get('reasoning')}")
    else:
        print(f"‚úó Only {len(advisor_stances)} advisor stances (need at least 2)")
        return False

    print("\n6. Investigation Options")
    print("-" * 60)
    inv_options = council_data.get('investigation_options', [])
    if len(inv_options) == 2:
        print(f"‚úì Found {len(inv_options)} investigation options")
        for i, option in enumerate(inv_options, 1):
            print(f"  {i}. {option}")
    else:
        print(f"‚úó Found {len(inv_options)} investigation options (need exactly 2)")
        return False

    print("\n7. Decision Options")
    print("-" * 60)
    dec_options = council_data.get('decision_options', [])
    if len(dec_options) == 2:
        print(f"‚úì Found {len(dec_options)} decision options")
        for i, option in enumerate(dec_options, 1):
            print(f"  {i}. {option}")
    else:
        print(f"‚úó Found {len(dec_options)} decision options (need exactly 2)")
        return False

    print("\n8. Complete JSON Output")
    print("-" * 60)
    print(json.dumps(council_data, indent=2))

    print("\n" + "=" * 60)
    print("‚úì ALL TESTS PASSED!")
    print("=" * 60)
    return True

if __name__ == "__main__":
    try:
        success = test_council_meeting()
        exit(0 if success else 1)
    except Exception as e:
        print(f"\n‚úó TEST FAILED WITH ERROR:")
        print(f"  {e}")
        import traceback
        traceback.print_exc()
        exit(1)



################################################################################
# FILE: old_codebase\test_council_metrics.py
# Size: 7031 bytes
################################################################################

"""
End-to-end test for council meeting advisor metric updates.
Simulates a full council meeting flow and verifies metrics change.
"""

import json
import sys
import io

# Fix encoding issues on Windows
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

from game_state import GameState
from engines.council_engine import generate_council_meeting
from engines.world_turns_engine import WorldTurnsEngine
from engines.state_updater import apply_world_turn_updates

def test_metrics_update():
    print("=" * 60)
    print("TESTING COUNCIL MEETING METRIC UPDATES")
    print("=" * 60)

    # Load game state
    game_state = GameState()

    print("\n1. Initial Advisor Metrics")
    print("-" * 60)
    initial_metrics = {}
    for advisor in game_state.inner_circle_manager.get_all():
        name = advisor['name']
        metrics = advisor.get('metrics', {})
        initial_metrics[name] = {
            'loyalty': metrics.get('loyalty', 50),
            'relationship': metrics.get('relationship', 50)
        }
        print(f"{name}:")
        print(f"  Loyalty: {initial_metrics[name]['loyalty']}")
        print(f"  Relationship: {initial_metrics[name]['relationship']}")

    print("\n2. Generate Council Meeting")
    print("-" * 60)
    council_data = generate_council_meeting(game_state)

    if not council_data:
        print("‚úó Failed to generate council meeting!")
        return False

    game_state.current_event = council_data
    game_state.event_stage = 0
    game_state.event_conversation = []

    print(f"‚úì Council meeting: {council_data.get('title')}")
    print(f"‚úì Dilemma: {council_data.get('central_dilemma')[:80]}...")

    print("\n3. Simulate Player Dialogue")
    print("-" * 60)
    # Simulate player asking advisor questions
    advisor_stances = council_data.get('advisor_stances', [])
    if len(advisor_stances) >= 2:
        first_advisor = advisor_stances[0]['name']
        second_advisor = advisor_stances[1]['name']

        # Simulate conversation
        game_state.event_conversation = [
            {
                "player": f"Ask {first_advisor} to elaborate on their position",
                "ai": f"{first_advisor}: I stand by my position. This is crucial for our survival."
            },
            {
                "player": f"Question {second_advisor} about risks",
                "ai": f"{second_advisor}: I understand your concerns, but my approach is sound."
            }
        ]

        print(f"‚úì Player questioned {first_advisor}")
        print(f"‚úì Player questioned {second_advisor}")
    else:
        print("‚úó Not enough advisor stances!")
        return False

    print("\n4. Player Makes Final Decision (Favoring First Advisor)")
    print("-" * 60)
    # Simulate player siding with first advisor
    player_action = f"Heed {first_advisor}'s counsel and follow their strategy"
    outcome = {"narrative": f"The council accepts {first_advisor}'s wisdom."}

    print(f"Decision: {player_action}")

    print("\n5. World Turn Simulation (Analyzing Conversation)")
    print("-" * 60)
    world_turns_engine = WorldTurnsEngine()

    world_updates = world_turns_engine.simulate_turn(game_state, {
        "action": player_action,
        "outcome": outcome,
        "event_type": "council_meeting",
        "conversation": game_state.event_conversation
    })

    if not world_updates:
        print("‚úó No world updates generated!")
        return False

    print("‚úì World turn simulation complete")

    print("\n6. Inspect Inner Circle Updates")
    print("-" * 60)
    inner_circle_updates = world_updates.get('inner_circle_updates', [])

    if not inner_circle_updates:
        print("‚ö† Warning: No inner circle updates generated!")
        print("This might be an AI generation issue - the logic is in place.")
        return True  # Don't fail, as AI might not always generate updates

    print(f"‚úì Found {len(inner_circle_updates)} advisor updates:")
    for update in inner_circle_updates:
        name = update.get('name')
        loyalty_change = update.get('loyalty_change', 0)
        opinion_change = update.get('opinion_change', 0)
        memory = update.get('memory', 'No memory')

        print(f"\n  {name}:")
        print(f"    Loyalty change: {loyalty_change:+d}")
        print(f"    Opinion change: {opinion_change:+d}")
        print(f"    Memory: {memory}")

    print("\n7. Apply Updates to Game State")
    print("-" * 60)
    apply_world_turn_updates(game_state, world_updates)

    print("\n8. Verify Metric Changes")
    print("-" * 60)
    changes_detected = False

    for advisor in game_state.inner_circle_manager.get_all():
        name = advisor['name']
        metrics = advisor.get('metrics', {})
        new_loyalty = metrics.get('loyalty', 50)
        new_relationship = metrics.get('relationship', 50)

        old_loyalty = initial_metrics[name]['loyalty']
        old_relationship = initial_metrics[name]['relationship']

        loyalty_diff = new_loyalty - old_loyalty
        relationship_diff = new_relationship - old_relationship

        print(f"{name}:")
        print(f"  Loyalty: {old_loyalty} ‚Üí {new_loyalty} ({loyalty_diff:+d})")
        print(f"  Relationship: {old_relationship} ‚Üí {new_relationship} ({relationship_diff:+d})")

        if loyalty_diff != 0 or relationship_diff != 0:
            changes_detected = True
            print(f"  ‚úì Metrics changed!")
        else:
            print(f"  - No change")

    print("\n9. Verify Memory Addition")
    print("-" * 60)
    memories_added = False

    for advisor in game_state.inner_circle_manager.get_all():
        name = advisor['name']
        history = advisor.get('history', [])

        if history:
            latest_memory = history[-1]
            print(f"{name}: {latest_memory}")
            if f"Turn {game_state.turn_number}" in latest_memory:
                memories_added = True
        else:
            print(f"{name}: No memories")

    print("\n" + "=" * 60)
    if changes_detected and memories_added:
        print("‚úì FULL INTEGRATION TEST PASSED!")
        print("  - Metrics successfully updated based on dialogue")
        print("  - Memories successfully added to character history")
    elif not changes_detected and not memories_added:
        print("‚ö† PARTIAL SUCCESS")
        print("  - Logic is correctly in place")
        print("  - AI may not have generated updates (varies by API)")
        print("  - Manual verification recommended in UI")
    print("=" * 60)

    return True

if __name__ == "__main__":
    try:
        success = test_metrics_update()
        exit(0 if success else 1)
    except Exception as e:
        print(f"\n‚úó TEST FAILED WITH ERROR:")
        print(f"  {e}")
        import traceback
        traceback.print_exc()
        exit(1)



################################################################################
# FILE: old_codebase\test_crisis_mechanical_consequences.py
# Size: 9846 bytes
################################################################################

"""
Test suite for crisis events with mechanical consequences.

This test verifies that crisis events generate `updates` blocks that are
validated and applied to the game state, causing direct mechanical consequences.
"""

import json
import sys
import os

# Import game systems
from game_state import GameState
from engines.crisis_engine import generate_crisis_event, detect_crisis
from engines.state_validator import validate_updates


def test_crisis_event_has_updates():
    """Test that crisis events contain an 'updates' block."""
    print("\n" + "=" * 60)
    print("TEST: Crisis Events Contain Updates Block")
    print("=" * 60)

    # Create a game state with crisis conditions (low food)
    game_state = GameState()
    game_state.civilization['resources']['food'] = 50
    game_state.civilization['population'] = 1000

    # Detect crisis type
    crisis_type = detect_crisis(game_state)
    if not crisis_type:
        print("‚ùå FAIL: No crisis detected with low food")
        return False

    print(f"‚úì Crisis detected: {crisis_type}")

    # Generate crisis event
    try:
        event_data = generate_crisis_event(game_state, crisis_type)
    except Exception as e:
        print(f"‚ùå FAIL: Error generating crisis event: {e}")
        return False

    # Check if updates block exists
    if 'updates' not in event_data:
        print(f"‚ùå FAIL: Crisis event does not contain 'updates' block")
        print(f"Event data keys: {list(event_data.keys())}")
        return False

    print(f"‚úì Crisis event contains 'updates' block")

    # Check if updates block is non-empty
    updates = event_data.get('updates', {})
    if not updates:
        print(f"‚ùå FAIL: Updates block is empty")
        return False

    print(f"‚úì Updates block contains {len(updates)} entries:")
    for key, value in updates.items():
        print(f"  - {key}: {value}")

    return True


def test_crisis_updates_validation():
    """Test that crisis updates pass validation."""
    print("\n" + "=" * 60)
    print("TEST: Crisis Updates Pass Validation")
    print("=" * 60)

    # Create a game state with crisis conditions (low wealth)
    game_state = GameState()
    game_state.civilization['resources']['wealth'] = 50
    game_state.civilization['population'] = 1000

    # Detect crisis type
    crisis_type = detect_crisis(game_state)
    if not crisis_type:
        print("‚ùå FAIL: No crisis detected with low wealth")
        return False

    print(f"‚úì Crisis detected: {crisis_type}")

    # Generate crisis event
    try:
        event_data = generate_crisis_event(game_state, crisis_type)
    except Exception as e:
        print(f"‚ùå FAIL: Error generating crisis event: {e}")
        return False

    updates = event_data.get('updates', {})
    if not updates:
        print(f"‚ö†Ô∏è  SKIP: Updates block is empty (AI may not have generated updates)")
        return True  # Not a failure - AI might need more context

    # Validate updates
    is_valid, cleaned_updates, errors = validate_updates(updates, game_state)

    if errors:
        print(f"‚ö†Ô∏è  Validation warnings found ({len(errors)}):")
        for error in errors:
            print(f"  - {error}")

    if not cleaned_updates:
        print(f"‚ùå FAIL: No valid updates after validation")
        return False

    print(f"‚úì Validation passed with {len(cleaned_updates)} valid updates")
    for key, value in cleaned_updates.items():
        print(f"  - {key}: {value}")

    return True


def test_crisis_updates_application():
    """Test that crisis updates are correctly applied to game state."""
    print("\n" + "=" * 60)
    print("TEST: Crisis Updates Are Applied to Game State")
    print("=" * 60)

    # Create a game state with crisis conditions (famine)
    game_state = GameState()
    initial_population = 1000
    initial_food = 100
    game_state.civilization['population'] = initial_population
    game_state.civilization['resources']['food'] = initial_food

    # Force famine crisis by setting very low food per capita
    game_state.civilization['resources']['food'] = 10  # Very low food

    # Detect and generate crisis
    crisis_type = detect_crisis(game_state)
    if crisis_type != 'famine':
        print(f"‚ö†Ô∏è  SKIP: Expected famine crisis, got {crisis_type}")
        return True

    print(f"‚úì Famine crisis detected")

    # Store initial values
    initial_population = game_state.civilization['population']
    initial_food = game_state.civilization['resources']['food']

    # Generate and apply crisis event
    try:
        from engines.state_updater import apply_updates
        event_data = generate_crisis_event(game_state, crisis_type)
        updates = event_data.get('updates', {})

        if not updates:
            print(f"‚ö†Ô∏è  SKIP: No updates generated by AI")
            return True

        # Validate and apply
        is_valid, cleaned_updates, errors = validate_updates(updates, game_state)
        if cleaned_updates:
            apply_updates(game_state, cleaned_updates)
            print(f"‚úì Updates applied")
        else:
            print(f"‚ö†Ô∏è  SKIP: No valid updates to apply")
            return True

    except Exception as e:
        print(f"‚ùå FAIL: Error applying updates: {e}")
        return False

    # Verify changes
    final_population = game_state.civilization['population']
    final_food = game_state.civilization['resources']['food']

    population_change = final_population - initial_population
    food_change = final_food - initial_food

    print(f"‚úì Population: {initial_population} ‚Üí {final_population} ({population_change:+d})")
    print(f"‚úì Food: {initial_food} ‚Üí {final_food} ({food_change:+d})")

    # Expect negative changes for famine
    if population_change >= 0 and food_change >= 0:
        print(f"‚ö†Ô∏è  WARNING: Expected negative changes for famine, but no losses occurred")

    return True


def test_multiple_crisis_types():
    """Test that different crisis types generate appropriate updates."""
    print("\n" + "=" * 60)
    print("TEST: Different Crisis Types Generate Appropriate Updates")
    print("=" * 60)

    crisis_scenarios = [
        ('famine', {'food': 0, 'population': 1000}),
        ('economic_collapse', {'wealth': 0, 'population': 1000, 'food': 500}),
        ('food_shortage', {'food': 200, 'population': 1000}),
        ('economic_crisis', {'wealth': 50, 'population': 1000, 'food': 500}),
    ]

    results = []

    for crisis_type, conditions in crisis_scenarios:
        game_state = GameState()

        # Set conditions
        for key, value in conditions.items():
            if key == 'food':
                game_state.civilization['resources']['food'] = value
            elif key == 'wealth':
                game_state.civilization['resources']['wealth'] = value
            elif key == 'population':
                game_state.civilization['population'] = value

        # Generate crisis event
        try:
            event_data = generate_crisis_event(game_state, crisis_type)
            updates = event_data.get('updates', {})

            if updates:
                print(f"‚úì {crisis_type}: Generated {len(updates)} updates")
                results.append(True)
            else:
                print(f"‚ö†Ô∏è  {crisis_type}: No updates generated")
                results.append(False)

        except Exception as e:
            print(f"‚ùå {crisis_type}: Error - {e}")
            results.append(False)

    success_rate = sum(results) / len(results) * 100
    print(f"\n‚úì Success rate: {success_rate:.0f}% ({sum(results)}/{len(results)})")

    return success_rate >= 50  # At least 50% should succeed


def run_all_tests():
    """Run all crisis mechanical consequences tests."""
    print("\n" + "=" * 70)
    print("CRISIS MECHANICAL CONSEQUENCES TEST SUITE")
    print("=" * 70)
    print("\nThese tests verify that crisis events include mechanical consequences")
    print("via 'updates' blocks that are validated and applied to the game state.")
    print("=" * 70)

    tests = [
        ("Crisis Events Contain Updates Block", test_crisis_event_has_updates),
        ("Crisis Updates Pass Validation", test_crisis_updates_validation),
        ("Crisis Updates Are Applied to Game State", test_crisis_updates_application),
        ("Different Crisis Types Generate Updates", test_multiple_crisis_types),
    ]

    results = []
    for test_name, test_func in tests:
        try:
            result = test_func()
            results.append((test_name, result))
        except Exception as e:
            print(f"\n‚ùå EXCEPTION in {test_name}: {e}")
            import traceback
            traceback.print_exc()
            results.append((test_name, False))

    # Summary
    print("\n" + "=" * 70)
    print("TEST SUMMARY")
    print("=" * 70)

    passed = sum(1 for _, result in results if result)
    total = len(results)

    for test_name, result in results:
        status = "‚úì PASS" if result else "‚ùå FAIL"
        print(f"{status}: {test_name}")

    print("=" * 70)
    print(f"Total: {passed}/{total} tests passed ({passed/total*100:.0f}%)")
    print("=" * 70)

    if passed == total:
        print("\nüéâ All tests passed!")
    elif passed > 0:
        print(f"\n‚ö†Ô∏è  Some tests failed. {total - passed} test(s) need attention.")
    else:
        print("\n‚ùå All tests failed. Please review the implementation.")

    return passed == total


if __name__ == "__main__":
    success = run_all_tests()
    sys.exit(0 if success else 1)



################################################################################
# FILE: old_codebase\test_crisis_parsing.py
# Size: 898 bytes
################################################################################

from engines.visual_engine import _parse_crisis_prompts
from engines.prompt_loader import load_prompt

content = load_prompt('visuals/crisis_illustration')
sections = content.split('---')
print(f'Found {len(sections)} sections\n')

for i, section in enumerate(sections):
    section = section.strip()
    if not section:
        print(f'Section {i}: EMPTY')
        continue

    # Check if it starts with ##
    lines = section.split('\n')
    header = None
    for line in lines:
        if line.startswith('## '):
            header = line
            break

    print(f'Section {i}: Header = {header}, Length = {len(section)} chars')

print('\n' + '='*60)
print('Testing parser:')
print('='*60)

prompts = _parse_crisis_prompts(content)
print(f'\nParsed {len(prompts)} crisis types:')
for key in prompts.keys():
    print(f'  - {key}: {len(prompts[key])} chars')



################################################################################
# FILE: old_codebase\test_event_lifecycle.py
# Size: 9726 bytes
################################################################################

#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Integration test for complete event lifecycle.
Tests: Event Generation ‚Üí Investigation ‚Üí Decision ‚Üí State Updates ‚Üí Validation
"""

import sys
import os
import io

# Force UTF-8 encoding for Windows
if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

# Add parent directory to path
sys.path.insert(0, os.path.dirname(__file__))

from game_state import GameState
from engines.event_generator import generate_event, generate_event_stage
from engines.action_processor import process_player_action


def test_event_generation():
    """Test that events can be generated without errors."""
    print("=" * 60)
    print("TEST 1: Event Generation")
    print("=" * 60)

    game = GameState()
    print(f"‚úì Game state loaded (Turn {game.turn_number})")

    # Generate an event
    print("‚úì Generating event...")
    event = generate_event(game)

    # Validate event structure
    assert 'title' in event, "Event missing title"
    assert 'narrative' in event, "Event missing narrative"

    # Check for appropriate options based on event type
    if 'game_over' in event and event['game_over']:
        print(f"  ‚ÑπÔ∏è Special event: {event.get('title', 'Unknown')}")
    elif 'council' in event.get('title', '').lower():
        print(f"  ‚ÑπÔ∏è Council meeting event: {event['title']}")
    else:
        assert 'investigation_options' in event or 'decision_options' in event, "Event missing options"

    print(f"‚úì Event generated: '{event.get('title', 'Unknown')}'")
    print(f"  Narrative: {event.get('narrative', '')[:80]}...")

    return game, event


def test_event_investigation(game, event):
    """Test event investigation mechanic."""
    print("\n" + "=" * 60)
    print("TEST 2: Event Investigation")
    print("=" * 60)

    # Skip if event doesn't support investigation
    if 'game_over' in event and event['game_over']:
        print("‚äò Skipped (game over event)")
        return None

    if 'investigation_options' not in event:
        print("‚äò Skipped (event has no investigation options)")
        return None

    investigation_option = event['investigation_options'][0] if event['investigation_options'] else "Ask for more information"

    print(f"‚úì Player investigates: '{investigation_option}'")

    # Generate next stage
    stage_data = generate_event_stage(game, investigation_option)

    # Validate stage structure
    assert 'narrative' in stage_data, "Stage missing narrative"
    assert 'investigation_options' in stage_data, "Stage missing investigation options"
    assert 'decision_options' in stage_data, "Stage missing decision options"

    print(f"‚úì Stage {game.event_stage} generated")
    print(f"  Response: {stage_data['narrative'][:80]}...")
    print(f"  New investigation options: {len(stage_data['investigation_options'])}")
    print(f"  Updated decision options: {len(stage_data['decision_options'])}")

    return stage_data


def test_event_decision(game, event):
    """Test event decision and state updates."""
    print("\n" + "=" * 60)
    print("TEST 3: Event Decision & State Updates")
    print("=" * 60)

    # Get decision option
    if 'decision_options' in event and event['decision_options']:
        decision = event['decision_options'][0]
    else:
        decision = "Proceed cautiously"

    print(f"‚úì Player decides: '{decision}'")

    # Store pre-action state
    pre_population = game.civilization['population']
    pre_food = game.civilization['resources']['food']
    pre_wealth = game.civilization['resources']['wealth']
    pre_year = game.civilization['meta']['year']
    pre_turn = game.turn_number

    print(f"  Pre-action state:")
    print(f"    Population: {pre_population}, Food: {pre_food}, Wealth: {pre_wealth}")
    print(f"    Year: {pre_year}, Turn: {pre_turn}")

    # Process action
    event_title = event.get('title', 'Test Event')
    event_narrative = event.get('narrative', 'Test narrative')

    print("‚úì Processing action...")
    outcome = process_player_action(game, decision, event_title, event_narrative)

    # Validate outcome structure
    assert 'narrative' in outcome, "Outcome missing narrative"
    print(f"‚úì Outcome generated: {outcome['narrative'][:80]}...")

    # Check state changes
    post_population = game.civilization['population']
    post_food = game.civilization['resources']['food']
    post_wealth = game.civilization['resources']['wealth']
    post_year = game.civilization['meta']['year']
    post_turn = game.turn_number

    print(f"  Post-action state:")
    print(f"    Population: {post_population} ({post_population - pre_population:+d})")
    print(f"    Food: {post_food} ({post_food - pre_food:+d})")
    print(f"    Wealth: {post_wealth} ({post_wealth - pre_wealth:+d})")
    print(f"    Year: {post_year} (advanced from {pre_year})")
    print(f"    Turn: {post_turn} (advanced from {pre_turn})")

    # Validate automatic progression
    assert post_year == pre_year + 1, "Year did not advance"
    assert post_turn == pre_turn + 1, "Turn did not advance"

    print("‚úì Automatic progression verified (year +1, turn +1)")

    # Check for warnings
    if 'resource_warnings' in outcome:
        print(f"  ‚ö†Ô∏è Resource warnings: {', '.join(outcome['resource_warnings'])}")

    return outcome


def test_data_integrity(game):
    """Test that game state remains valid after event."""
    print("\n" + "=" * 60)
    print("TEST 4: Data Integrity Check")
    print("=" * 60)

    # Check required fields
    assert 'meta' in game.civilization, "Missing civilization.meta"
    assert 'leader' in game.civilization, "Missing civilization.leader"
    assert 'population' in game.civilization, "Missing population"
    assert 'resources' in game.civilization, "Missing resources"

    # Check leader data
    leader = game.civilization['leader']
    assert 'name' in leader, "Missing leader name"
    assert 'age' in leader, "Missing leader age"
    assert 'traits' in leader, "Missing leader traits"
    assert isinstance(leader['traits'], list), "Leader traits must be a list"

    # Check resources are non-negative
    resources = game.civilization['resources']
    assert resources['food'] >= 0, "Food cannot be negative"
    assert resources['wealth'] >= 0, "Wealth cannot be negative"

    # Check population is reasonable
    population = game.civilization['population']
    assert population >= 50, f"Population too low: {population}"
    assert population <= 1000000, f"Population unreasonably high: {population}"

    print("‚úì All required fields present")
    print("‚úì Leader data valid")
    print("‚úì Resources within bounds")
    print("‚úì Population reasonable")

    # Run data validator
    from engines.data_validator import validate_all

    validation_result = validate_all(game)

    if validation_result['errors']:
        print("‚ö†Ô∏è Validation errors found:")
        for error in validation_result['errors']:
            print(f"    - {error}")
    else:
        print("‚úì Data validator passed (no errors)")

    return validation_result['valid']


def test_save_and_reload(game):
    """Test that game state can be saved and reloaded."""
    print("\n" + "=" * 60)
    print("TEST 5: Save & Reload")
    print("=" * 60)

    # Save current state
    pre_turn = game.turn_number
    pre_population = game.civilization['population']

    print(f"‚úì Saving game state (Turn {pre_turn}, Pop {pre_population})...")
    game.save()

    # Reload
    print("‚úì Reloading game state...")
    game2 = GameState()

    # Verify data matches
    assert game2.turn_number == pre_turn, "Turn number mismatch after reload"
    assert game2.civilization['population'] == pre_population, "Population mismatch after reload"

    print(f"‚úì Reloaded successfully (Turn {game2.turn_number}, Pop {game2.civilization['population']})")
    print("‚úì Data integrity maintained across save/load cycle")

    return True


def main():
    """Run all integration tests."""
    print("=" * 60)
    print("EVENT LIFECYCLE INTEGRATION TEST")
    print("=" * 60)
    print()

    try:
        # Test 1: Generate event
        game, event = test_event_generation()

        # Test 2: Investigate event (if applicable)
        stage_data = test_event_investigation(game, event)

        # Test 3: Make decision
        outcome = test_event_decision(game, event)

        # Test 4: Validate data integrity
        valid = test_data_integrity(game)

        # Test 5: Save and reload
        save_ok = test_save_and_reload(game)

        # Summary
        print("\n" + "=" * 60)
        print("‚úÖ ALL INTEGRATION TESTS PASSED!")
        print("=" * 60)
        print("\nThe complete event lifecycle works correctly:")
        print("  ‚úì Event generation")
        print("  ‚úì Investigation mechanics")
        print("  ‚úì Decision processing")
        print("  ‚úì State updates")
        print("  ‚úì Data validation")
        print("  ‚úì Persistence")
        print("\nThe system is stable and ready for gameplay.")
        print("=" * 60)

        return True

    except Exception as e:
        print("\n" + "=" * 60)
        print("‚ùå TEST FAILED")
        print("=" * 60)
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
        return False


if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)



################################################################################
# FILE: old_codebase\test_faction_consequences.py
# Size: 3989 bytes
################################################################################

"""
Test script to verify that faction decision consequences are properly applied.
Tests the fix for Issue #2: Asymmetric Faction Consequences Are Never Applied
"""

import sys
import os
import io

# Fix encoding for Windows console
if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8', errors='replace')

sys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))

from engines.faction_manager import FactionManager
from engines.faction_engine import apply_faction_decision_consequences

class MockGameState:
    """Mock game state for testing"""
    def __init__(self):
        # Create initial faction data
        self.faction_manager = FactionManager({
            "factions": [
                {
                    "id": "faction_merchants_guild_001",
                    "name": "The Merchant's Guild",
                    "approval": 60,
                },
                {
                    "id": "faction_warriors_caste_001",
                    "name": "The Warrior's Caste",
                    "approval": 60,
                },
                {
                    "id": "faction_priesthood_sun_001",
                    "name": "The Priesthood of the Sun",
                    "approval": 60,
                }
            ]
        })

def test_faction_consequences():
    """Test that faction consequences are properly applied"""
    print("=" * 60)
    print("TEST: Faction Decision Consequences")
    print("=" * 60)

    # Create mock game state
    game_state = MockGameState()

    # Get initial approval ratings
    merchants = game_state.faction_manager.get_by_name("The Merchant's Guild")
    warriors = game_state.faction_manager.get_by_name("The Warrior's Caste")
    priesthood = game_state.faction_manager.get_by_name("The Priesthood of the Sun")

    print("\n--- INITIAL APPROVAL RATINGS ---")
    print(f"Merchants: {merchants['approval']}")
    print(f"Warriors: {warriors['approval']}")
    print(f"Priesthood: {priesthood['approval']}")

    # Simulate a faction decision: Side with Merchants
    print("\n--- PLAYER DECISION: Side with The Merchant's Guild ---")
    chosen_faction = "The Merchant's Guild"
    opposed_factions = ["The Warrior's Caste", "The Priesthood of the Sun"]

    apply_faction_decision_consequences(game_state, chosen_faction, opposed_factions)

    # Get updated approval ratings
    print("\n--- UPDATED APPROVAL RATINGS ---")
    print(f"Merchants: {merchants['approval']} (expected: 80, change: +20)")
    print(f"Warriors: {warriors['approval']} (expected: 20, change: -40)")
    print(f"Priesthood: {priesthood['approval']} (expected: 20, change: -40)")

    # Verify the changes
    print("\n--- VERIFICATION ---")
    success = True

    if merchants['approval'] == 80:
        print("‚úì Merchants approval correctly increased by +20")
    else:
        print(f"‚úó Merchants approval incorrect: {merchants['approval']} (expected 80)")
        success = False

    if warriors['approval'] == 20:
        print("‚úì Warriors approval correctly decreased by -40")
    else:
        print(f"‚úó Warriors approval incorrect: {warriors['approval']} (expected 20)")
        success = False

    if priesthood['approval'] == 20:
        print("‚úì Priesthood approval correctly decreased by -40")
    else:
        print(f"‚úó Priesthood approval incorrect: {priesthood['approval']} (expected 20)")
        success = False

    print("\n" + "=" * 60)
    if success:
        print("TEST PASSED: Faction consequences are working correctly!")
    else:
        print("TEST FAILED: Faction consequences are not working as expected")
    print("=" * 60)

    return success

if __name__ == "__main__":
    success = test_faction_consequences()
    sys.exit(0 if success else 1)



################################################################################
# FILE: old_codebase\test_faction_goal_simulation.py
# Size: 14747 bytes
################################################################################

"""
Test suite for passive faction goal simulation.

This test verifies that factions react to turn outcomes based on their goals,
adjusting approval ratings when outcomes align with or contradict their objectives.
"""

import json
import sys
import os

# Import game systems
from game_state import GameState
from engines.action_processor import _check_faction_goals


def test_wealth_goal_positive():
    """Test that factions with wealth goals gain approval when wealth increases."""
    print("\n" + "=" * 60)
    print("TEST: Wealth Goal - Positive Outcome")
    print("=" * 60)

    # Create game state
    game_state = GameState()

    # Find a faction with wealth-related goals (Merchant's Guild)
    merchant_faction = None
    for faction in game_state.faction_manager.get_all():
        goals = [g.lower() for g in faction.get('goals', [])]
        if any('wealth' in g or 'trade' in g for g in goals):
            merchant_faction = faction
            break

    if not merchant_faction:
        print("‚ö†Ô∏è  SKIP: No faction with wealth goals found")
        return True

    faction_name = merchant_faction['name']
    initial_approval = merchant_faction.get('approval', 60)

    print(f"‚úì Testing faction: {faction_name}")
    print(f"  Initial approval: {initial_approval}")
    print(f"  Goals: {merchant_faction.get('goals', [])}")

    # Create outcome with wealth increase
    outcome = {
        'updates': {
            'civilization.resources.wealth': 500
        },
        'narrative': 'Trade flourished and merchants prospered.'
    }

    # Apply faction goal check
    _check_faction_goals(game_state, outcome, action='Establish trade routes', event_title='Trade Opportunity')

    # Check if approval increased
    updated_faction = game_state.faction_manager.get_by_name(faction_name)
    final_approval = updated_faction.get('approval', 60)
    approval_change = final_approval - initial_approval

    print(f"  Final approval: {final_approval}")
    print(f"  Approval change: {approval_change:+d}")

    if approval_change > 0:
        print(f"‚úì PASS: Approval increased as expected")
        return True
    else:
        print(f"‚ùå FAIL: Expected approval increase, got {approval_change:+d}")
        return False


def test_wealth_goal_negative():
    """Test that factions with wealth goals lose approval when wealth decreases."""
    print("\n" + "=" * 60)
    print("TEST: Wealth Goal - Negative Outcome")
    print("=" * 60)

    # Create game state
    game_state = GameState()

    # Find a faction with wealth-related goals
    merchant_faction = None
    for faction in game_state.faction_manager.get_all():
        goals = [g.lower() for g in faction.get('goals', [])]
        if any('wealth' in g or 'trade' in g for g in goals):
            merchant_faction = faction
            break

    if not merchant_faction:
        print("‚ö†Ô∏è  SKIP: No faction with wealth goals found")
        return True

    faction_name = merchant_faction['name']
    initial_approval = merchant_faction.get('approval', 60)

    print(f"‚úì Testing faction: {faction_name}")
    print(f"  Initial approval: {initial_approval}")

    # Create outcome with wealth decrease
    outcome = {
        'updates': {
            'civilization.resources.wealth': -300
        },
        'narrative': 'Economic collapse devastated the markets.'
    }

    # Apply faction goal check
    _check_faction_goals(game_state, outcome, action='Failed economic policy', event_title='Economic Crisis')

    # Check if approval decreased
    updated_faction = game_state.faction_manager.get_by_name(faction_name)
    final_approval = updated_faction.get('approval', 60)
    approval_change = final_approval - initial_approval

    print(f"  Final approval: {final_approval}")
    print(f"  Approval change: {approval_change:+d}")

    if approval_change < 0:
        print(f"‚úì PASS: Approval decreased as expected")
        return True
    else:
        print(f"‚ùå FAIL: Expected approval decrease, got {approval_change:+d}")
        return False


def test_military_goal():
    """Test that factions with military goals react to military actions."""
    print("\n" + "=" * 60)
    print("TEST: Military Goal - Military Success")
    print("=" * 60)

    # Create game state
    game_state = GameState()

    # Find a faction with military-related goals (Warrior's Caste)
    warrior_faction = None
    for faction in game_state.faction_manager.get_all():
        goals = [g.lower() for g in faction.get('goals', [])]
        if any('military' in g or 'expand' in g or 'army' in g for g in goals):
            warrior_faction = faction
            break

    if not warrior_faction:
        print("‚ö†Ô∏è  SKIP: No faction with military goals found")
        return True

    faction_name = warrior_faction['name']
    initial_approval = warrior_faction.get('approval', 60)

    print(f"‚úì Testing faction: {faction_name}")
    print(f"  Initial approval: {initial_approval}")
    print(f"  Goals: {warrior_faction.get('goals', [])}")

    # Create outcome with military success
    outcome = {
        'updates': {
            'civilization.population': 150  # Population increase from conquest
        },
        'narrative': 'Victory! Our armies conquered the enemy settlement and brought glory to our people.'
    }

    # Apply faction goal check
    _check_faction_goals(
        game_state,
        outcome,
        action='Launch military conquest',
        event_title='Military Victory'
    )

    # Check if approval increased
    updated_faction = game_state.faction_manager.get_by_name(faction_name)
    final_approval = updated_faction.get('approval', 60)
    approval_change = final_approval - initial_approval

    print(f"  Final approval: {final_approval}")
    print(f"  Approval change: {approval_change:+d}")

    if approval_change > 0:
        print(f"‚úì PASS: Approval increased as expected")
        return True
    else:
        print(f"‚ùå FAIL: Expected approval increase, got {approval_change:+d}")
        return False


def test_stability_goal():
    """Test that factions with stability goals react to population changes."""
    print("\n" + "=" * 60)
    print("TEST: Stability Goal - Population Loss")
    print("=" * 60)

    # Create game state
    game_state = GameState()

    # Find a faction with stability-related goals (Elder Council)
    stability_faction = None
    for faction in game_state.faction_manager.get_all():
        goals = [g.lower() for g in faction.get('goals', [])]
        if any('stability' in g or 'tradition' in g or 'maintain' in g for g in goals):
            stability_faction = faction
            break

    if not stability_faction:
        print("‚ö†Ô∏è  SKIP: No faction with stability goals found")
        return True

    faction_name = stability_faction['name']
    initial_approval = stability_faction.get('approval', 60)

    print(f"‚úì Testing faction: {faction_name}")
    print(f"  Initial approval: {initial_approval}")
    print(f"  Goals: {stability_faction.get('goals', [])}")

    # Create outcome with population loss (instability)
    outcome = {
        'updates': {
            'civilization.population': -200
        },
        'narrative': 'Famine and disease ravaged the population, causing widespread suffering.'
    }

    # Apply faction goal check
    _check_faction_goals(game_state, outcome, action='Failed to prevent famine', event_title='Crisis')

    # Check if approval decreased
    updated_faction = game_state.faction_manager.get_by_name(faction_name)
    final_approval = updated_faction.get('approval', 60)
    approval_change = final_approval - initial_approval

    print(f"  Final approval: {final_approval}")
    print(f"  Approval change: {approval_change:+d}")

    if approval_change < 0:
        print(f"‚úì PASS: Approval decreased as expected")
        return True
    else:
        print(f"‚ùå FAIL: Expected approval decrease, got {approval_change:+d}")
        return False


def test_religious_goal():
    """Test that factions with religious goals react to religious developments."""
    print("\n" + "=" * 60)
    print("TEST: Religious Goal - Temple Construction")
    print("=" * 60)

    # Create game state
    game_state = GameState()

    # Find a faction with religious goals
    religious_faction = None
    for faction in game_state.faction_manager.get_all():
        goals = [g.lower() for g in faction.get('goals', [])]
        if any('temple' in g or 'faith' in g or 'divine' in g for g in goals):
            religious_faction = faction
            break

    if not religious_faction:
        print("‚ö†Ô∏è  SKIP: No faction with religious goals found")
        return True

    faction_name = religious_faction['name']
    initial_approval = religious_faction.get('approval', 60)

    print(f"‚úì Testing faction: {faction_name}")
    print(f"  Initial approval: {initial_approval}")
    print(f"  Goals: {religious_faction.get('goals', [])}")

    # Create outcome with temple construction
    outcome = {
        'updates': {
            'technology.infrastructure.append': 'Grand Temple'
        },
        'narrative': 'A magnificent temple was constructed, bringing glory to the gods.'
    }

    # Apply faction goal check
    _check_faction_goals(
        game_state,
        outcome,
        action='Construct a grand temple',
        event_title='Religious Construction'
    )

    # Check if approval increased
    updated_faction = game_state.faction_manager.get_by_name(faction_name)
    final_approval = updated_faction.get('approval', 60)
    approval_change = final_approval - initial_approval

    print(f"  Final approval: {final_approval}")
    print(f"  Approval change: {approval_change:+d}")

    if approval_change > 0:
        print(f"‚úì PASS: Approval increased as expected")
        return True
    else:
        print(f"‚ùå FAIL: Expected approval increase, got {approval_change:+d}")
        return False


def test_no_updates():
    """Test that faction goal check handles empty updates gracefully."""
    print("\n" + "=" * 60)
    print("TEST: No Updates - Graceful Handling")
    print("=" * 60)

    # Create game state
    game_state = GameState()

    # Create outcome with no updates
    outcome = {
        'updates': {},
        'narrative': 'Nothing happened.'
    }

    # Apply faction goal check (should return early)
    try:
        _check_faction_goals(game_state, outcome, action='Wait', event_title='No Event')
        print(f"‚úì PASS: Handled empty updates without error")
        return True
    except Exception as e:
        print(f"‚ùå FAIL: Error handling empty updates: {e}")
        return False


def test_history_entries():
    """Test that faction history entries are created."""
    print("\n" + "=" * 60)
    print("TEST: Faction History Entries Created")
    print("=" * 60)

    # Create game state
    game_state = GameState()

    # Find any faction
    faction = game_state.faction_manager.get_all()[0] if game_state.faction_manager.get_all() else None
    if not faction:
        print("‚ö†Ô∏è  SKIP: No factions available")
        return True

    faction_name = faction['name']
    initial_history_length = len(faction.get('history', []))

    print(f"‚úì Testing faction: {faction_name}")
    print(f"  Initial history entries: {initial_history_length}")

    # Create outcome that affects the faction
    outcome = {
        'updates': {
            'civilization.resources.wealth': 200
        },
        'narrative': 'Test event.'
    }

    # Apply faction goal check
    _check_faction_goals(game_state, outcome, action='Test action', event_title='Test Event')

    # Check if history entry was added
    updated_faction = game_state.faction_manager.get_by_name(faction_name)
    final_history_length = len(updated_faction.get('history', []))

    print(f"  Final history entries: {final_history_length}")

    if final_history_length > initial_history_length:
        print(f"‚úì PASS: History entry added")
        print(f"  Latest entry: {updated_faction['history'][-1]}")
        return True
    else:
        print(f"‚ö†Ô∏è  No history entry added (faction goals may not match outcome)")
        return True  # Not necessarily a failure


def run_all_tests():
    """Run all faction goal simulation tests."""
    print("\n" + "=" * 70)
    print("FACTION GOAL SIMULATION TEST SUITE")
    print("=" * 70)
    print("\nThese tests verify that factions react to turn outcomes based on")
    print("their goals, adjusting approval ratings when outcomes align with or")
    print("contradict their objectives.")
    print("=" * 70)

    tests = [
        ("Wealth Goal - Positive Outcome", test_wealth_goal_positive),
        ("Wealth Goal - Negative Outcome", test_wealth_goal_negative),
        ("Military Goal - Military Success", test_military_goal),
        ("Stability Goal - Population Loss", test_stability_goal),
        ("Religious Goal - Temple Construction", test_religious_goal),
        ("No Updates - Graceful Handling", test_no_updates),
        ("Faction History Entries Created", test_history_entries),
    ]

    results = []
    for test_name, test_func in tests:
        try:
            result = test_func()
            results.append((test_name, result))
        except Exception as e:
            print(f"\n‚ùå EXCEPTION in {test_name}: {e}")
            import traceback
            traceback.print_exc()
            results.append((test_name, False))

    # Summary
    print("\n" + "=" * 70)
    print("TEST SUMMARY")
    print("=" * 70)

    passed = sum(1 for _, result in results if result)
    total = len(results)

    for test_name, result in results:
        status = "‚úì PASS" if result else "‚ùå FAIL"
        print(f"{status}: {test_name}")

    print("=" * 70)
    print(f"Total: {passed}/{total} tests passed ({passed/total*100:.0f}%)")
    print("=" * 70)

    if passed == total:
        print("\nüéâ All tests passed!")
    elif passed > 0:
        print(f"\n‚ö†Ô∏è  Some tests failed. {total - passed} test(s) need attention.")
    else:
        print("\n‚ùå All tests failed. Please review the implementation.")

    return passed == total


if __name__ == "__main__":
    success = run_all_tests()
    sys.exit(0 if success else 1)



################################################################################
# FILE: old_codebase\test_faction_integration.py
# Size: 6658 bytes
################################################################################

"""
Integration test to verify faction decision consequences are triggered from event processing.
Tests the full integration in process_player_action().
"""

import sys
import os
import io

# Fix encoding for Windows console
if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8', errors='replace')

sys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))

from engines.faction_manager import FactionManager

class MockGameState:
    """Mock game state for integration testing"""
    def __init__(self):
        # Create faction manager
        self.faction_manager = FactionManager({
            "factions": [
                {
                    "id": "faction_merchants_guild_001",
                    "name": "The Merchant's Guild",
                    "approval": 60,
                },
                {
                    "id": "faction_warriors_caste_001",
                    "name": "The Warrior's Caste",
                    "approval": 60,
                },
                {
                    "id": "faction_priesthood_sun_001",
                    "name": "The Priesthood of the Sun",
                    "approval": 60,
                }
            ]
        })

        # Simulate a faction audience event
        self.current_event = {
            "event_type": "faction_audience",
            "title": "The Throne Room of Shifting Sands",
            "narrative": "Three faction representatives stand before you...",
            "petitions": [
                {
                    "faction": "The Merchant's Guild",
                    "demand": "We request reduced tariffs to expand trade routes."
                },
                {
                    "faction": "The Warrior's Caste",
                    "demand": "We demand greater military funding."
                },
                {
                    "faction": "The Priesthood of the Sun",
                    "demand": "We seek funds for a grand temple."
                }
            ],
            "decision_options": [
                "Side with the Merchant's Guild and reduce tariffs",
                "Side with the Warrior's Caste and increase military funding"
            ]
        }

def test_integration():
    """Test that the integration correctly detects and processes faction decisions"""
    print("=" * 70)
    print("INTEGRATION TEST: Faction Decision Detection and Processing")
    print("=" * 70)

    game_state = MockGameState()

    # Test 1: Check event_type detection
    print("\n--- TEST 1: Event Type Detection ---")
    has_event = hasattr(game_state, 'current_event')
    is_faction_event = game_state.current_event.get('event_type') == 'faction_audience'

    print(f"Has current_event attribute: {has_event}")
    print(f"Event type is 'faction_audience': {is_faction_event}")

    if has_event and is_faction_event:
        print("‚úì Event type detection working")
    else:
        print("‚úó Event type detection failed")
        return False

    # Test 2: Check faction name parsing from action
    print("\n--- TEST 2: Faction Name Parsing ---")
    test_action = "Side with the Merchant's Guild and reduce tariffs"
    petitions = game_state.current_event.get('petitions', [])

    # Simulate the parsing logic from event_engine.py
    chosen_faction = None
    for petition in petitions:
        faction_name = petition.get('faction', '')
        if faction_name.lower() in test_action.lower():
            chosen_faction = faction_name
            break

    print(f"Action: '{test_action}'")
    print(f"Parsed faction: '{chosen_faction}'")

    if chosen_faction == "The Merchant's Guild":
        print("‚úì Faction name parsing working")
    else:
        print(f"‚úó Faction name parsing failed (got '{chosen_faction}')")
        return False

    # Test 3: Check opposed factions identification
    print("\n--- TEST 3: Opposed Factions Identification ---")
    opposed_factions = [p.get('faction') for p in petitions if p.get('faction') != chosen_faction]

    print(f"Opposed factions: {opposed_factions}")
    expected_opposed = ["The Warrior's Caste", "The Priesthood of the Sun"]

    if set(opposed_factions) == set(expected_opposed):
        print("‚úì Opposed factions identification working")
    else:
        print(f"‚úó Opposed factions incorrect (expected {expected_opposed})")
        return False

    # Test 4: Verify initial state
    print("\n--- TEST 4: Initial Approval State ---")
    merchants = game_state.faction_manager.get_by_name("The Merchant's Guild")
    warriors = game_state.faction_manager.get_by_name("The Warrior's Caste")
    priesthood = game_state.faction_manager.get_by_name("The Priesthood of the Sun")

    print(f"Merchants: {merchants['approval']}")
    print(f"Warriors: {warriors['approval']}")
    print(f"Priesthood: {priesthood['approval']}")

    if merchants['approval'] == 60 and warriors['approval'] == 60 and priesthood['approval'] == 60:
        print("‚úì Initial state correct")
    else:
        print("‚úó Initial state incorrect")
        return False

    # Test 5: Apply consequences and verify
    print("\n--- TEST 5: Applying Consequences ---")
    from engines.faction_engine import apply_faction_decision_consequences
    apply_faction_decision_consequences(game_state, chosen_faction, opposed_factions)

    print(f"\nMerchants: {merchants['approval']} (expected: 80)")
    print(f"Warriors: {warriors['approval']} (expected: 20)")
    print(f"Priesthood: {priesthood['approval']} (expected: 20)")

    success = (
        merchants['approval'] == 80 and
        warriors['approval'] == 20 and
        priesthood['approval'] == 20
    )

    if success:
        print("‚úì Consequences applied correctly")
    else:
        print("‚úó Consequences not applied correctly")
        return False

    # All tests passed
    print("\n" + "=" * 70)
    print("ALL INTEGRATION TESTS PASSED")
    print("=" * 70)
    print("\nThe fix successfully:")
    print("  1. Detects faction_audience events")
    print("  2. Parses faction names from player actions")
    print("  3. Identifies opposed factions")
    print("  4. Applies asymmetric approval changes (+20/-40)")
    print("  5. Triggers conspiracy warnings when appropriate")
    return True

if __name__ == "__main__":
    success = test_integration()
    sys.exit(0 if success else 1)



################################################################################
# FILE: old_codebase\test_first_turn_briefing.py
# Size: 8180 bytes
################################################################################

"""
Test script for enhanced first turn briefing.
Verifies the new longer, more immersive opening event.
"""

import json
import sys
import io

# Fix encoding issues on Windows
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

from game_state import GameState
from engines.council_engine import generate_first_turn_briefing

def test_first_turn_briefing():
    print("=" * 80)
    print("TESTING ENHANCED FIRST TURN BRIEFING")
    print("=" * 80)

    # Load game state (or create fresh one)
    print("\n1. Loading/Creating Game State")
    print("-" * 80)
    try:
        game_state = GameState()
        # Reset to turn 0 to simulate first turn
        game_state.turn_number = 0
        print(f"‚úì Game state loaded successfully")
        print(f"  Civilization: {game_state.civilization.get('meta', {}).get('name', 'Unknown')}")
        print(f"  Leader: {game_state.civilization.get('leader', {}).get('name', 'Unknown')}")
        print(f"  Era: {game_state.civilization.get('meta', {}).get('era', 'Unknown')}")
    except Exception as e:
        print(f"‚úó Failed to load game state: {e}")
        return False

    print("\n2. Checking Inner Circle Advisors")
    print("-" * 80)
    if hasattr(game_state, 'inner_circle_manager'):
        advisors = game_state.inner_circle_manager.get_all()
        print(f"‚úì Found {len(advisors)} advisors:")
        for advisor in advisors:
            print(f"  - {advisor['name']} ({advisor['role']})")
            traits = advisor.get('personality_traits', [])
            if traits:
                print(f"    Personality: {', '.join(traits[:3])}")
    else:
        print("‚ö† No inner circle manager found")

    print("\n3. Generating First Turn Briefing")
    print("-" * 80)
    print("‚è≥ Calling Gemini API to generate opening event...")
    print("   This may take 10-20 seconds for the enhanced prompt...")

    try:
        briefing_data = generate_first_turn_briefing(game_state)
    except Exception as e:
        print(f"‚úó Failed to generate briefing: {e}")
        import traceback
        traceback.print_exc()
        return False

    if not briefing_data:
        print("‚úó Briefing generation returned None!")
        return False

    print("‚úì Briefing generated successfully!")

    print("\n4. Verifying JSON Structure")
    print("-" * 80)

    # Check required fields
    required_fields = ['title', 'narrative', 'state_of_realm', 'advisor_reports',
                      'pressing_matters', 'investigation_options', 'decision_options']
    missing_fields = []
    for field in required_fields:
        if field in briefing_data:
            print(f"‚úì '{field}' present")
        else:
            print(f"‚úó '{field}' MISSING!")
            missing_fields.append(field)

    if missing_fields:
        print(f"\n‚ö† Missing fields: {', '.join(missing_fields)}")
        print("   Note: 'state_of_realm' is a new field added in Phase 1")

    print("\n5. Analyzing Content Length and Quality")
    print("-" * 80)

    narrative = briefing_data.get('narrative', '')
    state_of_realm = briefing_data.get('state_of_realm', '')
    advisor_reports = briefing_data.get('advisor_reports', [])

    # Count sentences in narrative
    narrative_sentences = narrative.count('.') + narrative.count('!') + narrative.count('?')
    print(f"Narrative length:")
    print(f"  - Characters: {len(narrative)}")
    print(f"  - Sentences (approx): {narrative_sentences}")
    if narrative_sentences >= 12:
        print(f"  ‚úì Meets minimum 12 sentence target")
    else:
        print(f"  ‚ö† Below target of 12 sentences (got {narrative_sentences})")

    # Count sentences in state_of_realm
    if state_of_realm:
        realm_sentences = state_of_realm.count('.') + state_of_realm.count('!') + state_of_realm.count('?')
        print(f"\nState of Realm length:")
        print(f"  - Characters: {len(state_of_realm)}")
        print(f"  - Sentences (approx): {realm_sentences}")
        if realm_sentences >= 5:
            print(f"  ‚úì Meets minimum 5 sentence target")
        else:
            print(f"  ‚ö† Below target of 5 sentences (got {realm_sentences})")
    else:
        print(f"\n‚ö† State of Realm field is empty or missing")

    # Check advisor reports
    print(f"\nAdvisor Reports:")
    print(f"  - Count: {len(advisor_reports)}")
    if len(advisor_reports) >= 3:
        print(f"  ‚úì Has at least 3 advisor reports")
    else:
        print(f"  ‚ö† Expected at least 3 reports (got {len(advisor_reports)})")

    for i, report in enumerate(advisor_reports, 1):
        advisor_name = report.get('advisor_title', 'Unknown')
        summary = report.get('summary', '')
        summary_sentences = summary.count('.') + summary.count('!') + summary.count('?')
        print(f"  Report {i} ({advisor_name}):")
        print(f"    - Characters: {len(summary)}")
        print(f"    - Sentences: {summary_sentences}")
        if summary_sentences >= 2:
            print(f"    ‚úì Meets 2-3 sentence target")

    print("\n6. Displaying Full Opening Event")
    print("=" * 80)
    print(f"\nüìú {briefing_data.get('title', 'UNTITLED')}\n")
    print("‚îÄ" * 80)
    print("OPENING NARRATIVE:")
    print("‚îÄ" * 80)
    print(narrative)

    if state_of_realm:
        print("\n" + "‚îÄ" * 80)
        print("STATE OF THE REALM:")
        print("‚îÄ" * 80)
        print(state_of_realm)

    print("\n" + "‚îÄ" * 80)
    print("ADVISOR REPORTS:")
    print("‚îÄ" * 80)
    for report in advisor_reports:
        advisor_title = report.get('advisor_title', 'Unknown Advisor')
        summary = report.get('summary', 'No report available')
        print(f"\n{advisor_title}:")
        print(f'"{summary}"')

    print("\n" + "‚îÄ" * 80)
    print("PRESSING MATTERS:")
    print("‚îÄ" * 80)
    print(briefing_data.get('pressing_matters', 'No pressing matters listed'))

    print("\n" + "‚îÄ" * 80)
    print("YOUR OPTIONS:")
    print("‚îÄ" * 80)

    inv_options = briefing_data.get('investigation_options', [])
    print("\nInvestigation Options:")
    for i, option in enumerate(inv_options, 1):
        print(f"  {i}. {option}")

    dec_options = briefing_data.get('decision_options', [])
    print("\nDecision Options:")
    for i, option in enumerate(dec_options, 1):
        print(f"  {i}. {option}")

    print("\n" + "=" * 80)

    # Verify options
    print("\n7. Verifying Options Arrays")
    print("-" * 80)
    if len(inv_options) == 2:
        print(f"‚úì Investigation options: {len(inv_options)} (correct)")
    else:
        print(f"‚úó Investigation options: {len(inv_options)} (expected 2)")
        return False

    if len(dec_options) == 2:
        print(f"‚úì Decision options: {len(dec_options)} (correct)")
    else:
        print(f"‚úó Decision options: {len(dec_options)} (expected 2)")
        return False

    print("\n8. Complete JSON Output")
    print("-" * 80)
    print(json.dumps(briefing_data, indent=2, ensure_ascii=False))

    print("\n" + "=" * 80)
    print("‚úì FIRST TURN BRIEFING TEST COMPLETE!")
    print("=" * 80)

    # Summary stats
    total_length = len(narrative) + len(state_of_realm) + sum(len(r.get('summary', '')) for r in advisor_reports)
    print(f"\nüìä CONTENT STATISTICS:")
    print(f"  Total text length: {total_length:,} characters")
    print(f"  Narrative: {len(narrative):,} chars (~{narrative_sentences} sentences)")
    print(f"  State of Realm: {len(state_of_realm):,} chars")
    print(f"  Advisor Reports: {sum(len(r.get('summary', '')) for r in advisor_reports):,} chars")
    print(f"  Quality: {'‚úì ENHANCED' if narrative_sentences >= 12 else '‚ö† STANDARD'}")

    return True

if __name__ == "__main__":
    try:
        success = test_first_turn_briefing()
        exit(0 if success else 1)
    except Exception as e:
        print(f"\n‚úó TEST FAILED WITH ERROR:")
        print(f"  {e}")
        import traceback
        traceback.print_exc()
        exit(1)



################################################################################
# FILE: old_codebase\test_historical_mode.py
# Size: 5947 bytes
################################################################################

"""
Quick test script for historical_earth mode
"""

from world_generator import WorldGenerator
import json

def test_stone_age_generation():
    print("=" * 60)
    print("Testing Stone Age Historical Generation")
    print("=" * 60)

    generator = WorldGenerator()
    config = {
        "world_mode": "historical_earth",
        "starting_era": "stone_age",
        "earth_region": "mediterranean",
        "civilization_name": "The Mediterranean People",
        "population_size": "medium",
        "cultural_focus": "agricultural",
        "religion_type": "animism",
        "social_structure": "tribal_council",
        "difficulty": "balanced",
        "neighbor_count": "few",
        "resource_abundance": "moderate"
    }

    world_data = generator.generate_world(config)

    print("\n--- Civilization Info ---")
    print(f"Name: {world_data['civilization']['meta']['name']}")
    print(f"Year: {world_data['civilization']['meta']['year']}")
    print(f"Era: {world_data['civilization']['meta']['era']}")
    print(f"World Mode: {world_data['civilization']['meta']['world_mode']}")
    print(f"Region: {world_data['civilization']['meta']['earth_region']}")
    print(f"Butterfly Effects Enabled: {world_data['civilization']['meta']['butterfly_effects_enabled']}")
    print(f"Leader: {world_data['civilization']['leader']['name']}")
    print(f"Population: {world_data['civilization']['population']}")

    print("\n--- World Geography ---")
    print(f"Region: {world_data['world']['geography']['region']}")
    print(f"Terrain: {world_data['world']['geography']['terrain']}")
    print(f"Climate: {world_data['world']['geography']['climate']}")
    print(f"Resources: {', '.join(world_data['world']['geography']['resources'][:5])}")

    print("\n--- Factions ---")
    for faction in world_data['factions']['factions']:
        print(f"  - {faction['name']} (Leader: {faction['leader']})")

    print("\n--- Inner Circle ---")
    for member in world_data['inner_circle']['characters']:
        print(f"  - {member['name']} ({member['role']})")

    print("\n" + "=" * 60)
    print("Stone Age test PASSED!")
    print("=" * 60 + "\n")


def test_classical_generation():
    print("=" * 60)
    print("Testing Classical Era Historical Generation")
    print("=" * 60)

    generator = WorldGenerator()
    config = {
        "world_mode": "historical_earth",
        "starting_era": "classical",
        "earth_region": "mediterranean",
        "civilization_name": "Custom Name",  # Should be overridden
        "population_size": "large",
        "cultural_focus": "martial",
        "religion_type": "polytheism",
        "social_structure": "republic",
        "difficulty": "balanced",
        "neighbor_count": "several",
        "resource_abundance": "moderate"
    }

    world_data = generator.generate_world(config)

    print("\n--- Civilization Info ---")
    print(f"Name: {world_data['civilization']['meta']['name']}")
    print(f"Year: {world_data['civilization']['meta']['year']}")
    print(f"Era: {world_data['civilization']['meta']['era']}")
    print(f"World Mode: {world_data['civilization']['meta']['world_mode']}")
    print(f"Region: {world_data['civilization']['meta']['earth_region']}")
    print(f"Historical Factions Enabled: {world_data['civilization']['meta']['historical_factions_enabled']}")
    print(f"Leader: {world_data['civilization']['leader']['name']}")
    print(f"Population: {world_data['civilization']['population']}")

    print("\n--- Historical Factions ---")
    for faction in world_data['factions']['factions']:
        print(f"  - {faction['name']}")
        print(f"    Leader: {faction['leader']}")
        print(f"    Goals: {', '.join(faction['goals'][:2])}")

    print("\n--- Known Peoples (Neighbors) ---")
    for neighbor in world_data['world']['known_peoples']:
        print(f"  - {neighbor['name']} ({neighbor['relationship']})")

    print("\n" + "=" * 60)
    print("Classical Era test PASSED!")
    print("=" * 60 + "\n")


def test_fantasy_mode():
    print("=" * 60)
    print("Testing Fantasy Mode (Backward Compatibility)")
    print("=" * 60)

    generator = WorldGenerator()
    config = {
        "world_mode": "fantasy",
        "starting_era": "bronze_age",
        "terrain": "forest",
        "civilization_name": "The Forest Folk",
        "population_size": "medium",
        "cultural_focus": "spiritual",
        "religion_type": "animism",
        "social_structure": "egalitarian",
        "difficulty": "balanced",
        "neighbor_count": "few",
        "resource_abundance": "moderate"
    }

    world_data = generator.generate_world(config)

    print("\n--- Civilization Info ---")
    print(f"Name: {world_data['civilization']['meta']['name']}")
    print(f"Year: {world_data['civilization']['meta']['year']}")
    print(f"Era: {world_data['civilization']['meta']['era']}")
    print(f"World Mode: {world_data['civilization']['meta']['world_mode']}")
    print(f"Leader: {world_data['civilization']['leader']['name']}")

    print("\n--- World Geography ---")
    print(f"Terrain: {world_data['world']['geography']['terrain']}")
    print(f"Climate: {world_data['world']['geography']['climate']}")

    print("\n--- Factions ---")
    for faction in world_data['factions']['factions']:
        print(f"  - {faction['name']}")

    print("\n" + "=" * 60)
    print("Fantasy Mode test PASSED!")
    print("=" * 60 + "\n")


if __name__ == "__main__":
    try:
        test_stone_age_generation()
        test_classical_generation()
        test_fantasy_mode()

        print("\n" + "=" * 60)
        print("ALL TESTS PASSED! ‚úì")
        print("=" * 60)
    except Exception as e:
        print(f"\n‚ùå TEST FAILED: {e}")
        import traceback
        traceback.print_exc()



################################################################################
# FILE: old_codebase\test_image_updates.py
# Size: 5913 bytes
################################################################################

"""
Test script to verify image update logic works correctly.
Run this before playing to ensure the system is working.
"""

from engines.image_update_manager import (
    should_update_leader_portrait,
    should_update_settlement_image,
    get_tracker,
    reset_tracker
)


def test_portrait_updates():
    """Test leader portrait update detection logic."""
    print("\n=== Testing Leader Portrait Updates ===\n")

    # Reset tracker for clean test
    reset_tracker()
    tracker = get_tracker()

    # Mock game state
    game_state = {
        'civilization': {
            'leader': {
                'age': 25,
                'life_expectancy': 80,
                'traits': ['Brave', 'Warrior'],
            },
            'resources': {
                'wealth': 100
            }
        }
    }

    # Test 1: Initial generation
    should_update, reason = should_update_leader_portrait(game_state)
    print(f"Test 1 - Initial: {should_update} ({reason})")
    assert should_update, "Should update on first call"

    # Initialize tracker
    tracker.update_portrait_state(game_state)

    # Test 2: No changes (same turn)
    should_update, reason = should_update_leader_portrait(game_state)
    print(f"Test 2 - No changes: {should_update} ({reason})")
    assert not should_update, "Should not update immediately"

    # Test 3: After 10 turns
    for _ in range(10):
        tracker.increment_turns()
    should_update, reason = should_update_leader_portrait(game_state)
    print(f"Test 3 - After 10 turns: {should_update} ({reason})")
    assert should_update, "Should update after 10 turns"
    tracker.update_portrait_state(game_state)

    # Test 4: Age milestone (cross 20% threshold)
    game_state['civilization']['leader']['age'] = 16  # 20% of 80
    should_update, reason = should_update_leader_portrait(game_state)
    print(f"Test 4 - Age milestone (20%): {should_update} ({reason})")
    # Note: Won't trigger since we just updated, unless 10 turns passed

    # Test 5: Trait change
    aging_changes = ["Leader gained trait: Experienced"]
    should_update, reason = should_update_leader_portrait(game_state, aging_changes)
    print(f"Test 5 - Trait change: {should_update} ({reason})")
    assert should_update, "Should update on trait change"
    tracker.update_portrait_state(game_state)

    # Test 6: Wealth tier change
    game_state['civilization']['resources']['wealth'] = 600  # Move to "prosperous" tier
    should_update, reason = should_update_leader_portrait(game_state)
    print(f"Test 6 - Wealth change: {should_update} ({reason})")
    assert should_update, "Should update on wealth tier change"

    print("\n[PASS] All portrait update tests passed!\n")


def test_settlement_updates():
    """Test settlement image update detection logic."""
    print("\n=== Testing Settlement Image Updates ===\n")

    # Reset tracker for clean test
    reset_tracker()
    tracker = get_tracker()

    # Mock game state
    game_state = {
        'civilization': {
            'population': 50,
            'meta': {
                'era': 'stone_age'
            },
            'technology': {
                'infrastructure': ['Huts', 'Fire Pit']
            }
        }
    }

    # Test 1: Initial generation
    should_update, reason = should_update_settlement_image(game_state)
    print(f"Test 1 - Initial: {should_update} ({reason})")
    assert should_update, "Should update on first call"

    # Initialize tracker
    tracker.update_settlement_state(game_state)

    # Test 2: No changes
    should_update, reason = should_update_settlement_image(game_state)
    print(f"Test 2 - No changes: {should_update} ({reason})")
    assert not should_update, "Should not update with no changes"

    # Test 3: Population crosses size threshold (100 = village)
    game_state['civilization']['population'] = 150
    should_update, reason = should_update_settlement_image(game_state)
    print(f"Test 3 - Population growth (camp -> village): {should_update} ({reason})")
    assert should_update, "Should update when crossing size threshold"
    tracker.update_settlement_state(game_state)

    # Test 4: Era change
    game_state['civilization']['meta']['era'] = 'bronze_age'
    should_update, reason = should_update_settlement_image(game_state)
    print(f"Test 4 - Era change: {should_update} ({reason})")
    assert should_update, "Should update on era change"
    tracker.update_settlement_state(game_state)

    # Test 5: Major infrastructure
    game_state['civilization']['technology']['infrastructure'].append('Walls')
    should_update, reason = should_update_settlement_image(game_state)
    print(f"Test 5 - Major infrastructure (Walls): {should_update} ({reason})")
    assert should_update, "Should update for major infrastructure"
    tracker.update_settlement_state(game_state)

    # Test 6: Minor infrastructure (should NOT trigger)
    game_state['civilization']['technology']['infrastructure'].append('Granary')
    should_update, reason = should_update_settlement_image(game_state)
    print(f"Test 6 - Minor infrastructure (Granary): {should_update} ({reason})")
    assert not should_update, "Should NOT update for minor infrastructure"

    print("\n[PASS] All settlement update tests passed!\n")


if __name__ == "__main__":
    print("\n" + "="*60)
    print("IMAGE UPDATE SYSTEM TEST")
    print("="*60)

    try:
        test_portrait_updates()
        test_settlement_updates()

        print("\n" + "="*60)
        print("[SUCCESS] ALL TESTS PASSED!")
        print("="*60 + "\n")

    except AssertionError as e:
        print(f"\n[FAIL] TEST FAILED: {e}\n")
    except Exception as e:
        print(f"\n[ERROR] {e}\n")
        import traceback
        traceback.print_exc()



################################################################################
# FILE: old_codebase\test_inner_circle_generation.py
# Size: 6937 bytes
################################################################################

"""
Test script for Inner Circle generation system.
Tests the new culturally grounded name and personality generation.
"""

from world_generator import WorldGenerator
import json

def test_inner_circle_generation():
    """Test that inner circle members are generated with proper cultural grounding."""

    print("=" * 80)
    print("TESTING INNER CIRCLE GENERATION")
    print("=" * 80)

    generator = WorldGenerator()

    # Test different cultural focuses
    test_configs = [
        {
            "era": "bronze_age",
            "terrain": "forest",
            "civilization_name": "The Forest Tribes",
            "population_size": "medium",
            "leader_name": "",
            "cultural_focus": "martial",
            "religion_type": "animism",
            "social_structure": "tribal_council",
            "difficulty": "balanced",
            "neighbor_count": "few",
            "resource_abundance": "moderate"
        },
        {
            "era": "classical",
            "terrain": "coastal",
            "civilization_name": "The Trading Republic",
            "population_size": "large",
            "leader_name": "",
            "cultural_focus": "mercantile",
            "religion_type": "polytheism",
            "social_structure": "hierarchical",
            "difficulty": "balanced",
            "neighbor_count": "several",
            "resource_abundance": "abundant"
        },
        {
            "era": "iron_age",
            "terrain": "mountain",
            "civilization_name": "The Sacred Mountains",
            "population_size": "small",
            "leader_name": "",
            "cultural_focus": "spiritual",
            "religion_type": "ancestor_worship",
            "social_structure": "theocracy",
            "difficulty": "balanced",
            "neighbor_count": "few",
            "resource_abundance": "scarce"
        },
        {
            "era": "stone_age",
            "terrain": "plains",
            "civilization_name": "The Plains Wanderers",
            "population_size": "small",
            "leader_name": "",
            "cultural_focus": "agricultural",
            "religion_type": "nature_worship",
            "social_structure": "egalitarian",
            "difficulty": "balanced",
            "neighbor_count": "none",
            "resource_abundance": "moderate"
        }
    ]

    for i, config in enumerate(test_configs, 1):
        print(f"\n{'=' * 80}")
        print(f"TEST {i}: {config['civilization_name']} ({config['cultural_focus'].upper()} culture, {config['era'].upper()} era)")
        print('=' * 80)

        # Generate world
        world_data = generator.generate_world(config)

        # Display civilization info
        print(f"\nCivilization: {world_data['civilization']['meta']['name']}")
        print(f"Leader: {world_data['civilization']['leader']['name']}")
        print(f"Era: {world_data['civilization']['meta']['era']}")
        print(f"Cultural Focus: {config['cultural_focus']}")
        print(f"Population: {world_data['civilization']['population']}")

        # Display inner circle
        inner_circle = world_data['inner_circle']['characters']
        print(f"\n{'-' * 80}")
        print(f"INNER CIRCLE ({len(inner_circle)} members):")
        print('-' * 80)

        for char in inner_circle:
            print(f"\n  * {char['name']}")
            print(f"     Role: {char['role']}")
            print(f"     Faction: {char.get('faction_link', 'None')}")
            print(f"     Personality: {', '.join(char['personality_traits'])}")
            print(f"     Dialogue: \"{char['dialogue_sample']}\"")
            print(f"     Metrics: Loyalty={char['metrics']['loyalty']}, Influence={char['metrics']['influence']}, Relationship={char['metrics']['relationship']}")

        # Validate structure
        print(f"\n{'-' * 80}")
        print("VALIDATION:")
        print('-' * 80)

        all_valid = True

        # Check each character
        for char in inner_circle:
            # Check name is not a default hardcoded name
            if char['name'] in ['Seraphina Vane', 'General Kaelen', 'High Priestess Lyra']:
                print(f"  [X] FAIL: {char['name']} is a hardcoded default name!")
                all_valid = False
            else:
                print(f"  [OK] {char['name']} has unique generated name")

            # Check role is era-appropriate
            expected_roles = {
                'stone_age': ['War Chief', 'Scout Master', 'Shaman'],
                'bronze_age': ['Commander', 'Eyes of the Throne', 'High Priest'],
                'iron_age': ['Grand Marshal', 'Spymaster', 'High Priestess'],
                'classical': ['Strategos', 'Master of Whispers', 'Hierophant']
            }

            era = world_data['civilization']['meta']['era']
            if char['role'] in expected_roles.get(era, []):
                print(f"  [OK] {char['role']} is appropriate for {era} era")

            # Check personality traits are not generic defaults
            default_traits = [
                ["Pragmatic", "Cunning", "Discreet", "Ambitious"],
                ["Disciplined", "Direct", "Loyal", "Stern"],
                ["Pious", "Compassionate", "Traditionalist", "Serene"]
            ]

            if char['personality_traits'] not in default_traits:
                print(f"  [OK] {char['name']} has culturally-influenced traits: {', '.join(char['personality_traits'])}")

            # Check dialogue is not default
            default_dialogues = [
                "Information is a currency more valuable than gold, my lord.",
                "A strong army is the only true guarantee of peace.",
                "May the Sun's light guide your decisions and illuminate your path."
            ]

            if char['dialogue_sample'] not in default_dialogues:
                print(f"  [OK] {char['name']} has culturally-appropriate dialogue")
            else:
                print(f"  [WARN]  {char['name']} has default dialogue")

        if all_valid:
            print(f"\n  [PASS] TEST {i} PASSED: Inner circle properly generated!")
        else:
            print(f"\n  [FAIL] TEST {i} FAILED: Issues detected")

    print(f"\n{'=' * 80}")
    print("ALL TESTS COMPLETED")
    print('=' * 80)
    print("\nSummary:")
    print("- Inner circle names are now culturally grounded and unique")
    print("- Personalities reflect both role and cultural focus")
    print("- Dialogue is contextual to culture and role")
    print("- Era-appropriate role titles are used")
    print("- Faction links are established where possible")
    print("\n[SUCCESS] Inner circle system is now dynamic and culturally aware!")

if __name__ == "__main__":
    test_inner_circle_generation()



################################################################################
# FILE: old_codebase\test_state_validation.py
# Size: 4341 bytes
################################################################################

#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""Test script to verify state validation catches invalid AI updates."""

import sys
import io

# Force UTF-8 encoding for Windows console
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace')

from game_state import GameState
from engines.state_validator import validate_updates

def test_invalid_updates():
    """Test that the validator properly rejects invalid update paths."""
    print("=" * 70)
    print("Testing State Validation - Invalid Updates")
    print("=" * 70)

    # Load game state
    game = GameState()

    # Test cases that should FAIL validation (these are the bugs we're fixing)
    invalid_test_cases = [
        {
            "name": "Invalid append - religion.traditions (doesn't exist in schema)",
            "updates": {"religion.traditions.append": "New Tradition"}
        },
        {
            "name": "Invalid append - religion.beliefs (doesn't exist in schema)",
            "updates": {"religion.beliefs.append": "Core Belief"}
        },
        {
            "name": "Invalid root key - narrative",
            "updates": {"narrative.append": "Some story"}
        },
        {
            "name": "Creating arbitrary civilization key",
            "updates": {"civilization.scouts_dispatched": 5}
        },
        {
            "name": "Wrong root key - population",
            "updates": {"population.change": 100}
        },
        {
            "name": "Wrong root key - food",
            "updates": {"food.change": -50}
        }
    ]

    print("\n[TEST 1] Invalid Updates (should all be REJECTED):\n")
    all_rejected = True
    for test in invalid_test_cases:
        is_valid, cleaned, errors = validate_updates(test["updates"], game)

        if is_valid or len(errors) == 0:
            print(f"  ‚ùå FAILED: {test['name']}")
            print(f"     Expected rejection but validation passed!")
            all_rejected = False
        else:
            print(f"  ‚úÖ PASS: {test['name']}")
            print(f"     Error: {errors[0]}")

    # Test cases that should PASS validation
    valid_test_cases = [
        {
            "name": "Valid append - culture.traditions",
            "updates": {"culture.traditions.append": "Harvest Festival"}
        },
        {
            "name": "Valid append - religion.practices",
            "updates": {"religion.practices.append": "Lunar Worship"}
        },
        {
            "name": "Valid append - religion.core_tenets",
            "updates": {"religion.core_tenets.append": "Honor the Ancestors"}
        },
        {
            "name": "Valid append - religion.holy_sites",
            "updates": {"religion.holy_sites.append": "Sacred Grove"}
        },
        {
            "name": "Valid append - technology.discoveries",
            "updates": {"technology.discoveries.append": "Bronze Working"}
        },
        {
            "name": "Valid update - civilization.population",
            "updates": {"civilization.population": -50}
        },
        {
            "name": "Valid update - civilization.resources.food",
            "updates": {"civilization.resources.food": 100}
        },
        {
            "name": "Valid update - civilization.resources.wealth",
            "updates": {"civilization.resources.wealth": -200}
        }
    ]

    print("\n[TEST 2] Valid Updates (should all be ACCEPTED):\n")
    all_accepted = True
    for test in valid_test_cases:
        is_valid, cleaned, errors = validate_updates(test["updates"], game)

        if not is_valid or len(errors) > 0:
            print(f"  ‚ùå FAILED: {test['name']}")
            print(f"     Expected acceptance but got errors: {errors}")
            all_accepted = False
        else:
            print(f"  ‚úÖ PASS: {test['name']}")

    print("\n" + "=" * 70)
    if all_rejected and all_accepted:
        print("‚úÖ ALL TESTS PASSED - Validation is working correctly!")
        print("=" * 70)
        return True
    else:
        print("‚ùå SOME TESTS FAILED - Validation needs fixes")
        print("=" * 70)
        return False

if __name__ == '__main__':
    success = test_invalid_updates()
    sys.exit(0 if success else 1)



################################################################################
# FILE: old_codebase\test_succession_crisis.py
# Size: 6841 bytes
################################################################################

"""
Test succession crisis system to verify trigger_succession_crisis() is properly wired.
"""

import sys
import os

# Fix Windows encoding issues
if sys.platform == 'win32':
    import io
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

sys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))

from game_state import GameState
from engines.leader_engine import trigger_succession_crisis
from engines.crisis_engine import detect_crisis, generate_crisis_event

def test_trigger_succession_crisis():
    """Test that trigger_succession_crisis generates faction-backed candidates"""
    print("\n=== TEST 1: trigger_succession_crisis() generates faction-backed candidates ===")

    game = GameState()

    # Test trigger_succession_crisis
    succession_data = trigger_succession_crisis(game)

    print(f"\n‚úì Event type: {succession_data.get('event_type')}")
    print(f"‚úì Number of candidates: {len(succession_data.get('candidates', []))}")
    print(f"‚úì Transition crisis duration: {succession_data.get('transition_crisis_duration')} turns")
    print(f"‚úì Rival claimant chance: {succession_data.get('rival_claimant_chance')*100}%")

    # Check each candidate has faction backing
    print("\n‚úì Candidates:")
    for i, candidate in enumerate(succession_data.get('candidates', [])):
        print(f"\n  Candidate {i+1}: {candidate['name']}")
        print(f"    Archetype: {candidate['archetype']}")
        print(f"    Traits: {', '.join(candidate['traits'])}")
        print(f"    Backing faction: {candidate['backing_faction']}")
        print(f"    Backing faction ID: {candidate['backing_faction_id']}")
        print(f"    Demands: {candidate['demands']}")
        print(f"    Approval changes: {candidate['approval_changes']}")

        # Verify required fields
        assert 'name' in candidate, "Candidate missing name"
        assert 'archetype' in candidate, "Candidate missing archetype"
        assert 'traits' in candidate, "Candidate missing traits"
        assert 'backing_faction' in candidate, "Candidate missing backing_faction"
        assert 'backing_faction_id' in candidate, "Candidate missing backing_faction_id"
        assert 'demands' in candidate, "Candidate missing demands"
        assert 'approval_changes' in candidate, "Candidate missing approval_changes"

    print("\n‚úÖ TEST PASSED: trigger_succession_crisis() generates proper faction-backed candidates")
    return True

def test_crisis_engine_succession():
    """Test that crisis engine properly detects and generates succession crisis"""
    print("\n=== TEST 2: Crisis engine detects succession crisis ===")

    game = GameState()

    # Force leader to be very old
    leader = game.civilization['leader']
    leader['age'] = leader.get('life_expectancy', 60) + 15  # Well past life expectancy

    print(f"\n‚úì Leader age: {leader['age']}")
    print(f"‚úì Life expectancy: {leader.get('life_expectancy', 60)}")

    # Detect crisis
    crisis_type = detect_crisis(game)
    print(f"\n‚úì Detected crisis type: {crisis_type}")

    assert crisis_type == 'succession_crisis', f"Expected 'succession_crisis', got '{crisis_type}'"

    # Generate crisis event
    crisis_event = generate_crisis_event(game, crisis_type)

    print(f"\n‚úì Crisis event title: {crisis_event.get('title')}")
    print(f"‚úì Is crisis: {crisis_event.get('is_crisis')}")
    print(f"‚úì Crisis type: {crisis_event.get('crisis_type')}")
    print(f"‚úì Has succession_data: {'succession_data' in crisis_event}")

    # Verify succession data is present
    assert 'succession_data' in crisis_event, "Crisis event missing succession_data"
    succession_data = crisis_event['succession_data']

    print(f"\n‚úì Succession data present with {len(succession_data.get('candidates', []))} candidates")

    # Check first candidate
    if succession_data.get('candidates'):
        first_candidate = succession_data['candidates'][0]
        print(f"\n‚úì First candidate: {first_candidate['name']} ({first_candidate['archetype']})")
        print(f"  Backed by: {first_candidate['backing_faction']}")
        print(f"  Demands: {first_candidate['demands']}")

    print("\n‚úÖ TEST PASSED: Crisis engine properly handles succession crisis")
    return True

def test_old_function_deprecated():
    """Verify that generate_successor_candidates is not used in main routes"""
    print("\n=== TEST 3: Verify old function is not used ===")

    with open('main.py', 'r', encoding='utf-8') as f:
        main_content = f.read()

    # Check that /api/die uses trigger_succession_crisis
    assert 'trigger_succession_crisis' in main_content, "main.py should import trigger_succession_crisis"

    # Check handle_death function
    handle_death_start = main_content.find("@app.route('/api/die'")
    handle_death_end = main_content.find("@app.route", handle_death_start + 1)
    handle_death_code = main_content[handle_death_start:handle_death_end]

    assert 'trigger_succession_crisis(game)' in handle_death_code, "/api/die should call trigger_succession_crisis()"

    # Check choose_successor function
    choose_successor_start = main_content.find("@app.route('/api/choose_successor'")
    choose_successor_end = main_content.find("@app.route", choose_successor_start + 1)
    if choose_successor_end == -1:
        choose_successor_end = len(main_content)
    choose_successor_code = main_content[choose_successor_start:choose_successor_end]

    assert 'trigger_succession_crisis' in choose_successor_code, "/api/choose_successor should use trigger_succession_crisis()"

    print("\n‚úì main.py properly uses trigger_succession_crisis() in /api/die")
    print("‚úì main.py properly uses trigger_succession_crisis() in /api/choose_successor")
    print("\n‚úÖ TEST PASSED: Old function is properly deprecated")
    return True

def run_all_tests():
    """Run all succession crisis tests"""
    print("\n" + "="*80)
    print("TESTING SUCCESSION CRISIS SYSTEM")
    print("="*80)

    tests = [
        test_trigger_succession_crisis,
        test_crisis_engine_succession,
        test_old_function_deprecated
    ]

    passed = 0
    failed = 0

    for test in tests:
        try:
            if test():
                passed += 1
        except Exception as e:
            print(f"\n‚ùå TEST FAILED: {test.__name__}")
            print(f"   Error: {e}")
            import traceback
            traceback.print_exc()
            failed += 1

    print("\n" + "="*80)
    print(f"RESULTS: {passed} passed, {failed} failed")
    print("="*80)

    return failed == 0

if __name__ == '__main__':
    success = run_all_tests()
    sys.exit(0 if success else 1)



################################################################################
# FILE: old_codebase\test_systems.py
# Size: 12976 bytes
################################################################################

#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Comprehensive test script for Phase 1 & Phase 2 systems.
Tests all new features without breaking existing functionality.
"""

import sys
import os
import io

# Force UTF-8 encoding for Windows
if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

# Add parent directory to path
sys.path.insert(0, os.path.dirname(__file__))

def test_imports():
    """Test that all modules import correctly."""
    print("=" * 60)
    print("TESTING IMPORTS")
    print("=" * 60)

    try:
        print("‚úì Importing game_state...")
        from game_state import GameState

        print("‚úì Importing resource_engine...")
        from engines.resource_engine import (
            calculate_consumption, apply_consumption,
            generate_resource_production, apply_passive_generation
        )

        print("‚úì Importing crisis_engine...")
        from engines.crisis_engine import (
            detect_crisis, generate_crisis_event, should_generate_crisis
        )

        print("‚úì Importing consequence_engine...")
        from engines.consequence_engine import (
            initialize_consequences, analyze_action_for_consequences,
            apply_consequences, get_consequence_context
        )

        print("‚úì Importing callback_engine...")
        from engines.callback_engine import generate_callback_event

        print("‚úì Importing victory_engine...")
        from engines.victory_engine import (
            initialize_victory_tracking, calculate_victory_progress,
            check_victory, check_failure
        )

        print("‚úì Importing leader_engine...")
        from engines.leader_engine import (
            TRAIT_EFFECTS, get_trait_bonus, apply_aging_effects,
            calculate_leader_effectiveness, generate_successor_candidates
        )

        print("\n‚úÖ All imports successful!\n")
        return True

    except Exception as e:
        print(f"\n‚ùå Import failed: {e}\n")
        import traceback
        traceback.print_exc()
        return False

def test_game_state_load():
    """Test that game state loads correctly."""
    print("=" * 60)
    print("TESTING GAME STATE LOAD")
    print("=" * 60)

    try:
        from game_state import GameState

        print("‚úì Loading game state...")
        game = GameState()

        print("‚úì Checking civilization data...")
        assert 'meta' in game.civilization
        assert 'leader' in game.civilization
        assert 'population' in game.civilization

        print("‚úì Checking leader data...")
        leader = game.civilization['leader']
        assert 'name' in leader
        assert 'age' in leader
        assert 'traits' in leader  # Should be auto-added if missing

        print("‚úì Checking new systems initialized...")
        assert 'consequences' in game.civilization  # Should be auto-initialized
        assert 'victory_progress' in game.civilization  # Should be auto-initialized

        print(f"\n‚úì Leader: {leader['name']}, Age {leader['age']}")
        print(f"‚úì Traits: {', '.join(leader['traits'])}")
        print(f"‚úì Population: {game.civilization['population']}")

        print("\n‚úÖ Game state load successful!\n")
        return game

    except Exception as e:
        print(f"\n‚ùå Game state load failed: {e}\n")
        import traceback
        traceback.print_exc()
        return None

def test_resource_system(game):
    """Test resource consumption and production."""
    print("=" * 60)
    print("TESTING RESOURCE SYSTEM")
    print("=" * 60)

    try:
        from engines.resource_engine import (
            calculate_consumption, apply_consumption,
            generate_resource_production, apply_passive_generation
        )

        print("‚úì Testing consumption calculation...")
        consumption = calculate_consumption(game)
        print(f"  Food consumption: {consumption['food']}")
        print(f"  Wealth consumption: {consumption['wealth']}")

        print("\n‚úì Testing production calculation...")
        production = generate_resource_production(game)
        print(f"  Base food production: {production['food']}")
        print(f"  Base wealth production: {production['wealth']}")

        print("\n‚úì Testing passive generation with leader bonus...")
        old_food = game.civilization['resources']['food']
        result = apply_passive_generation(game)
        print(f"  Leader effectiveness: {result.get('effectiveness', 1.0):.2f}x")
        print(f"  Final food production: {result['food']}")
        print(f"  Final wealth production: {result['wealth']}")

        # Restore old value
        game.civilization['resources']['food'] = old_food

        print("\n‚úÖ Resource system working!\n")
        return True

    except Exception as e:
        print(f"\n‚ùå Resource system test failed: {e}\n")
        import traceback
        traceback.print_exc()
        return False

def test_crisis_detection(game):
    """Test crisis detection."""
    print("=" * 60)
    print("TESTING CRISIS DETECTION")
    print("=" * 60)

    try:
        from engines.crisis_engine import detect_crisis, should_generate_crisis

        print("‚úì Testing crisis detection...")
        crisis_type = detect_crisis(game)

        if crisis_type:
            print(f"  ‚ö†Ô∏è Crisis detected: {crisis_type}")
        else:
            print(f"  ‚úì No crisis (resources are healthy)")

        print("\n‚úì Testing crisis probability...")
        should_crisis, crisis_type = should_generate_crisis(game)

        if should_crisis:
            print(f"  ‚ö†Ô∏è Crisis event should trigger: {crisis_type}")
        else:
            print(f"  ‚úì No crisis event")

        print("\n‚úÖ Crisis detection working!\n")
        return True

    except Exception as e:
        print(f"\n‚ùå Crisis detection failed: {e}\n")
        import traceback
        traceback.print_exc()
        return False

def test_consequence_system(game):
    """Test consequence tracking."""
    print("=" * 60)
    print("TESTING CONSEQUENCE SYSTEM")
    print("=" * 60)

    try:
        from engines.consequence_engine import (
            initialize_consequences, analyze_action_for_consequences,
            get_consequence_context
        )

        print("‚úì Initializing consequences...")
        initialize_consequences(game)

        print("‚úì Testing promise detection...")
        action = "I promise to help the neighboring tribe"
        detected = analyze_action_for_consequences(action, "Test Event", "outcome")

        if detected['promises']:
            print(f"  ‚úì Promise detected: {detected['promises'][0]['text'][:50]}...")

        print("\n‚úì Testing alliance detection...")
        action = "We form an alliance with the Mountain Clan"
        detected = analyze_action_for_consequences(action, "Alliance Event", "outcome")

        if detected['alliances']:
            print(f"  ‚úì Alliance detected: {detected['alliances'][0]['name']}")

        print("\n‚úì Getting consequence context...")
        context = get_consequence_context(game)
        print(f"  Context:\n{context}")

        print("\n‚úÖ Consequence system working!\n")
        return True

    except Exception as e:
        print(f"\n‚ùå Consequence system test failed: {e}\n")
        import traceback
        traceback.print_exc()
        return False

def test_victory_system(game):
    """Test victory/failure detection."""
    print("=" * 60)
    print("TESTING VICTORY/FAILURE SYSTEM")
    print("=" * 60)

    try:
        from engines.victory_engine import (
            calculate_victory_progress, check_victory, check_failure,
            get_victory_status_summary
        )

        print("‚úì Calculating victory progress...")
        progress = calculate_victory_progress(game)

        for victory_type, score in progress.items():
            print(f"  {victory_type.capitalize()}: {score}/100")

        print("\n‚úì Checking for victory...")
        is_victory, victory_type, victory_desc = check_victory(game)

        if is_victory:
            print(f"  üèÜ VICTORY: {victory_type}")
        else:
            print(f"  ‚úì No victory yet (highest: {max(progress.values())}/100)")

        print("\n‚úì Checking for failure...")
        is_failed, failure_type, failure_desc = check_failure(game)

        if is_failed:
            print(f"  üíÄ FAILURE: {failure_type}")
        else:
            print(f"  ‚úì No failure conditions met")

        print("\n‚úì Getting victory status summary...")
        status = get_victory_status_summary(game)
        print(f"  Closest to victory: {status['closest_victory']} ({status['closest_progress']}/100)")

        print("\n‚úÖ Victory/failure system working!\n")
        return True

    except Exception as e:
        print(f"\n‚ùå Victory/failure test failed: {e}\n")
        import traceback
        traceback.print_exc()
        return False

def test_leader_system(game):
    """Test leader mechanics."""
    print("=" * 60)
    print("TESTING LEADER SYSTEM")
    print("=" * 60)

    try:
        from engines.leader_engine import (
            get_trait_bonus, apply_aging_effects,
            calculate_leader_effectiveness, generate_successor_candidates,
            TRAIT_EFFECTS
        )

        leader = game.civilization['leader']

        print(f"‚úì Current leader: {leader['name']}, Age {leader['age']}")
        print(f"  Traits: {', '.join(leader.get('traits', []))}")

        print("\n‚úì Testing trait bonuses...")
        for trait in leader.get('traits', []):
            trait_data = TRAIT_EFFECTS.get(trait, {})
            if trait_data:
                print(f"  {trait}: {trait_data['description']}")
                bonuses = trait_data.get('bonuses', {})
                for bonus_type, value in bonuses.items():
                    print(f"    - {bonus_type}: +{value}")

        print("\n‚úì Testing leader effectiveness...")
        effectiveness = calculate_leader_effectiveness(leader)
        print(f"  Effectiveness: {effectiveness:.2f}x")

        print("\n‚úì Testing aging effects...")
        old_traits = leader.get('traits', []).copy()
        aging_changes = apply_aging_effects(game)

        if aging_changes:
            print(f"  Changes: {', '.join(aging_changes)}")
        else:
            print(f"  No aging changes (leader not at milestone)")

        # Restore traits
        leader['traits'] = old_traits

        print("\n‚úì Testing successor generation...")
        candidates = generate_successor_candidates(game)

        print(f"  Generated {len(candidates)} candidates:")
        for i, candidate in enumerate(candidates, 1):
            print(f"    {i}. {candidate['name']} ({candidate['type']})")
            print(f"       Age {candidate['age']}, Traits: {', '.join(candidate['traits'])}")

        print("\n‚úÖ Leader system working!\n")
        return True

    except Exception as e:
        print(f"\n‚ùå Leader system test failed: {e}\n")
        import traceback
        traceback.print_exc()
        return False

def main():
    """Run all tests."""
    print("\n" + "=" * 60)
    print("CIVILIZATION GAME - COMPREHENSIVE SYSTEM TEST")
    print("=" * 60 + "\n")

    # Test 1: Imports
    if not test_imports():
        print("‚ùå FATAL: Import test failed. Cannot continue.")
        return False

    # Test 2: Game State Load
    game = test_game_state_load()
    if not game:
        print("‚ùå FATAL: Game state load failed. Cannot continue.")
        return False

    # Test 3: Resource System
    if not test_resource_system(game):
        print("‚ö†Ô∏è WARNING: Resource system test failed.")

    # Test 4: Crisis Detection
    if not test_crisis_detection(game):
        print("‚ö†Ô∏è WARNING: Crisis detection test failed.")

    # Test 5: Consequence System
    if not test_consequence_system(game):
        print("‚ö†Ô∏è WARNING: Consequence system test failed.")

    # Test 6: Victory/Failure System
    if not test_victory_system(game):
        print("‚ö†Ô∏è WARNING: Victory/failure system test failed.")

    # Test 7: Leader System
    if not test_leader_system(game):
        print("‚ö†Ô∏è WARNING: Leader system test failed.")

    print("\n" + "=" * 60)
    print("‚úÖ ALL CORE TESTS PASSED!")
    print("=" * 60)
    print("\nThe game should run smoothly. Start with:")
    print("  python main.py")
    print("\nThen visit: http://127.0.0.1:5000")
    print("=" * 60 + "\n")

    return True

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)



################################################################################
# FILE: old_codebase\test_validation.py
# Size: 2541 bytes
################################################################################

#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""Test script to verify the data validation system works correctly."""

import sys
import io

# Force UTF-8 encoding for Windows console
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace')

from game_state import GameState
from engines.data_validator import validate_faction_references, validate_all

def main():
    print("=" * 60)
    print("Testing Data Validation System")
    print("=" * 60)

    try:
        # Load game state
        print("\n[1] Loading game state...")
        game = GameState()
        print("    SUCCESS: Game state loaded")

        # Check factions structure
        print("\n[2] Checking factions data...")
        if isinstance(game.factions, dict):
            factions_list = game.factions.get('factions', [])
        elif isinstance(game.factions, list):
            factions_list = game.factions
        else:
            print("    ERROR: Invalid factions structure")
            return False

        print(f"    Found {len(factions_list)} factions")

        # Verify faction IDs exist
        faction_ids = [f.get('id') for f in factions_list if f.get('id')]
        print(f"    Factions with IDs: {len(faction_ids)}")
        for faction in factions_list:
            print(f"      - {faction.get('name')}: {faction.get('id', 'NO ID')}")

        # Check inner circle
        print("\n[3] Checking inner circle data...")
        print(f"    Found {len(game.inner_circle)} characters")
        for char in game.inner_circle:
            faction_link = char.get('faction_link', 'N/A')
            faction_id = char.get('faction_id', 'NO ID')
            print(f"      - {char.get('name')}: {faction_link} -> {faction_id}")

        # Run validation
        print("\n[4] Running validation checks...")
        validation_result = validate_all(game)

        if validation_result['valid']:
            print("    SUCCESS: All validation checks passed!")
        else:
            print("    WARNINGS FOUND:")
            for error in validation_result['errors']:
                print(f"      - {error}")

        print("\n" + "=" * 60)
        print("Test completed successfully!")
        print("=" * 60)
        return True

    except Exception as e:
        print(f"\n    ERROR: {e}")
        import traceback
        traceback.print_exc()
        return False

if __name__ == '__main__':
    success = main()
    sys.exit(0 if success else 1)



################################################################################
# FILE: old_codebase\test_visual_system.py
# Size: 6761 bytes
################################################################################

#!/usr/bin/env python
"""
Test script for visual generation system.
Tests all three visual features without requiring game state.
"""

import os
from dotenv import load_dotenv

# Load environment
load_dotenv()

def test_imports():
    """Test that all modules import correctly."""
    print("=" * 60)
    print("TEST 1: Module Imports")
    print("=" * 60)

    try:
        from engines.visual_engine import (
            generate_leader_portrait,
            generate_crisis_illustration,
            generate_settlement_evolution,
            get_settlement_gallery
        )
        print("[PASS] All visual engine functions imported")
    except Exception as e:
        print(f"[FAIL] Import error: {e}")
        return False

    try:
        from model_config import VISUAL_MODEL
        print(f"[PASS] Visual model configured: {VISUAL_MODEL}")
    except Exception as e:
        print(f"[FAIL] Model config error: {e}")
        return False

    return True


def test_api_key():
    """Test that API key is configured."""
    print("\n" + "=" * 60)
    print("TEST 2: API Key Configuration")
    print("=" * 60)

    api_key = os.getenv("GEMINI_API_KEY")
    if not api_key:
        print("[FAIL] GEMINI_API_KEY not found in environment")
        return False

    print(f"[PASS] API key configured: {api_key[:10]}...")
    return True


def test_directories():
    """Test that image directories exist."""
    print("\n" + "=" * 60)
    print("TEST 3: Directory Structure")
    print("=" * 60)

    dirs = [
        "static/images/leaders",
        "static/images/crises",
        "static/images/settlements"
    ]

    all_exist = True
    for dir_path in dirs:
        if os.path.exists(dir_path):
            print(f"[PASS] {dir_path} exists")
        else:
            print(f"[FAIL] {dir_path} missing")
            all_exist = False

    return all_exist


def test_leader_portrait_generation():
    """Test leader portrait generation (dry run - won't actually call API unless requested)."""
    print("\n" + "=" * 60)
    print("TEST 4: Leader Portrait Function")
    print("=" * 60)

    try:
        from engines.visual_engine import generate_leader_portrait

        # Mock leader data
        leader = {
            'name': 'Test Leader',
            'age': 35,
            'traits': ['Wise', 'Charismatic'],
            'role': 'Chieftain'
        }

        civ_context = {
            'era': 'iron_age',
            'culture_values': ['Honor', 'Courage']
        }

        print("[PASS] Leader portrait function callable")
        print(f"  - Would generate portrait for: {leader['name']}")
        print(f"  - Era: {civ_context['era']}")
        print(f"  - Traits: {', '.join(leader['traits'])}")

        return True
    except Exception as e:
        print(f"[FAIL] {e}")
        return False


def test_crisis_illustration_function():
    """Test crisis illustration function."""
    print("\n" + "=" * 60)
    print("TEST 5: Crisis Illustration Function")
    print("=" * 60)

    try:
        from engines.visual_engine import generate_crisis_illustration

        civ_context = {
            'era': 'classical',
            'name': 'Test Civilization',
            'terrain': 'plains'
        }

        print("[PASS] Crisis illustration function callable")
        print(f"  - Crisis types: famine, economic_collapse, succession_crisis")
        print(f"  - Era: {civ_context['era']}")

        return True
    except Exception as e:
        print(f"[FAIL] {e}")
        return False


def test_settlement_evolution_function():
    """Test settlement evolution function."""
    print("\n" + "=" * 60)
    print("TEST 6: Settlement Evolution Function")
    print("=" * 60)

    try:
        from engines.visual_engine import generate_settlement_evolution

        print("[PASS] Settlement evolution function callable")
        print(f"  - Tracks civilization progress over time")
        print(f"  - Auto-cleanup keeps last 5 settlements")

        return True
    except Exception as e:
        print(f"[FAIL] {e}")
        return False


def run_live_test():
    """Optional: Run actual API test (costs money)."""
    print("\n" + "=" * 60)
    print("OPTIONAL: Live API Test")
    print("=" * 60)

    response = input("\nRun live API test? This will generate 1 leader portrait (~$0.04). (y/N): ")

    if response.lower() != 'y':
        print("[SKIP] Live API test skipped")
        return True

    try:
        from engines.visual_engine import generate_leader_portrait

        print("\nGenerating test leader portrait...")

        leader = {
            'name': 'Aldric the Wise',
            'age': 45,
            'traits': ['Wise', 'Scholar'],
            'role': 'Leader'
        }

        civ_context = {
            'era': 'classical',
            'culture_values': ['Knowledge', 'Peace']
        }

        result = generate_leader_portrait(leader, civ_context)

        if result.get('success'):
            print(f"[PASS] Portrait generated: {result['image_path']}")
            print(f"  - Check the image at: {result['image_path']}")
            return True
        else:
            print(f"[FAIL] Generation failed: {result.get('error', 'Unknown error')}")
            return False

    except Exception as e:
        print(f"[FAIL] Exception: {e}")
        import traceback
        traceback.print_exc()
        return False


def main():
    """Run all tests."""
    print("\n")
    print("+" + "=" * 58 + "+")
    print("|" + " " * 15 + "VISUAL SYSTEM TEST SUITE" + " " * 19 + "|")
    print("+" + "=" * 58 + "+")

    tests = [
        test_imports,
        test_api_key,
        test_directories,
        test_leader_portrait_generation,
        test_crisis_illustration_function,
        test_settlement_evolution_function,
    ]

    results = []
    for test in tests:
        try:
            results.append(test())
        except Exception as e:
            print(f"\n[ERROR] Test crashed: {e}")
            results.append(False)

    # Summary
    print("\n" + "=" * 60)
    print("TEST SUMMARY")
    print("=" * 60)

    passed = sum(results)
    total = len(results)

    print(f"Passed: {passed}/{total}")

    if passed == total:
        print("\n[SUCCESS] All tests passed!")
        print("\nVisual system is ready to use.")
        print("\nTo test live generation:")
        run_live_test()
    else:
        print("\n[WARNING] Some tests failed. Check output above.")

    print("\n" + "=" * 60)


if __name__ == "__main__":
    main()



################################################################################
# FILE: old_codebase\test_world_turn_updates.py
# Size: 5320 bytes
################################################################################

"""
Test script for apply_world_turn_updates function.
Tests faction, inner circle, and neighboring civilization updates.
"""

import sys
import os
sys.path.insert(0, os.path.dirname(__file__))

from game_state import GameState
from engines.state_updater import apply_world_turn_updates


def test_apply_world_turn_updates():
    """Test the apply_world_turn_updates function with various scenarios."""
    print("=" * 70)
    print("Testing apply_world_turn_updates Function")
    print("=" * 70)

    # Load game state
    game_state = GameState()

    # Test 1: Faction updates
    print("\n### TEST 1: Faction Approval Updates ###")
    print("Initial factions:")
    for faction in game_state.faction_manager.get_all():
        print(f"  - {faction['name']}: approval = {faction.get('approval', 'N/A')}")

    faction_test_updates = {
        'faction_updates': [
            {'name': "The Merchant's Guild", 'approval_change': 10},
            {'name': "The Warrior's Caste", 'approval_change': -5},
            {'name': "Nonexistent Faction", 'approval_change': 5}  # Should warn
        ]
    }

    print("\nApplying faction updates...")
    apply_world_turn_updates(game_state, faction_test_updates)

    print("\nFactions after update:")
    for faction in game_state.faction_manager.get_all():
        print(f"  - {faction['name']}: approval = {faction.get('approval', 'N/A')}")

    # Test 2: Inner Circle updates
    print("\n### TEST 2: Inner Circle Metrics Updates ###")
    print("Initial inner circle:")
    for character in game_state.inner_circle_manager.get_all():
        metrics = character.get('metrics', {})
        print(f"  - {character['name']}: relationship={metrics.get('relationship', 'N/A')}, "
              f"loyalty={metrics.get('loyalty', 'N/A')}")

    inner_circle_test_updates = {
        'inner_circle_updates': [
            {'name': 'Seraphina Vane', 'loyalty_change': 5, 'opinion_change': 10},
            {'name': 'General Kaelen', 'loyalty_change': -3, 'opinion_change': 7},
            {'name': 'Nonexistent Character', 'loyalty_change': 5, 'opinion_change': 5}  # Should warn
        ]
    }

    print("\nApplying inner circle updates...")
    apply_world_turn_updates(game_state, inner_circle_test_updates)

    print("\nInner circle after update:")
    for character in game_state.inner_circle_manager.get_all():
        metrics = character.get('metrics', {})
        print(f"  - {character['name']}: relationship={metrics.get('relationship', 'N/A')}, "
              f"loyalty={metrics.get('loyalty', 'N/A')}")

    # Test 3: Neighboring civilization updates
    print("\n### TEST 3: Neighboring Civilization Relationship Updates ###")
    print("Initial known peoples:")
    for people in game_state.world.get('known_peoples', []):
        print(f"  - {people['name']}: relationship = {people.get('relationship', 'N/A')}")

    neighbor_test_updates = {
        'neighboring_civilization_updates': [
            {'name': 'The Plains Riders', 'relationship_change': 10},  # neutral -> friendly
            {'name': 'The Forest Tribes', 'relationship_change': 10},  # allied -> allied (already max)
            {'name': 'The Stone Circle Clans', 'relationship_change': -10},  # hostile -> hostile (already min)
            {'name': 'Nonexistent Civilization', 'relationship_change': 5}  # Should warn
        ]
    }

    print("\nApplying neighboring civilization updates...")
    apply_world_turn_updates(game_state, neighbor_test_updates)

    print("\nKnown peoples after update:")
    for people in game_state.world.get('known_peoples', []):
        print(f"  - {people['name']}: relationship = {people.get('relationship', 'N/A')}")

    # Test 4: Combined updates
    print("\n### TEST 4: Combined Updates ###")
    combined_updates = {
        'faction_updates': [
            {'name': "The Priesthood of the Sun", 'approval_change': 15}
        ],
        'inner_circle_updates': [
            {'name': 'High Priestess Lyra', 'loyalty_change': 10, 'opinion_change': 5}
        ],
        'neighboring_civilization_updates': [
            {'name': 'The Plains Riders', 'relationship_change': 10}  # friendly -> allied
        ]
    }

    print("\nApplying combined updates...")
    apply_world_turn_updates(game_state, combined_updates)

    # Test 5: Edge cases
    print("\n### TEST 5: Edge Cases ###")

    # Invalid input
    print("\nTest with non-dict input:")
    apply_world_turn_updates(game_state, "not a dict")

    # Empty updates
    print("\nTest with empty updates:")
    apply_world_turn_updates(game_state, {})

    # Missing managers (simulate)
    print("\nTest with missing faction_manager:")
    original_manager = game_state.faction_manager
    delattr(game_state, 'faction_manager')
    apply_world_turn_updates(game_state, {'faction_updates': [{'name': 'Test', 'approval_change': 5}]})
    game_state.faction_manager = original_manager

    print("\n" + "=" * 70)
    print("All tests completed!")
    print("=" * 70)

    # Don't save changes - this is just a test
    print("\nNote: Changes not saved to preserve original game state.")


if __name__ == '__main__':
    test_apply_world_turn_updates()



################################################################################
# FILE: old_codebase\test_world_turns_integration.py
# Size: 3946 bytes
################################################################################

#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Test script for world_turns_engine integration with BonusEngine
"""

import sys
import os
import io

# Force UTF-8 encoding for Windows
if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

# Add parent directory to path
sys.path.insert(0, os.path.dirname(__file__))

from game_state import GameState
from engines.world_turns_engine import WorldTurnsEngine

print("=" * 60)
print("TESTING WORLD TURNS ENGINE INTEGRATION")
print("=" * 60)

# Load game state
print("\n1. Loading game state...")
game = GameState()
print("   ‚úì Game state loaded")

# Create world turns engine
print("\n2. Initializing WorldTurnsEngine...")
engine = WorldTurnsEngine()
print("   ‚úì WorldTurnsEngine initialized")

# Test the new method
print("\n3. Testing calculate_rates_with_bonus_engine()...")
rates = engine.calculate_rates_with_bonus_engine(game)
print(f"   Science rate: {rates['science']:.2f}")
print(f"   Culture rate: {rates['culture']:.2f}")
print(f"   Science sources: {len(rates['science_sources'])} bonuses")
print(f"   Culture sources: {len(rates['culture_sources'])} bonuses")

# Show source breakdown
if rates['science_sources']:
    print("\n   Science bonus sources:")
    for src_type, src_name, value in rates['science_sources']:
        print(f"     +{value} from {src_type}: {src_name}")

if rates['culture_sources']:
    print("\n   Culture bonus sources:")
    for src_type, src_name, value in rates['culture_sources']:
        print(f"     +{value} from {src_type}: {src_name}")

# Test simulate_turn (this will trigger the verification)
print("\n4. Testing simulate_turn() with verification...")
print("   Note: This calls Gemini API, so it may take a moment...")
print("   Watching for verification output...")

# We won't actually run simulate_turn as it calls API
# Instead we'll manually test the verification logic
print("\n5. Manual Verification Test...")
population = game.civilization['population']
happiness = game.population_happiness
inner_circle = game.inner_circle

# OLD WAY
science_bonus_old = 0
culture_bonus_old = 0
for character in inner_circle:
    if character.get("role") == "Scholar":
        science_bonus_old += 5
    if character.get("role") == "Artisan":
        culture_bonus_old += 5

science_per_turn_old = (population / 1000) * (happiness / 100) + science_bonus_old
culture_per_turn_old = (population / 1000) * (happiness / 100) + culture_bonus_old

print(f"   OLD method: science={science_per_turn_old:.2f}, culture={culture_per_turn_old:.2f}")

# NEW WAY
science_per_turn_new = rates['science']
culture_per_turn_new = rates['culture']

print(f"   NEW method: science={science_per_turn_new:.2f}, culture={culture_per_turn_new:.2f}")

# Compare
science_match = abs(science_per_turn_old - science_per_turn_new) < 0.01
culture_match = abs(culture_per_turn_old - culture_per_turn_new) < 0.01

print("\n6. Verification Results:")
if science_match and culture_match:
    print("   ‚úÖ OLD and NEW methods produce identical results!")
    print(f"   ‚úì Science: {science_per_turn_old:.2f} == {science_per_turn_new:.2f}")
    print(f"   ‚úì Culture: {culture_per_turn_old:.2f} == {culture_per_turn_new:.2f}")
    success = True
else:
    print("   ‚ùå MISMATCH detected!")
    print(f"   ‚úó Science: {science_per_turn_old:.2f} != {science_per_turn_new:.2f}")
    print(f"   ‚úó Culture: {culture_per_turn_old:.2f} != {culture_per_turn_new:.2f}")
    success = False

print("\n" + "=" * 60)
if success:
    print("‚úÖ WORLD TURNS ENGINE INTEGRATION SUCCESSFUL!")
    print("\nThe BonusEngine produces identical results to the old")
    print("hardcoded logic. Safe to clean up old code!")
else:
    print("‚ö† INTEGRATION FAILED - DO NOT REMOVE OLD CODE YET")
print("=" * 60)

sys.exit(0 if success else 1)



################################################################################
# FILE: old_codebase\world_generator.py
# Size: 36404 bytes
################################################################################

import random
import os
import google.generativeai as genai
from engines.prompt_loader import load_prompt
from engines.world_modes.fantasy_mode import FantasyWorldMode
from engines.world_modes.historical_earth_mode import HistoricalEarthMode

class WorldGenerator:
    """
    Generates custom game worlds based on player choices.

    This class now acts as a facade/dispatcher to different world generation modes.
    """

    # World mode registry
    WORLD_MODES = {
        'fantasy': FantasyWorldMode(),
        'historical_earth': HistoricalEarthMode()
    }

    # Legacy configuration mappings (kept for backward compatibility)
    ERA_CONFIGS = {
        "stone_age": {
            "era": "stone_age",
            "year_range": (-50000, -10000),
            "tech_tier": "stone_age",
            "base_discoveries": ["Fire", "Basic Stone Tools", "Spears"],
            "base_infrastructure": ["Central Campfire", "Temporary Shelters"],
            "population_multiplier": 0.5
        },
        "bronze_age": {
            "era": "bronze_age",
            "year_range": (-3000, -1200),
            "tech_tier": "bronze_age",
            "base_discoveries": ["Fire", "Basic Stone Tools", "Spears", "Improved Stone Tools", "Basic Pottery", "Bronze Casting"],
            "base_infrastructure": ["Central Campfire", "Permanent Huts", "Storage Pits"],
            "population_multiplier": 1.0
        },
        "iron_age": {
            "era": "iron_age",
            "year_range": (-1200, -500),
            "tech_tier": "iron_age",
            "base_discoveries": ["Fire", "Basic Stone Tools", "Spears", "Improved Stone Tools", "Basic Pottery", "Bronze Casting", "Iron Smelting", "Advanced Metalwork"],
            "base_infrastructure": ["Central Campfire", "Permanent Huts", "Storage Pits", "Stone Walls", "Watchtowers"],
            "population_multiplier": 1.5
        },
        "classical": {
            "era": "classical",
            "year_range": (-500, 500),
            "tech_tier": "classical",
            "base_discoveries": ["Fire", "Basic Stone Tools", "Spears", "Improved Stone Tools", "Basic Pottery", "Bronze Casting", "Iron Smelting", "Advanced Metalwork", "Writing Systems", "Advanced Architecture"],
            "base_infrastructure": ["Central Campfire", "Permanent Huts", "Storage Pits", "Stone Walls", "Watchtowers", "Marketplace", "Temple"],
            "population_multiplier": 2.0
        }
    }

    TERRAIN_CONFIGS = {
        "coastal": {
            "terrain": "Coastal cliffs with beaches and tide pools",
            "climate": "Temperate maritime",
            "resources": ["Fish", "Shellfish", "Seaweed", "Salt", "Driftwood"],
            "threats": ["Storms", "Tides", "Sea raiders"]
        },
        "forest": {
            "terrain": "Dense forest with clearings",
            "climate": "Temperate",
            "resources": ["Wild game", "Berries", "Timber", "Fresh water"],
            "threats": ["Wild beasts", "Harsh winters", "Forest fires"]
        },
        "mountain": {
            "terrain": "Rocky highlands with valleys",
            "climate": "Alpine",
            "resources": ["Stone", "Mountain herbs", "Game birds", "Snow melt water"],
            "threats": ["Avalanches", "Cold", "Mountain predators", "Difficult terrain"]
        },
        "desert": {
            "terrain": "Arid dunes with scattered oases",
            "climate": "Arid",
            "resources": ["Date palms", "Cacti", "Underground water", "Salt"],
            "threats": ["Sandstorms", "Extreme heat", "Scarce water", "Desert raiders"]
        },
        "plains": {
            "terrain": "Rolling grasslands",
            "climate": "Continental",
            "resources": ["Wild grains", "Grazing animals", "Rivers", "Clay"],
            "threats": ["Wildfires", "Nomadic raiders", "Droughts", "Floods"]
        },
        "river_valley": {
            "terrain": "Fertile valley along a great river",
            "climate": "Temperate",
            "resources": ["Fresh water", "Fertile soil", "Fish", "Reeds", "Wild game"],
            "threats": ["Flooding", "Waterborne diseases", "Rival settlements"]
        },
        "island": {
            "terrain": "Volcanic island with lush vegetation",
            "climate": "Tropical",
            "resources": ["Coconuts", "Fish", "Tropical fruits", "Obsidian"],
            "threats": ["Isolation", "Volcanic activity", "Hurricanes", "Limited resources"]
        }
    }

    CULTURE_TEMPLATES = {
        "martial": {
            "values": ["Strength", "Courage", "Honor", "Discipline", "Loyalty"],
            "sample_traditions": ["Warrior Initiations", "Battle Commemorations", "Weapon Crafting Ceremonies"],
            "traits": ["Aggressive", "Disciplined", "Territorial"]
        },
        "spiritual": {
            "values": ["Wisdom", "Devotion", "Harmony", "Respect for Spirits", "Ritual"],
            "sample_traditions": ["Seasonal Rituals", "Spirit Offerings", "Sacred Pilgrimages"],
            "traits": ["Contemplative", "Mystical", "Ritualistic"]
        },
        "agricultural": {
            "values": ["Hard Work", "Community", "Harvest", "Patience", "Sustainability"],
            "sample_traditions": ["Planting Festivals", "Harvest Celebrations", "Crop Rotation Rituals"],
            "traits": ["Patient", "Cooperative", "Grounded"]
        },
        "mercantile": {
            "values": ["Trade", "Prosperity", "Diplomacy", "Innovation", "Fairness"],
            "sample_traditions": ["Market Days", "Trade Agreements", "Merchant Guilds"],
            "traits": ["Diplomatic", "Shrewd", "Cosmopolitan"]
        },
        "scholarly": {
            "values": ["Knowledge", "Curiosity", "Innovation", "Record-Keeping", "Teaching"],
            "sample_traditions": ["Oral Storytelling", "Star Gazing Ceremonies", "Knowledge Sharing Gatherings"],
            "traits": ["Inquisitive", "Methodical", "Inventive"]
        },
        "artistic": {
            "values": ["Beauty", "Expression", "Creativity", "Tradition", "Excellence"],
            "sample_traditions": ["Art Festivals", "Craftsmanship Competitions", "Performance Rituals"],
            "traits": ["Creative", "Expressive", "Detail-Oriented"]
        }
    }

    RELIGION_CONFIGS = {
        "animism": {
            "name": "Animism",
            "type": "Spirit Worship",
            "tenets": ["All things have a spirit", "The natural world must be respected", "Balance must be maintained"],
            "practices": ["Shamanic rituals", "Spirit offerings", "Nature veneration"]
        },
        "polytheism": {
            "name": "Polytheism",
            "type": "Multiple Deities",
            "tenets": ["The gods influence all aspects of life", "Each deity governs their domain", "Offerings bring favor"],
            "practices": ["Temple rituals", "Sacrificial offerings", "Divine festivals"]
        },
        "monotheism": {
            "name": "Monotheism",
            "type": "Single Deity",
            "tenets": ["There is one supreme divine power", "Faith brings salvation", "The divine law must be followed"],
            "practices": ["Prayer rituals", "Sacred texts recitation", "Pilgrimage"]
        },
        "ancestor_worship": {
            "name": "Ancestor Veneration",
            "type": "Ancestor Worship",
            "tenets": ["The ancestors watch over us", "Honor the dead to prosper", "Lineage is sacred"],
            "practices": ["Ancestral offerings", "Tomb maintenance", "Genealogy keeping"]
        },
        "nature_worship": {
            "name": "Nature Reverence",
            "type": "Nature Worship",
            "tenets": ["Nature is the source of all life", "Harmony with the land brings prosperity", "Sacred groves must be protected"],
            "practices": ["Seasonal ceremonies", "Sacred grove pilgrimages", "Natural offerings"]
        },
        "none": {
            "name": "No Dominant Religion",
            "type": "Secular/Mixed Beliefs",
            "tenets": ["Practical wisdom guides us", "Diversity of belief is accepted"],
            "practices": ["Personal rituals", "Community gatherings"]
        }
    }

    SOCIAL_STRUCTURES = {
        "egalitarian": "Egalitarian tribe where decisions are made collectively",
        "hierarchical": "Hierarchical society with clear social ranks",
        "tribal_council": "Tribal council of elders and skilled leaders",
        "monarchy": "Hereditary monarchy with a ruling family",
        "theocracy": "Religious leaders hold temporal power"
    }

    def __init__(self):
        """Initialize the world generator."""
        pass

    def generate_world(self, config):
        """
        Generate a complete world based on configuration.

        This method now dispatches to the appropriate world mode based on config.

        Args:
            config: Dictionary containing all customization choices

        Returns:
            Dictionary containing all game state files
        """
        # Determine world mode (default to historical_earth)
        world_mode = config.get("world_mode", "historical_earth")

        # Get the appropriate mode instance
        mode = self.WORLD_MODES.get(world_mode, self.WORLD_MODES["historical_earth"])

        # Normalize config keys for compatibility
        if "era" in config and "starting_era" not in config:
            config["starting_era"] = config["era"]

        # Generate world using the selected mode
        world_data = mode.generate(config)

        return world_data

    def _generate_civilization(self, era, civ_name, population_size, leader_name):
        """Generate civilization state."""
        era_config = self.ERA_CONFIGS[era]

        # Population calculation
        pop_ranges = {
            "small": (100, 500),
            "medium": (500, 2000),
            "large": (2000, 5000)
        }
        pop_min, pop_max = pop_ranges[population_size]
        population = random.randint(int(pop_min * era_config["population_multiplier"]),
                                   int(pop_max * era_config["population_multiplier"]))

        # Year calculation
        year_min, year_max = era_config["year_range"]
        year = random.randint(year_min, year_max)

        # Leader generation
        if not leader_name:
            leader_name = self._generate_leader_name()

        leader_traits = random.sample([
            "Wise", "Brave", "Diplomatic", "Strategic", "Charismatic",
            "Cautious", "Bold", "Spiritual", "Pragmatic", "Visionary"
        ], 3)

        return {
            "meta": {
                "name": civ_name,
                "year": year,
                "era": era_config["era"],
                "founding_date": year
            },
            "leader": {
                "name": leader_name,
                "age": random.randint(25, 45),
                "life_expectancy": random.randint(60, 80),
                "role": "Leader",
                "traits": leader_traits,
                "years_ruled": 0
            },
            "population": population,
            "resources": {
                "food": population * random.randint(1, 3),
                "wealth": population * random.randint(1, 2),
                "tech_tier": era_config["tech_tier"]
            }
        }

    def _generate_culture(self, cultural_focus, social_structure):
        """Generate culture context."""
        culture_template = self.CULTURE_TEMPLATES[cultural_focus]

        # Select values
        values = culture_template["values"].copy()
        values.extend(random.sample([
            "Survival", "Community", "Respect for Elders", "Adaptation",
            "Craftsmanship", "Generosity", "Resilience"
        ], 3))

        # Select traditions
        traditions = culture_template["sample_traditions"].copy()
        traditions.extend(random.sample([
            "Oral Storytelling", "Seasonal Celebrations", "Coming of Age Ceremonies",
            "Ancestral Veneration", "Crafting Competitions"
        ], 2))

        return {
            "values": values[:8],  # Keep it manageable
            "traditions": traditions[:6],
            "taboos": ["Harming Kin", random.choice(["Oath Breaking", "Sacrilege", "Betrayal", "Waste"])],
            "social_structure": self.SOCIAL_STRUCTURES[social_structure],
            "recent_changes": []
        }

    def _generate_religion(self, religion_type):
        """Generate religion context."""
        if religion_type not in self.RELIGION_CONFIGS:
            religion_type = "animism"

        religion_config = self.RELIGION_CONFIGS[religion_type]

        # Generate deity name based on type
        deity_names = {
            "animism": ["The Great Spirit", "The Wild Soul", "The Earth Mother"],
            "polytheism": ["The Pantheon of Stars", "The Divine Court", "The Ancient Gods"],
            "monotheism": ["The Eternal One", "The Supreme Creator", "The Divine Light"],
            "ancestor_worship": ["The First Ancestor", "The Ancient Fathers", "The Founding Lineage"],
            "nature_worship": ["The Forest Spirit", "The Mountain Guardian", "The River Mother"],
            "none": ["Various Spirits", "Personal Beliefs", "Folk Traditions"]
        }

        primary_deity = random.choice(deity_names.get(religion_type, ["The Unknown"]))

        # Generate holy sites
        holy_sites = [
            random.choice(["The Sacred Grove", "The Great Oak", "The Ancient Cave", "The Stone Circle"]),
            random.choice(["The Mountain Peak", "The River Source", "The Ancestor's Tomb", "The First Settlement"])
        ]

        return {
            "name": religion_config["name"],
            "type": religion_config["type"],
            "primary_deity": primary_deity,
            "core_tenets": religion_config["tenets"],
            "practices": religion_config["practices"],
            "holy_sites": holy_sites,
            "influence": random.choice(["dominant", "significant", "moderate"]),
            "schisms": []
        }

    def _generate_technology(self, era):
        """Generate technology context."""
        era_config = self.ERA_CONFIGS[era]

        return {
            "current_tier": era_config["tech_tier"],
            "discoveries": era_config["base_discoveries"].copy(),
            "in_progress": [],
            "infrastructure": era_config["base_infrastructure"].copy()
        }

    def _generate_world_context(self, terrain, difficulty, neighbor_count, resource_abundance):
        """Generate world context."""
        terrain_config = self.TERRAIN_CONFIGS[terrain]

        # Adjust resources based on abundance
        resources = terrain_config["resources"].copy()
        if resource_abundance == "abundant":
            resources.extend(random.sample(["Medicinal Herbs", "Precious Stones", "Rare Woods", "Exotic Spices"], 2))
        elif resource_abundance == "scarce":
            resources = resources[:max(2, len(resources) - 2)]

        # Adjust threats based on difficulty
        threats = terrain_config["threats"].copy()
        if difficulty == "challenging":
            threats.extend(random.sample(["Hostile Neighbors", "Natural Disasters", "Resource Scarcity", "Disease"], 2))
        elif difficulty == "peaceful":
            threats = threats[:max(1, len(threats) - 1)]

        # Generate neighbors
        neighbor_counts = {
            "none": 0,
            "few": random.randint(1, 2),
            "several": random.randint(3, 4)
        }

        num_neighbors = neighbor_counts.get(neighbor_count, 1)
        neighbors = []

        neighbor_names = [
            "The River Clan", "The Mountain Folk", "The Desert Wanderers",
            "The Forest Tribes", "The Sea People", "The Plains Riders",
            "The Stone Circle Clans", "The Sun Worshippers"
        ]

        for i in range(num_neighbors):
            relationship = random.choice(["allied", "neutral", "wary", "hostile"]) if difficulty != "peaceful" else random.choice(["allied", "neutral", "friendly"])

            neighbors.append({
                "name": random.choice(neighbor_names),
                "relationship": relationship,
                "strength": "unknown",
                "distance": random.choice(["nearby", "several days journey", "distant"]),
                "history": "Recently discovered" if i == 0 else "Known through tales and occasional contact"
            })

        return {
            "known_peoples": neighbors,
            "geography": {
                "terrain": terrain_config["terrain"],
                "climate": terrain_config["climate"],
                "resources": resources,
                "threats": threats
            }
        }

    def _generate_factions(self):
        """Generates the default starting factions."""
        return {
            "factions": [
                {
                    "name": "The Merchant's Guild",
                    "leader": "Lysander the Wealthy",
                    "approval": 60,
                    "support_percentage": 25,
                    "status": "Neutral",
                    "goals": ["Establish new trade routes", "Increase city wealth by 20%", "Reduce tariffs on luxury goods"]
                },
                {
                    "name": "The Elder Council",
                    "leader": "Elder Maeve",
                    "approval": 60,
                    "support_percentage": 20,
                    "status": "Neutral",
                    "goals": ["Preserve ancient traditions", "Maintain social stability", "Construct a monument to the founders"]
                },
                {
                    "name": "The Warrior's Caste",
                    "leader": "Warlord Gorok",
                    "approval": 60,
                    "support_percentage": 30,
                    "status": "Neutral",
                    "goals": ["Expand our borders", "Recruit and train more soldiers", "Vanquish our rivals"]
                },
                {
                    "name": "The Priesthood of the Sun",
                    "leader": "High Priestess Elara",
                    "approval": 60,
                    "support_percentage": 25,
                    "status": "Neutral",
                    "goals": ["Spread the faith to new lands", "Build a Grand Temple", "Achieve spiritual enlightenment for the people"]
                }
            ]
        }

    def _generate_inner_circle(self, cultural_focus=None, era=None, factions=None):
        """
        Generates culturally grounded inner circle members.

        Args:
            cultural_focus: The civilization's cultural focus (martial, spiritual, etc.)
            era: The civilization's era (stone_age, bronze_age, etc.)
            factions: The faction data to link advisors to
        """
        # Extract faction names if factions provided
        faction_list = factions.get('factions', []) if factions else []

        # Define role templates with cultural variations
        role_templates = [
            {
                "role_key": "military",
                "roles": {
                    "stone_age": "War Chief",
                    "bronze_age": "Commander",
                    "iron_age": "Grand Marshal",
                    "classical": "Strategos",
                    "medieval": "Lord Commander",
                    "renaissance": "Marshal General"
                },
                "base_traits": ["Disciplined", "Direct", "Stern"],
                "cultural_traits": {
                    "martial": ["Aggressive", "Tactical"],
                    "spiritual": ["Devoted", "Honorable"],
                    "agricultural": ["Protective", "Patient"],
                    "mercantile": ["Strategic", "Pragmatic"],
                    "scholarly": ["Analytical", "Methodical"],
                    "artistic": ["Charismatic", "Inspiring"]
                },
                "faction_preference": "warrior"
            },
            {
                "role_key": "intelligence",
                "roles": {
                    "stone_age": "Scout Master",
                    "bronze_age": "Eyes of the Throne",
                    "iron_age": "Spymaster",
                    "classical": "Master of Whispers",
                    "medieval": "Lord of Secrets",
                    "renaissance": "Intelligence Minister"
                },
                "base_traits": ["Cunning", "Discreet", "Observant"],
                "cultural_traits": {
                    "martial": ["Ruthless", "Efficient"],
                    "spiritual": ["Mysterious", "Intuitive"],
                    "agricultural": ["Patient", "Meticulous"],
                    "mercantile": ["Pragmatic", "Shrewd"],
                    "scholarly": ["Analytical", "Insightful"],
                    "artistic": ["Subtle", "Persuasive"]
                },
                "faction_preference": "merchant"
            },
            {
                "role_key": "spiritual",
                "roles": {
                    "stone_age": "Shaman",
                    "bronze_age": "High Priest",
                    "iron_age": "High Priestess",
                    "classical": "Hierophant",
                    "medieval": "Grand Cleric",
                    "renaissance": "Archbishop"
                },
                "base_traits": ["Pious", "Serene", "Compassionate"],
                "cultural_traits": {
                    "martial": ["Militant", "Resolute"],
                    "spiritual": ["Mystic", "Devoted"],
                    "agricultural": ["Nurturing", "Harmonious"],
                    "mercantile": ["Diplomatic", "Wise"],
                    "scholarly": ["Philosophical", "Learned"],
                    "artistic": ["Expressive", "Inspiring"]
                },
                "faction_preference": "priest"
            }
        ]

        # Set defaults
        if not cultural_focus:
            cultural_focus = "spiritual"
        if not era:
            era = "bronze_age"

        characters = []

        for template in role_templates:
            # Get era-appropriate role title
            role = template["roles"].get(era, template["roles"]["bronze_age"])

            # Build personality traits
            traits = template["base_traits"].copy()
            cultural_traits = template["cultural_traits"].get(cultural_focus, [])
            if cultural_traits:
                traits.extend(random.sample(cultural_traits, min(2, len(cultural_traits))))

            # Randomly shuffle and pick 4 unique traits
            random.shuffle(traits)
            traits = traits[:4]

            # Find matching faction
            faction_link = None
            faction_pref = template["faction_preference"]
            for faction in faction_list:
                if faction_pref in faction["name"].lower():
                    faction_link = faction["name"]
                    break

            # If no match, randomly assign from available factions
            # Use a weighted random to ensure better distribution
            if not faction_link and faction_list:
                # Try to avoid assigning the same faction to consecutive advisors
                available_factions = faction_list.copy()
                if idx > 0 and inner_circle_characters:
                    # Get the last assigned faction
                    last_faction = inner_circle_characters[-1].get("faction_link")
                    # Filter out the last faction if possible
                    other_factions = [f for f in available_factions if f["name"] != last_faction]
                    if other_factions:
                        available_factions = other_factions

                faction_link = random.choice(available_factions)["name"]

            # Generate a culturally appropriate name (will be implemented)
            name = self._generate_advisor_name(cultural_focus, era, template["role_key"])

            # Generate dialogue sample based on role and culture
            dialogue = self._generate_advisor_dialogue(role, cultural_focus, traits)

            character = {
                "name": name,
                "role": role,
                "faction_link": faction_link,
                "personality_traits": traits,
                "dialogue_sample": dialogue,
                "history": [f"Appointed to the council as {role}."],
                "metrics": {
                    "relationship": random.randint(45, 55),
                    "influence": random.randint(40, 70),
                    "loyalty": random.randint(55, 75)
                },
                "portrait": "placeholder.png"  # Will be generated async
            }
            characters.append(character)

        return {"characters": characters}

    def _generate_advisor_name(self, cultural_focus, era, role_key):
        """
        Generate a culturally appropriate advisor name.

        Args:
            cultural_focus: The civilization's cultural focus
            era: The civilization's era
            role_key: The advisor's role type (military, intelligence, spiritual)
        """
        # Name pools based on cultural focus
        name_pools = {
            "martial": {
                "male": ["Theron", "Kaelen", "Marcus", "Gorak", "Brutus", "Ragnar", "Sigurd", "Ajax"],
                "female": ["Athena", "Valeria", "Brienne", "Astrid", "Cassandra", "Freya", "Hippolyta"]
            },
            "spiritual": {
                "male": ["Zephyr", "Elias", "Aurelius", "Soren", "Alaric", "Caelum", "Thaddeus"],
                "female": ["Seraphina", "Lyra", "Celestia", "Miriam", "Isolde", "Vesta", "Aria"]
            },
            "agricultural": {
                "male": ["Gareth", "Alden", "Borin", "Cedric", "Ewan", "Jasper", "Thorne"],
                "female": ["Ceres", "Flora", "Autumn", "Gaia", "Hazel", "Ivy", "Rowan"]
            },
            "mercantile": {
                "male": ["Lorenzo", "Darius", "Cassius", "Lucien", "Marcellus", "Silvio", "Titus"],
                "female": ["Portia", "Octavia", "Lavinia", "Aurelia", "Livia", "Cordelia", "Emilia"]
            },
            "scholarly": {
                "male": ["Ptolemy", "Archimedes", "Cyrus", "Thales", "Plato", "Solon", "Pytheas"],
                "female": ["Hypatia", "Minerva", "Aspasia", "Diotima", "Eudocia", "Theano", "Arete"]
            },
            "artistic": {
                "male": ["Apollo", "Orpheus", "Lysander", "Thalia", "Perseus", "Damon", "Leander"],
                "female": ["Calliope", "Clio", "Erato", "Melpomene", "Sappho", "Terpsichore", "Urania"]
            }
        }

        # Get appropriate name pool
        pool = name_pools.get(cultural_focus, name_pools["spiritual"])

        # Determine gender based on role (mix of male/female)
        gender = random.choice(["male", "female"])

        # Select name
        first_name = random.choice(pool[gender])

        # Add title based on role
        titles_by_role = {
            "military": ["the Valiant", "the Shield", "Ironfist", "the Unyielding", "Stormborn", "the Defender"],
            "intelligence": ["the Shadow", "the Whisper", "Silvertongue", "the Watcher", "the Veiled", "Nighteye"],
            "spiritual": ["the Blessed", "the Seer", "Lightbearer", "the Faithful", "Stargazer", "the Pure"]
        }

        title_pool = titles_by_role.get(role_key, ["the Wise"])
        title = random.choice(title_pool)

        return f"{first_name} {title}"

    def _generate_advisor_dialogue(self, role, cultural_focus, traits):
        """
        Generate a sample dialogue line that reflects the advisor's role and personality.

        Args:
            role: The advisor's role title
            cultural_focus: The civilization's cultural focus
            traits: List of personality traits
        """
        # Dialogue templates based on role and culture
        dialogue_templates = {
            "military": {
                "martial": [
                    "Strength is the only currency that matters on the battlefield.",
                    "A sharp blade and sharper mind win wars.",
                    "Our warriors must be ready to strike at a moment's notice."
                ],
                "spiritual": [
                    "The gods favor those who fight with honor.",
                    "Our armies must be blessed before they march.",
                    "Victory comes to the righteous, not merely the strong."
                ],
                "agricultural": [
                    "Protect the harvest, protect the people.",
                    "A strong defense ensures our fields remain fertile.",
                    "Our warriors are shepherds of peace, not wolves of war."
                ],
                "mercantile": [
                    "Military might secures profitable trade routes.",
                    "A merchant's coin is worth nothing without a soldier's sword.",
                    "Strategic positioning is as valuable as gold."
                ],
                "scholarly": [
                    "Knowledge of terrain and tactics wins battles.",
                    "Study our enemies before we engage them.",
                    "Military science is an art form unto itself."
                ],
                "artistic": [
                    "There is beauty in the perfect formation.",
                    "War is a terrible art, but art nonetheless.",
                    "Our banners shall inspire both fear and awe."
                ]
            },
            "intelligence": {
                "martial": [
                    "Information is the first casualty of war‚Äîand our greatest weapon.",
                    "Know your enemy before they know themselves.",
                    "Every secret is a dagger waiting to be wielded."
                ],
                "spiritual": [
                    "The spirits reveal truths to those who listen.",
                    "Not all battles are fought with steel, my lord.",
                    "Hidden knowledge is sacred knowledge."
                ],
                "agricultural": [
                    "Even the smallest rumor can blight a harvest.",
                    "Patience and observation yield the ripest fruit.",
                    "Trust must be cultivated like any crop."
                ],
                "mercantile": [
                    "Information is a currency more valuable than gold.",
                    "Every transaction reveals something about the buyer.",
                    "The market whispers secrets to those who listen."
                ],
                "scholarly": [
                    "Knowledge without discretion is dangerous.",
                    "I study what others dare not speak aloud.",
                    "The archive of secrets grows daily."
                ],
                "artistic": [
                    "Deception is an art, and I am its master.",
                    "Every lie must be beautiful to be believed.",
                    "The truth is canvas; manipulation is the brush."
                ]
            },
            "spiritual": {
                "martial": [
                    "The gods demand strength in body and spirit.",
                    "Pray for victory, prepare for battle.",
                    "Our faith is our armor."
                ],
                "spiritual": [
                    "May the divine light guide your path.",
                    "The spirits speak‚Äîwe must listen.",
                    "Faith is the foundation of all things."
                ],
                "agricultural": [
                    "As we sow, so shall we reap‚Äîin this life and the next.",
                    "The earth is sacred, and we its humble stewards.",
                    "Give thanks for the harvest, for it is blessed."
                ],
                "mercantile": [
                    "Prosperity flows from divine favor.",
                    "The gods smile upon fair trade and honest dealings.",
                    "Wealth without virtue is worthless."
                ],
                "scholarly": [
                    "Wisdom and faith are two paths to the same truth.",
                    "The divine mysteries are written in ancient texts.",
                    "Knowledge of the sacred is the highest knowledge."
                ],
                "artistic": [
                    "Beauty is the divine made manifest.",
                    "Our ceremonies are poems written in ritual.",
                    "The gods appreciate elegance as much as devotion."
                ]
            }
        }

        # Determine role category
        role_category = "military"
        if "spy" in role.lower() or "whisper" in role.lower() or "eyes" in role.lower() or "secret" in role.lower() or "scout" in role.lower():
            role_category = "intelligence"
        elif "priest" in role.lower() or "shaman" in role.lower() or "cleric" in role.lower() or "hierophant" in role.lower():
            role_category = "spiritual"

        # Get appropriate dialogue pool
        dialogue_pool = dialogue_templates.get(role_category, {}).get(cultural_focus, [])

        # If no specific dialogue, use generic
        if not dialogue_pool:
            dialogue_pool = [
                "I serve at your pleasure, my lord.",
                "My counsel is yours to consider.",
                "Together, we shall guide our people to greatness."
            ]

        return random.choice(dialogue_pool)

    def _generate_leader_name(self):
        """Generate a random leader name."""
        first_names = [
            "Anya", "Kael", "Theron", "Lyra", "Darius", "Mira", "Orin", "Sera",
            "Aldric", "Elara", "Bran", "Nyx", "Finn", "Rhea", "Cassius", "Aria"
        ]
        titles = [
            "the Wise", "the Bold", "the Just", "the Strong", "the Seer",
            "the Builder", "the Diplomat", "the Warrior", "the Keeper", "the Guide"
        ]

        return f"{random.choice(first_names)}, {random.choice(titles)}"

    def generate_ai_description(self, world_data):
        """
        Use AI to generate a unique opening description for the world.

        Args:
            world_data: The generated world data

        Returns:
            A narrative description string
        """
        try:
            from model_config import WORLD_GEN_MODEL
            from engines.prompt_loader import load_prompt
            model = genai.GenerativeModel(WORLD_GEN_MODEL)

            prompt = load_prompt('world/ai_description').format(
                civ_name=world_data['civilization']['meta']['name'],
                era=world_data['civilization']['meta']['era'],
                terrain=world_data['world']['geography']['terrain'],
                climate=world_data['world']['geography']['climate'],
                leader_name=world_data['civilization']['leader']['name'],
                cultural_values=', '.join(world_data['culture']['values'][:3]),
                religion_name=world_data['religion']['name']
            )

            response = model.generate_content(prompt)
            return response.text.strip()
        except Exception as e:
            print(f"Error generating AI description: {e}")
            return f"In the {world_data['civilization']['meta']['era']}, your people, known as {world_data['civilization']['meta']['name']}, begin their journey in a land of {world_data['world']['geography']['terrain'].lower()}."



################################################################################
# FILE: REFACTOR_BLUEPRINT.md
# Size: 24529 bytes
################################################################################

REFACTOR BLUEPRINT: Corporate Decision Simulator
Executive Summary
Project Objective: To deliver a comprehensive blueprint for the thematic refactoring of the "Civilization Narrative Game" engine into a "Corporate Decision Simulator" (CDS).

Core Mandate (The Golden Constraint): This blueprint adheres strictly to the principle of minimal code modification. The transformation will be achieved primarily through the re-theming of data files (context/*.json) and the re-engineering of AI prompts (prompts/), leveraging the existing engine's robust and flexible architecture.

Target State Vision: The CDS will be a sophisticated professional role-playing tool. Users will assume the role of an employee at a specific career level (the "Player Ladder"), making decisions that impact their career trajectory, their department's success, and the overall health of the corporation.

Document Purpose: This document serves as a direct and actionable guide for the development team. It provides a complete, step-by-step plan for executing the thematic refactor.

Step 1: Core Systems Analysis & Evaluation
This initial step inventories the existing codebase to determine which components are critical for the new CDS, which can be safely discarded, and which offer the most sophisticated value for the target corporate audience.

1.1 Essential Systems for the Corporate Decision Simulator
The existing engine is a well-architected, event-driven system whose core logic is highly adaptable. The following components are essential for the CDS and will be retained and re-themed.

Engine Files (engines/*.py)
action_processor.py: This is the central nervous system of the simulation. Its logic for taking a player action, querying the AI with context, and applying state updates is perfectly suited for processing corporate decisions. This will be the main integration point for our new prompts.   

resource_engine.py: The core logic for managing resource generation and consumption (food, wealth) is directly translatable to managing corporate budget and political_capital. The calculate_consumption() function is the key component to be re-themed to represent corporate overhead.   

faction_engine.py & faction_manager.py: These are arguably the most valuable assets. They provide a ready-made system for simulating the complex interplay between competing internal groups, which is a perfect model for inter-departmental politics, budget negotiations, and morale tracking.   

council_engine.py: This engine, designed for formal policy meetings, provides the ideal structure for simulating all forms of corporate meetings, from weekly team syncs to high-stakes board presentations.   

crisis_engine.py: The logic for detecting and triggering high-stakes events based on resource thresholds is directly applicable to corporate crises like budget freezes, mass layoffs, or PR disasters.   

event_generator.py: The mechanism for creating random, narrative events is the foundation for generating the day-to-day tasks, emails, and interpersonal conflicts that define corporate life.   

inner_circle_manager.py & character_engine.py: Provides the framework for managing key relationships with specific individuals, which maps directly to the player's interactions with their boss, mentor, rivals, and direct reports.   

bonus_engine.py & bonus_definitions.py: This system for calculating bonuses from character roles and traits is highly valuable for modeling how employee skills (leader.traits) and job titles (leader.role) provide tangible benefits (e.g., a "Persuasive" skill granting a bonus to PoliticalInfluence generation).   

consequence_engine.py & law_engine.py: These systems, which track long-term decisions and their ripple effects, are crucial for creating a sophisticated simulation where past choices matter. "Decrees" can be re-themed as "Corporate Policies" or "Executive Mandates".   

Context Files (context/*.json)
All files within the context/ directory are essential, as they represent the configurable "skin" of the simulation. Their re-theming is the primary task of this refactor. This includes: civilization_state.json, culture.json, factions.json, inner_circle.json, religion.json, technology.json, and world_context.json.   

1.2 Discardable and Deprecated Systems
The following systems are tied specifically to the civilization theme and are not relevant to the text-and-data-focused professional simulator. They should be disabled or ignored to reduce complexity.

engines/visual_engine.py & engines/image_engine.py: The CDS is a professional tool focused on decision-making logic and narrative. The generation of leader portraits and settlement images is superfluous and would detract from the professional tone. Disabling these engines will also reduce API costs and complexity.   

engines/world_modes/*: The concept of different world generation modes (e.g., fantasy_mode.py, historical_earth_mode.py) is irrelevant. The "world" of the CDS is a single, defined corporate environment. This entire directory can be ignored.   

data/tech_tree.json: While the concept of technology is being re-themed to "Skills & Tools," the specific tech_tree.json with prerequisites from the civilization game is too rigid for a corporate environment. The new concept will be a more fluid list of acquired competencies rather than a branching tree of unlocks.   

1.3 Evaluation for Corporate Sophistication
The true value of this engine for a corporate client is not just its narrative capability, but its underlying mechanics for simulating complex social and political systems. A simple narrative game might just present choices with linear outcomes. This engine, however, models the consequences of those choices within a dynamic system of competing interests. The faction_engine.py and council_engine.py are the cornerstones of this value proposition, offering a level of simulation depth that is highly relevant to professional and executive role-play.

faction_engine.py as an Inter-Departmental Political Simulator
The engine's faction system provides a powerful and surprisingly accurate model for the political landscape of a modern corporation.

Value Proposition: This engine simulates the core reality of corporate life: departments often function as semi-independent entities with their own goals, metrics (KPIs), and leadership, all competing for a finite pool of corporate resources like budget and headcount.

Mechanism: The existing faction.approval metric is a perfect analogue for department.morale. When a user (the "employee") makes a decision that benefits the "Sales" department, the faction_engine's logic will automatically calculate the negative impact on the "Engineering" department's morale if their goals are now harder to achieve. This allows the CDS to simulate zero-sum budget fights, resource allocation conflicts, and the political capital required to build consensus‚Äîfeatures that a business user simulating executive policy would find immensely valuable. The faction_audience.py event becomes a "Quarterly Budget Review" where department heads (VPs, Directors) petition the player for resources, forcing the player to make trade-offs that directly impact departmental morale and performance.

council_engine.py as a Management & Policy Simulation Tool
The council engine provides a structured framework for simulating the formal meetings that are central to corporate decision-making and policy implementation.

Value Proposition: This engine moves beyond simple random events into structured, multi-stage deliberations, mirroring the process of corporate governance. It allows the simulation to model how policy is debated, decided, and enacted.

Mechanism: The "Advisor Reports" can be re-themed as status updates from direct reports or department heads. The "Central Dilemma" becomes a project-based problem, such as "Product launch is behind schedule," "A major client has issued a complaint," or "Competitor X just launched a rival product." The player's choices within the council meeting can set a new active_policy, which in the CDS becomes the "Strategic Focus for the Quarter" (e.g., "Cost Reduction," "Aggressive Growth," "Product Innovation"). This provides a direct link between a single meeting's outcome and the long-term strategic direction of the simulated company.

Step 2: Thematic Mapping Blueprint
This section provides the exhaustive, file-by-file instructions for the thematic transformation. It is the core of the refactor.

2.A Data Layer Refactor (JSON Mapping)
The following tables provide a key-by-key mapping for each essential context/*.json file, transforming the "Civilization" theme into a "Corporate" theme. This ensures a 1:1 transformation of the simulation's data foundation. The key to this refactor is not just finding direct analogues, but also making creative, insightful mappings for abstract concepts. For instance, religion.json becomes corporate_mission.json, elevating the simulation by modeling how a company's stated values ("core tenets") can influence decisions and create internal conflict ("schisms").   

Table 1: context/civilization_state.json -> corporate_and_player_profile.json
Original Key (civilization_state.json)	New Concept (Corporate)	Example Value	Notes
meta.name	corporation.name	"OmniCorp Global"	The name of the simulated company.
meta.year	simulation.current_fiscal_quarter	"2025_Q3"	The simulation progresses in fiscal quarters.
meta.era	corporation.maturity_stage	"growth_phase"	e.g., "Startup," "Growth," "Mature," "Decline."
meta.founding_date	corporation.ipo_date	"2015_Q2"	The date the company was founded or went public.
leader.name	player.name	"Alex Chen"	The name of the user's character.
leader.age	player.years_at_company	5	Tracks tenure, not biological age.
leader.life_expectancy	player.expected_career_length	20	A metric for career progression simulation.
leader.role	player.title	"Senior Manager"	The "Player Ladder." This is the core role-play variable.
leader.traits	player.skills		Professional skills that provide bonuses.
leader.years_ruled	player.years_in_role	2	Tracks time at the current ladder level.
population	corporation.headcount	1500	Total number of employees in the company.
resources.food	corporation.budget	5000000	The company's operational budget (in USD).
resources.wealth	player.political_capital	350	The player's personal influence and network.
resources.tech_tier	corporation.tech_stack_tier	"modern_cloud_native"	The company's overall technology level.
victory_progress	player.performance_review_scores	{"innovation": 85, "leadership": 60}	Maps to key performance indicators (KPIs) for the player.
Table 2: context/factions.json -> departments.json
Original Key (factions.json)	New Concept (Corporate)	Example Value	Notes
factions (array)	departments (array)	N/A	The root array of department objects.
faction.name	department.name	"Engineering"	e.g., "Sales," "Marketing," "HR," "Legal."
faction.leader	department.head	"VP of Engineering"	The title of the department's leader.
faction.approval	department.morale	75	A 0-100 score representing the department's morale.
faction.support_percentage	department.headcount_percentage	30	The percentage of total company employees in this department.
faction.goals	department.kpis	``	The department's Key Performance Indicators for the quarter.
Table 3: context/inner_circle.json -> key_personnel.json
Original Key (inner_circle.json)	New Concept (Corporate)	Example Value	Notes
characters (array)	personnel (array)	N/A	The root array of key personnel objects.
character.name	person.name	"Sarah Jenkins"	The name of the key person.
character.role	person.relationship_to_player	"Your Boss"	e.g., "Mentor," "Rival Manager," "Direct Report."
character.faction_link	person.department	"Sales"	The department this person belongs to.
character.personality_traits	person.work_style	``	Describes their professional behavior.
character.metrics.relationship	person.metrics.rapport	65	How well the player gets along with this person.
character.metrics.influence	person.metrics.influence	80	How much power this person wields in the company.
character.metrics.loyalty	person.metrics.trust	40	How much this person trusts the player's judgment.
Table 4: context/culture.json -> company_culture.json
Original Key (culture.json)	New Concept (Corporate)	Example Value	Notes
values	stated_values	``	The official corporate values listed on the website.
traditions	unspoken_rules	``	The actual, unwritten rules of the workplace.
taboos	hr_violations	``	Actions that will trigger a negative HR event.
social_structure	organizational_structure	"Hierarchical with matrixed project teams"	Describes the company's org chart.
Table 5: context/religion.json -> corporate_mission.json
Original Key (religion.json)	New Concept (Corporate)	Example Value	Notes
name	mission_statement_name	"The OmniCorp Way"	The branding for the company's mission.
primary_deity	founding_ceo_vision	"Steve's Vision of 'Seamless Integration'"	The almost mythical vision of the company's founder.
core_tenets	mission_statement_pillars	``	The core pillars of the official mission statement.
practices	corporate_rituals	["All-hands meetings", "Quarterly off-sites"]	The recurring, quasi-ceremonial company events.
holy_sites	legacy_projects	``	Revered past projects that define the company.
schisms	major_pivots_or_reorgs	``	Major strategic shifts that caused internal strife.
Table 6: context/technology.json -> skills_and_assets.json
Original Key (technology.json)	New Concept (Corporate)	Example Value	Notes
current_tier	player.skill_level	"Expert"	The player's overall competency level.
discoveries	player.acquired_skills	``	The player's personal skills and certifications.
infrastructure	corporation.internal_tools	``	The company's shared technology assets and platforms.
Table 7: context/world_context.json -> market_and_competitors.json
Original Key (world_context.json)	New Concept (Corporate)	Example Value	Notes
known_peoples	competitors	(array of competitor objects)	Information on rival companies.
competitor.name	competitor.name	"CyberDyne Systems"	The name of the rival company.
competitor.relationship	competitor.market_position	"Direct Competitor"	e.g., "Market Leader," "Disruptive Startup."
geography	market_landscape	(object describing the market)	
geography.terrain	market.sector	"B2B Enterprise SaaS"	The industry sector the company operates in.
geography.climate	market.conditions	"High-Growth, High-Competition"	The current state of the market.
geography.resources	market.opportunities	["AI Integration", "Emerging Markets"]	Potential areas for growth.
geography.threats	market.risks	``	External threats to the company.
2.B Engine & Prompt Logic Refactor (Python Mapping)
This section details the necessary adjustments to engine logic and provides a clear strategy for rewriting the corresponding AI prompts. The most significant change is not in the Python code itself, but in the context provided to the AI prompts. The prompts must be fundamentally rewritten to shift the AI's persona from a "historical chronicler" to a "corporate environment simulator." This involves changing the entire lexicon, framing, and the types of outcomes the AI is instructed to generate.

engines/resource_engine.py
Logic: The function calculate_consumption() will be re-themed to calculate_Overhead(). Its internal logic, which calculates resource depletion based on population size, remains identical. It will now calculate corporation.headcount * average_salary_and_overhead_cost. This change is achieved by adjusting the base values used in the calculation, not the code itself.

Prompts: No direct prompts are associated with this engine. Its logic is purely mathematical.

engines/faction_engine.py
Logic: This engine will now simulate inter-departmental politics. The faction.approval key becomes department.morale. The existing logic that reduces approval for factions whose goals are ignored is perfectly preserved; it will now model the morale drop in a department that loses a budget battle or has its projects de-prioritized.

Prompts (prompts/factions/faction_audience.txt): This is a critical rewrite.

Old Context: A meeting where tribal factions (Hunters, Elders) petition their leader for resources or policy changes.   

New Context: A "Quarterly Budget Allocation Meeting" or "Strategic Planning Session."

New Prompt Strategy: The prompt must instruct the AI to generate "petitions" from different department heads (e.g., "VP of Sales," "Head of R&D"). These petitions will be competing requests for the same finite resource: corporation.budget. The AI must frame the dilemma in corporate terms, focusing on Return on Investment (ROI), strategic alignment, and departmental KPIs. The player will be forced to choose which department's initiative to fund, directly impacting the morale of all involved.

engines/council_engine.py
Logic: This becomes the primary engine for all formal meetings. It can be triggered for various events like "Project Kickoff," "Performance Review," or "Task Delegation," depending on the prompt used.

Prompts (prompts/council/council_meeting.txt): This prompt will be rewritten to simulate a standard management meeting, such as a "Weekly Team Sync."

Old Context: Advisors report on the state of the realm and present a major dilemma (e.g., famine, war).   

New Context: The player's direct reports or colleagues provide status updates on their projects. The "Central Dilemma" is now a specific, project-related problem (e.g., "A key team member just resigned," "The client has requested a major change in scope," "We're projected to miss our Q3 deadline"). The AI's output should be in the form of professional dialogue and meeting minutes.

engines/crisis_engine.py
Logic: The detect_crisis() function's conditions must be adjusted. Instead of food <= 0, it will now trigger on corporation.budget <= 0. Instead of population_happiness < 20, it will trigger on company.morale < 20.

Prompts (prompts/crises/*.txt): All crisis prompts must be mapped and completely rewritten to reflect corporate disasters.

famine.txt -> BudgetFreeze.txt: The narrative will describe a company-wide spending freeze, hiring freezes, and the potential cancellation of non-essential projects.

economic_collapse.txt -> BankruptcyWarning.txt: The narrative will detail severe financial distress, warnings from the CFO, and the possibility of insolvency and legal proceedings.

succession_crisis.txt -> CEO_Resignation.txt or Major_ReOrg.txt: The narrative will focus on a leadership vacuum, power struggles between executives, departmental silos, and widespread uncertainty about the company's future direction.

Step 3: New Concept Integration & Prompting Strategy
This final section details how to weave the new core concepts into the refactored system and establishes the "golden rules" for prompt engineering to ensure a cohesive and professional-sounding experience.

3.1 The "Player Ladder" Integration
The player.title variable is the single most important piece of context for the AI. It dictates the scope, scale, and nature of every event the player experiences, ensuring the simulation feels authentic to the player's role.

Implementation Strategy: The player.title must be passed as a context variable into every prompt that generates an event (event_generator.py, crisis_engine.py, council_engine.py). The prompts themselves will contain explicit logic instructing the AI to filter its output based on this role.

Prompt Examples:

Instruction within prompts/events/generate_event.txt:

<PLAYER_ROLE_CONTEXT>
The player's current title is: {player.title}.
Your generated event MUST be appropriate for this level of seniority.
- If "Junior Analyst", the event should be a micro-task, a request from a manager, or a peer-level interaction.
- If "Manager", the event should be about team management, project deadlines, or cross-team coordination.
- If "CEO", the event should be about company-wide strategy, board meetings, or major financial decisions.
A Junior Analyst should NEVER receive an event about setting company-wide policy.
</PLAYER_ROLE_CONTEXT>
Example Event for player.title == "Junior Analyst":

Title: "Urgent Request from your Manager"

Narrative: "You receive a Slack message from your manager, Sarah: 'Hey, the client data for the Q3 report is corrupted. Can you drop everything and fix the export script? I need it by EOD.'"

Example Event for player.title == "CEO":

Title: "Emergency Board Meeting"

Narrative: "Your Executive Assistant informs you that the board has called an emergency meeting. The latest quarterly projections have severely missed their targets, and the major investors are demanding an immediate explanation and a revised strategy."

3.2 Universal Corporate Inputs & Outputs
This confirms the mapping of the core simulation variables as requested, clarifying the flow of resources within the corporate simulation.

Inputs (Resources the Corporation Consumes/Manages):

corporation.budget (from food): The primary financial resource. Generated by successful projects and consumed by overhead (salaries, rent, etc.).

corporation.headcount (from population): The primary human resource. Increases through hiring, decreases through attrition or layoffs.

Outputs (Metrics the Corporation Produces):

Internal:

department.morale (from faction.approval): The health and satisfaction of individual business units.

company.morale (from population_happiness): The overall morale of the entire company, affecting productivity.

External/Player-Centric:

corporation.revenue (modeled via budget generation): The successful generation of corporation.budget. This will be a direct outcome of player decisions in prompts (e.g., "Your decision to launch the product early resulted in +$500,000 in initial revenue.").

player.political_capital (from wealth): The player's personal influence and network. Gained by successfully navigating politics, completing high-visibility projects, and building relationships. Spent to push through unpopular decisions or gain support for initiatives.

3.3 Final Prompting Strategy: The 5 Golden Rules
These are immutable principles for the prompt engineering team to ensure a cohesive, professional, and effective Corporate Decision Simulator.

Maintain a Professional Lexicon. All AI-generated text must use modern business and corporate language. Avoid archaic (my lord, chieftain) or overly casual terms. Incorporate terms like "Q3," "KPIs," "stakeholders," "deliverables," "synergy," "bandwidth," and "action items." The AI's persona is that of a corporate environment, not a fantasy storyteller.

Filter All Events Through the Player Ladder. Every single event, crisis, or meeting must be strictly scoped to the player.title. A junior employee should never be asked to weigh in on M&A strategy. A CEO should not receive a task to fix a software bug. This is the most critical rule for ensuring role-play authenticity and creating a believable career progression.

Frame Dilemmas as Business Trade-Offs. Corporate decisions are rarely about good versus evil. They are about navigating trade-offs between competing, often equally valid, priorities (e.g., speed vs. quality, short-term profit vs. long-term growth, employee morale vs. budget cuts). All decision prompts must frame choices in these terms, forcing the player to think strategically.

Quantify Outcomes. Whenever possible, AI-generated outcomes should include quantifiable business metrics. Instead of "The project was a success," the output should be "The project was completed on time and generated an initial revenue of $250,000, increasing Sales department morale by 5 points." This directly connects the narrative choices to the underlying simulation mechanics, making the cause-and-effect relationships clear to the user.

The Player is an Employee, Not a Monarch. The player does not have absolute power. Decisions may require buy-in from stakeholders (key_personnel), face resistance from departments (departments), or be overruled by a board of directors (a potential high-level crisis event). Prompts should reflect that the player operates within a complex system of constraints and influences, reinforcing the realism of the corporate environment.




################################################################################
# FILE: refactor_prompt.txt
# Size: 1068 bytes
################################################################################

[TASK]
You are an expert AI refactoring engine. Your one and only job is to apply the rules from the attached `REFACTOR_BLUEPRINT.md` to the single attached code/text file.

[CONTEXT]
You will receive:
1.  `REFACTOR_BLUEPRINT.md`: The master plan for the entire project.
2.  A single target file (e.g., `engines/faction_engine.py` or `prompts/crises/famine.txt`).

[INSTRUCTIONS]
1.  Read the `REFACTOR_BLUEPRINT.md` to understand the overall goal (e.g., "factions" are now "departments").
2.  Read the single target file provided.
3.  Apply the *specific* transformations from the blueprint that are relevant *only to that file*.
4.  If it's a `.py` file: Refactor all variable names, class names, and comments to match the blueprint's "Corporate" theme.
5.  If it's a `.txt` prompt file: Completely rewrite the prompt from scratch to match the new "Corporate" theme, tone, and context, as specified in the blueprint.
6.  **Your output must be *only* the new, complete, refactored file content. Do not add any conversation, greetings, or explanations.**


################################################################################
# FILE: run_refactor.bat
# Size: 1008 bytes
################################################################################

@echo off
echo.
echo =======================================================
echo    JULES AUTONOMOUS REFACTOR BOT LAUNCHER
echo =======================================================
echo.
echo This will start the Gemini CLI in YOLO (auto-approve) mode
echo and pass it your main refactor prompt.
echo.
echo Jules will run in the background via your GitHub integration.
echo.
echo Press Ctrl+C to cancel
echo.
pause
echo Launching...
echo.

:: This is the key:
:: 1. `gemini` - Starts the CLI.
:: 2. `--yolo` - Enables YOLO mode, auto-approving all actions.
:: 3. `-p "jules_refactor_prompt.txt"` - Passes your entire prompt file non-interactively.

gemini --yolo -p "jules_refactor_prompt.txt"

echo.
echo =======================================================
echo Task has been sent to Jules.
echo You can now check its status with 'gemini' and then:
echo /jules what is the status of my last task?
echo =======================================================
echo.
pause


################################################################################
# FILE: unpack.py
# Size: 2469 bytes
################################################################################

import os
import re

# This is the name of the file you uploaded.
SOURCE_FILE = "corporate_simulator_project V1.0.txt"

# Regex to find the start of a new file in the export
# Looks for: ################################################################################
#             # FILE: old_codebase\engines\action_processor.py
file_header_regex = re.compile(
    r"#{80}\n# FILE: (.*?)\n# Size: \d+ bytes\n#{80}\n\n(.*?)\n\n(?=#{80})",
    re.DOTALL
)

def unpack_project():
    print(f"Starting to unpack '{SOURCE_FILE}'...")
    
    try:
        with open(SOURCE_FILE, 'r', encoding='utf-8') as f:
            content = f.read()
    except FileNotFoundError:
        print(f"Error: '{SOURCE_FILE}' not found.")
        print("Please make sure the export file is in the same directory as this script.")
        return
    except Exception as e:
        print(f"Error reading file: {e}")
        return

    # Find all file matches
    matches = file_header_regex.findall(content)
    
    if not matches:
        print("Error: Could not find any file headers in the source file.")
        print("Please check the file format.")
        return

    print(f"Found {len(matches)} files to create.")
    created_count = 0

    for match in matches:
        file_path_str, file_content = match
        
        # Clean up the file path (remove extra spaces)
        file_path_str = file_path_str.strip()
        
        # We need to remove the "old_codebase\" prefix for os.path.join
        # and then re-add it to ensure correct directory creation.
        
        # Normalize paths for OS
        file_path = os.path.normpath(file_path_str)
        
        try:
            # Get the directory part of the path
            directory = os.path.dirname(file_path)
            
            # Create the directory if it doesn't exist
            if directory:
                os.makedirs(directory, exist_ok=True)
                
            # Write the file content
            with open(file_path, 'w', encoding='utf-8') as out_f:
                out_f.write(file_content)
                
            print(f"  [OK] Created: {file_path}")
            created_count += 1
            
        except Exception as e:
            print(f"  [FAIL] Error creating {file_path}: {e}")

    print(f"\nUnpack complete. Created {created_count} files.")

if __name__ == "__main__":
    unpack_project()

